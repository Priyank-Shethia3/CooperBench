diff --git a/src/PIL/Image.py b/src/PIL/Image.py
index 0fca3fa5c..9db7dd2b1 100644
--- a/src/PIL/Image.py
+++ b/src/PIL/Image.py
@@ -1048,35 +1048,87 @@ class Image:
                 new_im.info["transparency"] = trns
         return new_im
 
-    def quantize(self, colors=256, method=None, kmeans=0, palette=None, dither=1):
+    def quantize(self, colors=256, method=None, kmeans=0, palette=None, dither=1, max_colors=None, sort_palette=None, error_threshold=None, lightness_factor=1.0):
         """
         Convert the image to 'P' mode with the specified number
         of colors.
 
         :param colors: The desired number of colors, <= 256
         :param method: :data:`MEDIANCUT` (median cut),
-                       :data:`MAXCOVERAGE` (maximum coverage),
-                       :data:`FASTOCTREE` (fast octree),
-                       :data:`LIBIMAGEQUANT` (libimagequant; check support using
-                       :py:func:`PIL.features.check_feature`
-                       with ``feature="libimagequant"``).
+                    :data:`MAXCOVERAGE` (maximum coverage),
+                    :data:`FASTOCTREE` (fast octree),
+                    :data:`LIBIMAGEQUANT` (libimagequant; check support using
+                    :py:func:`PIL.features.check_feature`
+                    with ``feature="libimagequant"``).
 
-                       By default, :data:`MEDIANCUT` will be used.
+                    By default, :data:`MEDIANCUT` will be used.
 
-                       The exception to this is RGBA images. :data:`MEDIANCUT` and
-                       :data:`MAXCOVERAGE` do not support RGBA images, so
-                       :data:`FASTOCTREE` is used by default instead.
+                    The exception to this is RGBA images. :data:`MEDIANCUT` and
+                    :data:`MAXCOVERAGE` do not support RGBA images, so
+                    :data:`FASTOCTREE` is used by default instead.
         :param kmeans: Integer
         :param palette: Quantize to the palette of given
                         :py:class:`PIL.Image.Image`.
         :param dither: Dithering method, used when converting from
-           mode "RGB" to "P" or from "RGB" or "L" to "1".
-           Available methods are :data:`NONE` or :data:`FLOYDSTEINBERG` (default).
-           Default: 1 (legacy setting)
+        mode "RGB" to "P" or from "RGB" or "L" to "1".
+        Available methods are :data:`NONE` or :data:`FLOYDSTEINBERG` (default).
+        Default: 1 (legacy setting)
+        :param max_colors: Maximum number of colors to use in the palette.
+                        If specified, the actual number of colors will be
+                        min(colors, max_colors). Defaults to the value of colors.
+        :param sort_palette: Method for sorting the palette colors:
+                            "brightness" (by simple sum of RGB values),
+                            "rgb" (by red, then green, then blue)
+        :param error_threshold: Maximum acceptable mean square error between
+                            original and quantized image. If provided, the
+                            quantization will use as few colors as possible
+                            while staying below this threshold.
+        :param lightness_factor: Factor to adjust the brightness of palette colors.
+                                Values > 1.0 lighten the image, values < 1.0 darken.
+                                Default is 1.0 (no change).
         :returns: A new image
 
         """
 
+        def _adjust_palette_lightness(image, factor):
+            """
+            Adjust the brightness of a paletted image by modifying its palette.
+
+            Args:
+                image: A PIL image in 'P' mode with a palette
+                factor: Brightness factor (>1.0 lightens, <1.0 darkens)
+
+            Returns:
+                A new image with adjusted palette
+            """
+            if image.mode != "P":
+                return image
+
+            # Get current palette
+            palette = image.getpalette()
+            if not palette:
+                return image
+
+            # Create a new palette with adjusted brightness
+            new_palette = []
+            for i in range(0, len(palette), 3):
+                r, g, b = palette[i:i+3]
+
+                # Apply brightness factor and clamp to valid range
+                r = min(255, max(0, int(r * factor)))
+                g = min(255, max(0, int(g * factor)))
+                b = min(255, max(0, int(b * factor)))
+
+                new_palette.extend([r, g, b])
+
+            # Create a new image with the same data but adjusted palette
+            from PIL import Image
+
+            new_img = image.copy()
+            new_img.putpalette(new_palette)
+
+            return new_img
+
         self.load()
 
         if method is None:
@@ -1092,6 +1144,54 @@ class Image:
                 "are the only valid methods for quantizing RGBA images"
             )
 
+        # Validate lightness_factor
+        if lightness_factor <= 0:
+            raise ValueError("lightness_factor must be greater than 0")
+
+        # If max_colors is not specified, use the colors parameter
+        if max_colors is None:
+            max_colors = colors
+        else:
+            # Make sure max_colors is not larger than colors
+            colors = min(colors, max_colors)
+
+        # Handle error threshold-based quantization
+        if error_threshold is not None and palette is None:
+            import numpy as np
+            orig_array = np.array(self)
+
+            # Binary search for the optimal number of colors to meet the error threshold
+            min_colors = 2
+            max_colors_search = min(colors, 256)
+            best_colors = max_colors_search
+            best_image = None
+
+            while min_colors < max_colors_search:
+                mid_colors = (min_colors + max_colors_search) // 2
+                test_image = self._new(self.im.quantize(mid_colors, method, kmeans))
+
+                # Calculate error
+                from . import ImagePalette
+                mode = test_image.im.getpalettemode()
+                test_image.palette = ImagePalette.ImagePalette(mode, test_image.im.getpalette(mode, mode))
+
+                test_rgb = test_image.convert("RGB")
+                test_array = np.array(test_rgb)
+                mse = np.mean((orig_array - test_array) ** 2)
+
+                if mse <= error_threshold:
+                    # This is good enough, but we can try fewer colors
+                    best_colors = mid_colors
+                    best_image = test_image
+                    max_colors_search = mid_colors
+                else:
+                    # Need more colors
+                    min_colors = mid_colors + 1
+
+            # Return the best image that meets the threshold
+            if best_image:
+                return best_image
+
         if palette:
             # use palette from reference image
             palette.load()
@@ -1104,6 +1204,18 @@ class Image:
             im = self.im.convert("P", dither, palette.im)
             new_im = self._new(im)
             new_im.palette = palette.palette.copy()
+
+            # Apply max_colors limit if needed
+            if max_colors < 256 and new_im.palette:
+                colors_used = len(new_im.getcolors(256))
+                if colors_used > max_colors:
+                    # Requantize to the max_colors limit
+                    return new_im.quantize(max_colors, method, kmeans)
+
+            # Apply lightness adjustment if needed
+            if lightness_factor != 1.0:
+                new_im = _adjust_palette_lightness(new_im, lightness_factor)
+
             return new_im
 
         im = self._new(self.im.quantize(colors, method, kmeans))
@@ -1111,7 +1223,40 @@ class Image:
         from . import ImagePalette
 
         mode = im.im.getpalettemode()
-        im.palette = ImagePalette.ImagePalette(mode, im.im.getpalette(mode, mode))
+        # Feature 1: Limit palette to number of colors
+        palette_data = im.im.getpalette(mode, mode)[: colors * len(mode)]
+
+        # Feature 3: If sort_palette parameter is provided, sort the palette
+        if sort_palette is not None:
+            # Extract RGB tuples from the palette
+            rgb_tuples = []
+            for i in range(0, len(palette_data), len(mode)):
+                rgb_tuples.append(tuple(palette_data[i:i+len(mode)]))
+
+            # Sort the palette according to the chosen method
+            if sort_palette == "brightness":
+                # Sort by simple brightness (sum of RGB values)
+                sorted_indices = sorted(
+                    range(len(rgb_tuples)),
+                    key=lambda i: sum(rgb_tuples[i])
+                )
+            elif sort_palette == "rgb":
+                # Sort by RGB values (R primary, then G, then B)
+                sorted_indices = sorted(range(len(rgb_tuples)), key=lambda i: rgb_tuples[i])
+            else:
+                sorted_indices = list(range(len(rgb_tuples)))
+
+            # Rearrange the palette based on the sorted indices
+            sorted_palette = []
+            for idx in sorted_indices:
+                sorted_palette.extend(rgb_tuples[idx])
+            palette_data = sorted_palette
+
+        im.palette = ImagePalette.ImagePalette(mode, palette_data)
+
+        # Feature 5: Apply lightness adjustment if needed
+        if lightness_factor != 1.0:
+            im = _adjust_palette_lightness(im, lightness_factor)
 
         return im
 
