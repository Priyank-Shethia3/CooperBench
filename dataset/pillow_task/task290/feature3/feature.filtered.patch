diff --git a/src/PIL/Image.py b/src/PIL/Image.py
index 0fca3fa5c..cf0718f61 100644
--- a/src/PIL/Image.py
+++ b/src/PIL/Image.py
@@ -1048,31 +1048,34 @@ class Image:
                 new_im.info["transparency"] = trns
         return new_im
 
-    def quantize(self, colors=256, method=None, kmeans=0, palette=None, dither=1):
+    def quantize(self, colors=256, method=None, kmeans=0, palette=None, dither=1, sort_palette=None):
         """
         Convert the image to 'P' mode with the specified number
         of colors.
 
         :param colors: The desired number of colors, <= 256
-        :param method: :data:`MEDIANCUT` (median cut),
-                       :data:`MAXCOVERAGE` (maximum coverage),
-                       :data:`FASTOCTREE` (fast octree),
-                       :data:`LIBIMAGEQUANT` (libimagequant; check support using
-                       :py:func:`PIL.features.check_feature`
-                       with ``feature="libimagequant"``).
-
-                       By default, :data:`MEDIANCUT` will be used.
-
-                       The exception to this is RGBA images. :data:`MEDIANCUT` and
-                       :data:`MAXCOVERAGE` do not support RGBA images, so
-                       :data:`FASTOCTREE` is used by default instead.
-        :param kmeans: Integer
+        :param method: :data:`~PIL.Image.MEDIANCUT` (median cut),
+                    :data:`~PIL.Image.MAXCOVERAGE` (maximum coverage),
+                    :data:`~PIL.Image.FASTOCTREE` (fast octree),
+                    :data:`~PIL.Image.LIBIMAGEQUANT` (libimagequant; check support
+                    using :py:func:`PIL.features.check_feature` with
+                    ``feature="libimagequant"``).
+
+                    By default, :data:`~PIL.Image.MEDIANCUT` will be used.
+
+                    The exception to this is RGBA images. :data:`~PIL.Image.MEDIANCUT`
+                    and :data:`~PIL.Image.MAXCOVERAGE` do not support RGBA images, so
+                    :data:`~PIL.Image.FASTOCTREE` is used by default instead.
+        :param kmeans: Integer greater than or equal to zero.
         :param palette: Quantize to the palette of given
-                        :py:class:`PIL.Image.Image`.
+                    :py:class:`PIL.Image.Image`.
         :param dither: Dithering method, used when converting from
-           mode "RGB" to "P" or from "RGB" or "L" to "1".
-           Available methods are :data:`NONE` or :data:`FLOYDSTEINBERG` (default).
-           Default: 1 (legacy setting)
+        mode "RGB" to "P" or from "RGB" or "L" to "1".
+        Available methods are :data:`~PIL.Image.NONE` or :data:`~PIL.Image.FLOYDSTEINBERG`
+        (default).
+        :param sort_palette: Method for sorting the palette colors:
+                            "brightness" (by simple sum of RGB values),
+                            "rgb" (by red, then green, then blue)
         :returns: A new image
 
         """
@@ -1081,37 +1084,71 @@ class Image:
 
         if method is None:
             # defaults:
-            method = MEDIANCUT
+            method = 0  # MEDIANCUT
             if self.mode == "RGBA":
-                method = FASTOCTREE
+                method = 2  # FASTOCTREE
 
-        if self.mode == "RGBA" and method not in (FASTOCTREE, LIBIMAGEQUANT):
+        if self.mode == "RGBA" and method not in (2, 3):  # FASTOCTREE, LIBIMAGEQUANT
             # Caller specified an invalid mode.
-            raise ValueError(
+            msg = (
                 "Fast Octree (method == 2) and libimagequant (method == 3) "
                 "are the only valid methods for quantizing RGBA images"
             )
+            raise ValueError(msg)
 
         if palette:
             # use palette from reference image
             palette.load()
             if palette.mode != "P":
-                raise ValueError("bad mode for palette image")
-            if self.mode != "RGB" and self.mode != "L":
-                raise ValueError(
-                    "only RGB or L mode images can be quantized to a palette"
-                )
+                msg = "bad mode for palette image"
+                raise ValueError(msg)
+            if self.mode not in {"RGB", "L"}:
+                msg = "only RGB or L mode images can be quantized to a palette"
+                raise ValueError(msg)
             im = self.im.convert("P", dither, palette.im)
             new_im = self._new(im)
+            assert palette.palette is not None
             new_im.palette = palette.palette.copy()
             return new_im
 
+        if kmeans < 0:
+            msg = "kmeans must not be negative"
+            raise ValueError(msg)
+
         im = self._new(self.im.quantize(colors, method, kmeans))
 
         from . import ImagePalette
 
         mode = im.im.getpalettemode()
-        im.palette = ImagePalette.ImagePalette(mode, im.im.getpalette(mode, mode))
+        palette_data = im.im.getpalette(mode, mode)[:colors * len(mode)]
+ 
+        # If sort_palette parameter is provided, sort the palette
+        if sort_palette is not None:
+            # Extract RGB tuples from the palette
+            rgb_tuples = []
+            for i in range(0, len(palette_data), len(mode)):
+                rgb_tuples.append(tuple(palette_data[i:i+len(mode)]))
+ 
+            # Sort the palette according to the chosen method
+            if sort_palette == "brightness":
+                # Sort by simple brightness (sum of RGB values)
+                sorted_indices = sorted(
+                    range(len(rgb_tuples)), 
+                    key=lambda i: sum(rgb_tuples[i])
+                )
+            elif sort_palette == "rgb":
+                # Sort by RGB values (R primary, then G, then B)
+                sorted_indices = sorted(range(len(rgb_tuples)), key=lambda i: rgb_tuples[i])
+            else:
+                sorted_indices = list(range(len(rgb_tuples)))
+ 
+            # Rearrange the palette based on the sorted indices
+            sorted_palette = []
+            for idx in sorted_indices:
+                sorted_palette.extend(rgb_tuples[idx])
+            palette_data = sorted_palette
+ 
+        im.palette = ImagePalette.ImagePalette(mode, palette_data)
 
         return im
 

