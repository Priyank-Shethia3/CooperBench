diff --git a/src/PIL/Image.py b/src/PIL/Image.py
index 0fca3fa5c..a7bddac48 100644
--- a/src/PIL/Image.py
+++ b/src/PIL/Image.py
@@ -1048,34 +1048,76 @@ class Image:
                 new_im.info["transparency"] = trns
         return new_im
 
-    def quantize(self, colors=256, method=None, kmeans=0, palette=None, dither=1):
+    def quantize(self, colors=256, method=None, kmeans=0, palette=None, dither=1, lightness_factor=1.0):
         """
         Convert the image to 'P' mode with the specified number
         of colors.
 
         :param colors: The desired number of colors, <= 256
         :param method: :data:`MEDIANCUT` (median cut),
-                       :data:`MAXCOVERAGE` (maximum coverage),
-                       :data:`FASTOCTREE` (fast octree),
-                       :data:`LIBIMAGEQUANT` (libimagequant; check support using
-                       :py:func:`PIL.features.check_feature`
-                       with ``feature="libimagequant"``).
+                    :data:`MAXCOVERAGE` (maximum coverage),
+                    :data:`FASTOCTREE` (fast octree),
+                    :data:`LIBIMAGEQUANT` (libimagequant; check support using
+                    :py:func:`PIL.features.check_feature`
+                    with ``feature="libimagequant"``).
 
-                       By default, :data:`MEDIANCUT` will be used.
+                    By default, :data:`MEDIANCUT` will be used.
 
-                       The exception to this is RGBA images. :data:`MEDIANCUT` and
-                       :data:`MAXCOVERAGE` do not support RGBA images, so
-                       :data:`FASTOCTREE` is used by default instead.
+                    The exception to this is RGBA images. :data:`MEDIANCUT` and
+                    :data:`MAXCOVERAGE` do not support RGBA images, so
+                    :data:`FASTOCTREE` is used by default instead.
         :param kmeans: Integer
         :param palette: Quantize to the palette of given
                         :py:class:`PIL.Image.Image`.
         :param dither: Dithering method, used when converting from
-           mode "RGB" to "P" or from "RGB" or "L" to "1".
-           Available methods are :data:`NONE` or :data:`FLOYDSTEINBERG` (default).
-           Default: 1 (legacy setting)
+        mode "RGB" to "P" or from "RGB" or "L" to "1".
+        Available methods are :data:`NONE` or :data:`FLOYDSTEINBERG` (default).
+        Default: 1 (legacy setting)
+        :param lightness_factor: Factor to adjust the brightness of palette colors.
+                                Values > 1.0 lighten the image, values < 1.0 darken.
+                                Default is 1.0 (no change).
         :returns: A new image
 
         """
+ 
+        def _adjust_palette_lightness(image, factor):
+            """
+            Adjust the brightness of a paletted image by modifying its palette.
+ 
+            Args:
+                image: A PIL image in 'P' mode with a palette
+                factor: Brightness factor (>1.0 lightens, <1.0 darkens)
+ 
+            Returns:
+                A new image with adjusted palette
+            """
+            if image.mode != "P":
+                return image
+ 
+            # Get current palette
+            palette = image.getpalette()
+            if not palette:
+                return image
+ 
+            # Create a new palette with adjusted brightness
+            new_palette = []
+            for i in range(0, len(palette), 3):
+                r, g, b = palette[i:i+3]
+ 
+                # Apply brightness factor and clamp to valid range
+                r = min(255, max(0, int(r * factor)))
+                g = min(255, max(0, int(g * factor)))
+                b = min(255, max(0, int(b * factor)))
+ 
+                new_palette.extend([r, g, b])
+ 
+            # Create a new image with the same data but adjusted palette
+            from PIL import Image
+ 
+            new_img = image.copy()
+            new_img.putpalette(new_palette)
+ 
+            return new_img
 
         self.load()
 
@@ -1092,6 +1134,10 @@ class Image:
                 "are the only valid methods for quantizing RGBA images"
             )
 
+        # Validate lightness_factor
+        if lightness_factor <= 0:
+            raise ValueError("lightness_factor must be greater than 0")
+
         if palette:
             # use palette from reference image
             palette.load()
@@ -1104,6 +1150,11 @@ class Image:
             im = self.im.convert("P", dither, palette.im)
             new_im = self._new(im)
             new_im.palette = palette.palette.copy()
+ 
+            # Apply lightness adjustment if needed
+            if lightness_factor != 1.0:
+                new_im = _adjust_palette_lightness(new_im, lightness_factor)
+ 
             return new_im
 
         im = self._new(self.im.quantize(colors, method, kmeans))
@@ -1112,6 +1163,10 @@ class Image:
 
         mode = im.im.getpalettemode()
         im.palette = ImagePalette.ImagePalette(mode, im.im.getpalette(mode, mode))
+ 
+        # Apply lightness adjustment if needed
+        if lightness_factor != 1.0:
+            im = _adjust_palette_lightness(im, lightness_factor)
 
         return im
 
