diff --git a/src/PIL/Image.py b/src/PIL/Image.py
index 0fca3fa5c..2f1f8e0ce 100644
--- a/src/PIL/Image.py
+++ b/src/PIL/Image.py
@@ -1048,33 +1048,36 @@ class Image:
                 new_im.info["transparency"] = trns
         return new_im
 
-    def quantize(self, colors=256, method=None, kmeans=0, palette=None, dither=1):
+    def quantize(self, colors=256, method=None, kmeans=0, palette=None, dither=1, error_threshold=None):
         """
         Convert the image to 'P' mode with the specified number
         of colors.
 
         :param colors: The desired number of colors, <= 256
         :param method: :data:`MEDIANCUT` (median cut),
-                       :data:`MAXCOVERAGE` (maximum coverage),
-                       :data:`FASTOCTREE` (fast octree),
-                       :data:`LIBIMAGEQUANT` (libimagequant; check support using
-                       :py:func:`PIL.features.check_feature`
-                       with ``feature="libimagequant"``).
+                    :data:`MAXCOVERAGE` (maximum coverage),
+                    :data:`FASTOCTREE` (fast octree),
+                    :data:`LIBIMAGEQUANT` (libimagequant; check support using
+                    :py:func:`PIL.features.check_feature`
+                    with ``feature="libimagequant"``).
 
-                       By default, :data:`MEDIANCUT` will be used.
+                    By default, :data:`MEDIANCUT` will be used.
 
-                       The exception to this is RGBA images. :data:`MEDIANCUT` and
-                       :data:`MAXCOVERAGE` do not support RGBA images, so
-                       :data:`FASTOCTREE` is used by default instead.
+                    The exception to this is RGBA images. :data:`MEDIANCUT` and
+                    :data:`MAXCOVERAGE` do not support RGBA images, so
+                    :data:`FASTOCTREE` is used by default instead.
         :param kmeans: Integer
         :param palette: Quantize to the palette of given
                         :py:class:`PIL.Image.Image`.
         :param dither: Dithering method, used when converting from
-           mode "RGB" to "P" or from "RGB" or "L" to "1".
-           Available methods are :data:`NONE` or :data:`FLOYDSTEINBERG` (default).
-           Default: 1 (legacy setting)
+        mode "RGB" to "P" or from "RGB" or "L" to "1".
+        Available methods are :data:`NONE` or :data:`FLOYDSTEINBERG` (default).
+        Default: 1 (legacy setting)
+        :param error_threshold: Maximum acceptable mean square error between
+                            original and quantized image. If provided, the
+                            quantization will use as few colors as possible
+                            while staying below this threshold.
         :returns: A new image
-
         """
 
         self.load()
@@ -1092,6 +1095,43 @@ class Image:
                 "are the only valid methods for quantizing RGBA images"
             )
 
+        # Handle error threshold-based quantization
+        if error_threshold is not None and palette is None:
+            import numpy as np
+            orig_array = np.array(self)
+ 
+            # Binary search for the optimal number of colors to meet the error threshold
+            min_colors = 2
+            max_colors = min(colors, 256)
+            best_colors = max_colors
+            best_image = None
+ 
+            while min_colors < max_colors:
+                mid_colors = (min_colors + max_colors) // 2
+                test_image = self._new(self.im.quantize(mid_colors, method, kmeans))
+ 
+                # Calculate error
+                from . import ImagePalette
+                mode = test_image.im.getpalettemode()
+                test_image.palette = ImagePalette.ImagePalette(mode, test_image.im.getpalette(mode, mode))
+ 
+                test_rgb = test_image.convert("RGB")
+                test_array = np.array(test_rgb)
+                mse = np.mean((orig_array - test_array) ** 2)
+ 
+                if mse <= error_threshold:
+                    # This is good enough, but we can try fewer colors
+                    best_colors = mid_colors
+                    best_image = test_image
+                    max_colors = mid_colors
+                else:
+                    # Need more colors
+                    min_colors = mid_colors + 1
+ 
+            # Return the best image that meets the threshold
+            if best_image:
+                return best_image
+ 
         if palette:
             # use palette from reference image
             palette.load()

