diff --git a/src/PIL/ImageOps.py b/src/PIL/ImageOps.py
index fef1d7328..8badef58b 100644
--- a/src/PIL/ImageOps.py
+++ b/src/PIL/ImageOps.py
@@ -23,6 +23,7 @@ import operator
 import re
 from collections.abc import Sequence
 from typing import Literal, Protocol, cast, overload
+import logging
 
 from . import ExifTags, Image, ImagePalette
 
@@ -683,7 +684,12 @@ def exif_transpose(
 ) -> Image.Image: ...
 
 
-def exif_transpose(image: Image.Image, *, in_place: bool = False) -> Image.Image | None:
+def exif_transpose(
+    image: Image.Image, 
+    *, 
+    in_place: bool = False,
+    logger: Any = None
+) -> Image.Image | None:
     """
     If an image has an EXIF Orientation tag, other than 1, transpose the image
     accordingly, and remove the orientation data.
@@ -694,10 +700,30 @@ def exif_transpose(image: Image.Image, *, in_place: bool = False) -> Image.Image
         If ``False`` (default), a new :py:class:`~PIL.Image.Image` object is returned
         with the transposition applied. If there is no transposition, a copy of the
         image will be returned.
-    """
+    :param logger: Logger or callable. Keyword-only argument.
+        If provided, logging information will be sent to this logger during processing.
+        Can be a standard Python logger or a callable that accepts a message and optional level.
+    """
+    # Helper function to log messages
+    def log_message(message, level="INFO"):
+        if logger is None:
+            return
+ 
+        if hasattr(logger, "log"):
+            # Standard Python logger
+            log_level = getattr(logging, level, logging.INFO)
+            logger.log(log_level, message)
+        else:
+            # Callable logger
+            logger(message, level)
+ 
     image.load()
     image_exif = image.getexif()
     orientation = image_exif.get(ExifTags.Base.Orientation, 1)
+ 
+    log_message(f"Processing image with dimensions {image.size}", "DEBUG")
+    log_message(f"Orientation value: {orientation}")
+ 
     method = {
         2: Image.Transpose.FLIP_LEFT_RIGHT,
         3: Image.Transpose.ROTATE_180,
@@ -707,23 +733,35 @@ def exif_transpose(image: Image.Image, *, in_place: bool = False) -> Image.Image
         7: Image.Transpose.TRANSVERSE,
         8: Image.Transpose.ROTATE_90,
     }.get(orientation)
+ 
     if method is not None:
+        log_message(f"Applying transformation: {method.name}")
+ 
         if in_place:
+            log_message("Performing in-place transformation")
             image.im = image.im.transpose(method)
             image._size = image.im.size
         else:
             transposed_image = image.transpose(method)
+            log_message(f"Created new transposed image with dimensions {transposed_image.size}", "DEBUG")
+ 
         exif_image = image if in_place else transposed_image
 
         exif = exif_image.getexif()
         if ExifTags.Base.Orientation in exif:
+            log_message("Removing orientation from metadata")
             del exif[ExifTags.Base.Orientation]
+ 
             if "exif" in exif_image.info:
+                log_message("Updating EXIF data", "DEBUG")
                 exif_image.info["exif"] = exif.tobytes()
             elif "Raw profile type exif" in exif_image.info:
+                log_message("Updating Raw profile type exif", "DEBUG")
                 exif_image.info["Raw profile type exif"] = exif.tobytes().hex()
+ 
             for key in ("XML:com.adobe.xmp", "xmp"):
                 if key in exif_image.info:
+                    log_message(f"Processing {key} metadata", "DEBUG")
                     for pattern in (
                         r'tiff:Orientation="([0-9])"',
                         r"<tiff:Orientation>([0-9])</tiff:Orientation>",
@@ -734,8 +772,17 @@ def exif_transpose(image: Image.Image, *, in_place: bool = False) -> Image.Image
                             if isinstance(value, str)
                             else re.sub(pattern.encode(), b"", value)
                         )
+        else:
+            log_message("No orientation data found in EXIF metadata", "DEBUG")
+ 
+        log_message("Transposition completed successfully")
+ 
         if not in_place:
             return transposed_image
-    elif not in_place:
-        return image.copy()
-    return None
+    else:
+        log_message(f"No transformation needed for orientation {orientation}")
+        if not in_place:
+            log_message("Returning copy of original image", "DEBUG")
+            return image.copy()
+ 
+    return None
\ No newline at end of file

