diff --git a/src/PIL/ImageOps.py b/src/PIL/ImageOps.py
index fef1d7328..0d1514e1c 100644
--- a/src/PIL/ImageOps.py
+++ b/src/PIL/ImageOps.py
@@ -22,7 +22,7 @@ import functools
 import operator
 import re
 from collections.abc import Sequence
-from typing import Literal, Protocol, cast, overload
+from typing import Any, Callable, Literal, Protocol, cast, overload
 
 from . import ExifTags, Image, ImagePalette
 
@@ -683,7 +683,15 @@ def exif_transpose(
 ) -> Image.Image: ...
 
 
-def exif_transpose(image: Image.Image, *, in_place: bool = False) -> Image.Image | None:
+def exif_transpose(
+    image: Image.Image,
+    *,
+    in_place: bool = False,
+    strip_metadata: bool = False,
+    transform_callback: Callable[[int], Image.Transpose | list[Image.Transpose] | None] = None,
+    error_handler: Callable[[Exception, str, Any], Any] = None,
+    logger: Any = None
+) -> Image.Image | None:
     """
     If an image has an EXIF Orientation tag, other than 1, transpose the image
     accordingly, and remove the orientation data.
@@ -694,11 +702,44 @@ def exif_transpose(image: Image.Image, *, in_place: bool = False) -> Image.Image
         If ``False`` (default), a new :py:class:`~PIL.Image.Image` object is returned
         with the transposition applied. If there is no transposition, a copy of the
         image will be returned.
-    """
+    :param strip_metadata: Boolean. Keyword-only argument.
+        If ``True``, all metadata will be removed from the image after transposition.
+        If ``False`` (default), only orientation data is removed, preserving other metadata.
+    :param transform_callback: Callable. Keyword-only argument.
+        A function that receives the orientation value and returns a transformation method
+        or list of methods to apply. If None (default), the standard orientation mapping is used.
+        If the callback returns None, no transformation will be applied.
+    :param error_handler: Callable. Keyword-only argument.
+        A function that receives an exception, key, and value when errors occur during metadata processing.
+        If provided, the function can return a value to use instead of raising the exception,
+        or re-raise the exception. If None (default), exceptions are raised normally.
+    :param logger: Any. Keyword-only argument.
+        A logger object or callable that receives log messages. If a callable is provided,
+        it will be called with the message and level. If a standard logger is provided,
+        it will use the logger's methods. If None (default), no logging is performed.
+    """
+    def log_message(message: str, level: str = "INFO") -> None:
+        """Helper function to handle both callable and standard Python loggers."""
+        if logger is None:
+            return
+        if callable(logger):
+            logger(message, level)
+        else:
+            # Assume it's a standard logger
+            log_method = getattr(logger, level.lower(), None)
+            if log_method:
+                log_method(message)
+
+    log_message(f"Processing image with EXIF transpose, orientation detection starting", "DEBUG")
+
     image.load()
     image_exif = image.getexif()
     orientation = image_exif.get(ExifTags.Base.Orientation, 1)
-    method = {
+
+    log_message(f"Orientation value: {orientation}", "INFO")
+
+    # Default orientation to method mapping
+    default_methods = {
         2: Image.Transpose.FLIP_LEFT_RIGHT,
         3: Image.Transpose.ROTATE_180,
         4: Image.Transpose.FLIP_TOP_BOTTOM,
@@ -706,36 +747,117 @@ def exif_transpose(image: Image.Image, *, in_place: bool = False) -> Image.Image
         6: Image.Transpose.ROTATE_270,
         7: Image.Transpose.TRANSVERSE,
         8: Image.Transpose.ROTATE_90,
-    }.get(orientation)
+    }
+
+    # Get transformation method(s)
+    if transform_callback is not None:
+        method = transform_callback(orientation)
+        log_message(f"Using custom transform callback, method: {method}", "DEBUG")
+    else:
+        method = default_methods.get(orientation)
+        log_message(f"Using default transformation method: {method}", "DEBUG")
+
     if method is not None:
-        if in_place:
-            image.im = image.im.transpose(method)
-            image._size = image.im.size
-        else:
-            transposed_image = image.transpose(method)
-        exif_image = image if in_place else transposed_image
-
-        exif = exif_image.getexif()
-        if ExifTags.Base.Orientation in exif:
-            del exif[ExifTags.Base.Orientation]
-            if "exif" in exif_image.info:
-                exif_image.info["exif"] = exif.tobytes()
-            elif "Raw profile type exif" in exif_image.info:
-                exif_image.info["Raw profile type exif"] = exif.tobytes().hex()
-            for key in ("XML:com.adobe.xmp", "xmp"):
-                if key in exif_image.info:
-                    for pattern in (
-                        r'tiff:Orientation="([0-9])"',
-                        r"<tiff:Orientation>([0-9])</tiff:Orientation>",
-                    ):
-                        value = exif_image.info[key]
-                        exif_image.info[key] = (
-                            re.sub(pattern, "", value)
-                            if isinstance(value, str)
-                            else re.sub(pattern.encode(), b"", value)
-                        )
-        if not in_place:
-            return transposed_image
+        try:
+            if in_place:
+                # Handle both single transformation and list of transformations
+                if isinstance(method, list):
+                    log_message(f"Applying {len(method)} transformations in-place", "INFO")
+                    for i, m in enumerate(method):
+                        log_message(f"Applying transformation {i+1}: {m}", "DEBUG")
+                        image.im = image.im.transpose(m)
+                else:
+                    log_message(f"Applying transformation: {method.name if hasattr(method, 'name') else method}", "INFO")
+                    image.im = image.im.transpose(method)
+                image._size = image.im.size
+            else:
+                # Handle both single transformation and list of transformations
+                transposed_image = image
+                if isinstance(method, list):
+                    log_message(f"Applying {len(method)} transformations to copy", "INFO")
+                    for i, m in enumerate(method):
+                        log_message(f"Applying transformation {i+1}: {m}", "DEBUG")
+                        transposed_image = transposed_image.transpose(m)
+                else:
+                    log_message(f"Applying transformation: {method.name if hasattr(method, 'name') else method}", "INFO")
+                    transposed_image = image.transpose(method)
+
+            exif_image = image if in_place else transposed_image
+
+            if strip_metadata:
+                # Remove all metadata
+                log_message("Stripping all metadata as requested", "INFO")
+                exif_image.info = {}
+                # Create empty EXIF data
+                exif_image.info["exif"] = Image.Exif().tobytes()
+            else:
+                # Process EXIF and XMP metadata
+                log_message("Removing orientation from metadata", "INFO")
+                exif = exif_image.getexif()
+                if ExifTags.Base.Orientation in exif:
+                    del exif[ExifTags.Base.Orientation]
+                    if "exif" in exif_image.info:
+                        exif_image.info["exif"] = exif.tobytes()
+                    elif "Raw profile type exif" in exif_image.info:
+                        exif_image.info["Raw profile type exif"] = exif.tobytes().hex()
+
+                    # Process XMP data with error handling and tuple support
+                    for key in ("XML:com.adobe.xmp", "xmp"):
+                        if key in exif_image.info:
+                            for pattern in (
+                                r'tiff:Orientation="([0-9])"',
+                                r"<tiff:Orientation>([0-9])</tiff:Orientation>",
+                            ):
+                                try:
+                                    value = exif_image.info[key]
+                                    if isinstance(value, str):
+                                        value = re.sub(pattern, "", value)
+                                    elif isinstance(value, tuple):
+                                        # Feature 1: Handle tuple format for XMP
+                                        log_message(f"Processing XMP tuple data for key: {key}", "DEBUG")
+                                        value = tuple(
+                                            re.sub(pattern.encode(), b"", v) for v in value
+                                        )
+                                    else:
+                                        value = re.sub(pattern.encode(), b"", value)
+                                    exif_image.info[key] = value
+                                except Exception as e:
+                                    # Feature 4: Custom error handling
+                                    log_message(f"Error processing XMP data for key '{key}': {e}", "WARNING")
+                                    if error_handler is not None:
+                                        try:
+                                            result = error_handler(e, key, exif_image.info[key])
+                                            if result is not None:
+                                                exif_image.info[key] = result
+                                                log_message(f"Error handler returned: {result}", "DEBUG")
+                                            else:
+                                                log_message("Error handler returned None, skipping", "DEBUG")
+                                        except Exception as handler_error:
+                                            log_message(f"Error handler failed: {handler_error}, re-raising original error", "ERROR")
+                                            raise e
+                                    else:
+                                        log_message("No error handler provided, re-raising exception", "ERROR")
+                                        raise e
+
+            if not in_place:
+                log_message("Returning transposed image", "DEBUG")
+                return transposed_image
+            else:
+                log_message("In-place transformation completed", "DEBUG")
+        except Exception as e:
+            log_message(f"Error during transformation: {e}", "ERROR")
+            if error_handler is not None:
+                try:
+                    result = error_handler(e, "transformation", method)
+                    if result is not None:
+                        log_message(f"Error handler returned: {result}", "INFO")
+                        return result
+                except Exception as handler_error:
+                    log_message(f"Error handler failed: {handler_error}", "ERROR")
+            raise e
     elif not in_place:
+        log_message("No transformation needed, returning copy", "INFO")
         return image.copy()
+
+    log_message("EXIF transpose completed successfully", "INFO")
     return None
