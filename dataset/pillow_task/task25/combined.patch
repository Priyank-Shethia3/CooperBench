diff --git a/src/PIL/Image.py b/src/PIL/Image.py
index 233df592c..d4664b63f 100644
--- a/src/PIL/Image.py
+++ b/src/PIL/Image.py
@@ -2467,7 +2467,8 @@ class Image:
         )
 
     def save(
-        self, fp: StrOrBytesPath | IO[bytes], format: str | None = None, **params: Any
+        self, fp: StrOrBytesPath | IO[bytes], format: str | None = None,
+        preserve_readonly: bool = False, **params: Any
     ) -> None:
         """
         Saves this image under the given filename.  If no format is
@@ -2490,6 +2491,9 @@ class Image:
            format to use is determined from the filename extension.
            If a file object was used instead of a filename, this
            parameter should always be used.
+        :param preserve_readonly: If True, the readonly state of the image will be 
+           preserved. This is useful when saving images created with frombuffer() 
+           that need to maintain their connection to the underlying buffer.
         :param params: Extra parameters to the image writer. These can also be
            set on the image itself through ``encoderinfo``. This is useful when
            saving multiple images::
@@ -2514,6 +2518,13 @@ class Image:
 
         filename: str | bytes = ""
         open_fp = False
+        
+        # Extract feature parameters
+        dry_run = params.pop("dry_run", False)
+        backup = params.pop("backup", False)
+        backup_suffix = params.pop("backup_suffix", ".bak")
+        mark_corners = params.pop("mark_corners", False)
+        
         if is_path(fp):
             filename = os.fspath(fp)
             open_fp = True
@@ -2540,8 +2551,18 @@ class Image:
                 msg = f"unknown file extension: {ext}"
                 raise ValueError(msg) from e
 
-        # may mutate self!
-        self._ensure_mutable()
+        # Handle readonly state based on features 1 and 2
+        from . import ImageFile
+        
+        if not preserve_readonly:
+            # Feature 1: Only change readonly if saved filename matches opened filename
+            if isinstance(self, ImageFile.ImageFile) and filename == self.filename:
+                self._ensure_mutable()
+            else:
+                self.load()
+        else:
+            # Feature 2: preserve_readonly=True - only call load()
+            self.load()
 
         save_all = params.pop("save_all", None)
         self.encoderinfo = {**getattr(self, "encoderinfo", {}), **params}
@@ -2558,8 +2579,49 @@ class Image:
         else:
             save_handler = SAVE[format.upper()]
 
+        # Feature 3: Handle dry_run
+        if dry_run:
+            # For dry run, use a BytesIO object instead of actual file
+            from io import BytesIO
+            temp_fp = BytesIO()
+            try:
+                save_handler(self, temp_fp, filename)
+                # Success - the image can be saved in this format
+            finally:
+                try:
+                    del self.encoderinfo
+                except AttributeError:
+                    pass
+            return
+
+        # Feature 5: Handle corner marking
+        image_to_save = self
+        if mark_corners:
+            # Create a copy of the image for marking
+            image_to_save = self.copy()
+            
+            # Mark the corners by setting pixels to red
+            red_color = (255, 0, 0)
+            
+            # Mark top-left corner
+            image_to_save.putpixel((0, 0), red_color)
+            
+            # Mark bottom-right corner
+            image_to_save.putpixel((image_to_save.width - 1, image_to_save.height - 1), red_color)
+
         created = False
         if open_fp:
+            # Feature 4: Handle backup before opening file
+            if backup and os.path.exists(filename):
+                import shutil
+                backup_filename = filename + backup_suffix
+                try:
+                    shutil.copy2(filename, backup_filename)
+                except (shutil.SameFileError, OSError) as e:
+                    # Log warning but proceed with save
+                    import warnings
+                    warnings.warn(f"Failed to create backup: {e}")
+            
             created = not os.path.exists(filename)
             if params.get("append", False):
                 # Open also for reading ("+"), because TIFF save_all
@@ -2571,7 +2633,12 @@ class Image:
             fp = cast(IO[bytes], fp)
 
         try:
-            save_handler(self, fp, filename)
+            if image_to_save is self:
+                save_handler(self, fp, filename)
+            else:
+                # Save the watermarked image, but preserve original encoderinfo
+                image_to_save.encoderinfo = self.encoderinfo
+                save_handler(image_to_save, fp, filename)
         except Exception:
             if open_fp:
                 fp.close()
