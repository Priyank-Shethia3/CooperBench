diff --git a/llama-index-core/llama_index/core/base/llms/types.py b/llama-index-core/llama_index/core/base/llms/types.py
index 00e30cf23..9b7f26ef7 100644
--- a/llama-index-core/llama_index/core/base/llms/types.py
+++ b/llama-index-core/llama_index/core/base/llms/types.py
@@ -55,6 +55,10 @@ class ImageBlock(BaseModel):
     url: AnyUrl | str | None = None
     image_mimetype: str | None = None
     detail: str | None = None
+    skip_mimetype_guess: bool = False
+    encoding: Literal["base64", "raw"] = "base64"
+    preserve_original: bool = False
+    _original_image: bytes | None = None
 
     @field_validator("url", mode="after")
     @classmethod
@@ -74,36 +78,100 @@ class ImageBlock(BaseModel):
         """
         if not self.image:
             return self
+ 
+        if self.preserve_original:
+            self._original_image = self.image
 
-        if not self.image_mimetype:
-            guess = filetype.guess(self.image)
-            self.image_mimetype = guess.mime if guess else None
+        if not self.image_mimetype and not self.skip_mimetype_guess:
+            self.get_image_mimetype()
+ 
+        return self
+ 
+    def normalize_image_bytes(self, image_bytes: bytes) -> tuple[bytes, bytes]:
+        """Normalize image bytes for base64 encoding and MIME type guessing.
 
-        self.image = base64.b64encode(self.image)
+        Args:
+            image_bytes (bytes): The image bytes which may already be base64-encoded.
 
-        return self
+        Returns:
+            Tuple[bytes, bytes]: A tuple where the first element is the base64-encoded image bytes,
+            and the second element is the decoded bytes for MIME type guessing.
+        """
+        try:
+            # Attempt to decode assuming image_bytes is base64 encoded
+            decoded_bytes = base64.b64decode(image_bytes, validate=True)
+            # If decoding succeeds and re-encoding matches, consider it already base64
+            if base64.b64encode(decoded_bytes) == image_bytes:
+                return image_bytes, decoded_bytes
+        except (base64.binascii.Error, ValueError):
+            # Not a valid base64, treat as raw bytes
+            pass
+
+        # If not already encoded, encode it now
+        if self.encoding == "base64":
+            encoded_image = base64.b64encode(self.image)
+        else:
+            encoded_image = self.image
+        return encoded_image, image_bytes
+ 
+    def get_image_mimetype(self) -> Optional[str]:
+        """Return the image MIME type, guessing it on demand if not set.
 
-    def resolve_image(self, as_base64: bool = False) -> BytesIO:
+        Caches the guessed MIME type for future accesses.
+        """
+        if self.image_mimetype:
+            return self.image_mimetype
+
+        image_data = self.image
+        if image_data is None:
+            # Do not attempt guessing from path or URL to avoid I/O
+            return None
+
+        encoded_image, decoded_for_guessing = self.normalize_image_bytes(self.image)
+        guess = filetype.guess(image_data)
+        self.image = encoded_image
+        self.image_mimetype = guess.mime if guess else None
+        return self.image_mimetype
+
+    def resolve_image(self, as_base64: bool = False, force_mimetype: str | None = None) -> BytesIO:
         """Resolve an image such that PIL can read it.
 
         Args:
             as_base64 (bool): whether the resolved image should be returned as base64-encoded bytes
+            force_mimetype (str | None): explicitly specify or override the MIME type for the resolved image.
         """
+        mimetype = force_mimetype or self.image_mimetype
+ 
         if self.image is not None:
-            if as_base64:
+            if self.encoding == "base64":
+                if as_base64:
+                    result = self.image
+                    if mimetype:
+                        prefix = f"data:{mimetype};base64,"
+                        result = prefix.encode() + self.image if force_mimetype else result
+                    return BytesIO(result)
+                return BytesIO(base64.b64decode(self.image))
+            else:
                 return BytesIO(self.image)
-            return BytesIO(base64.b64decode(self.image))
         elif self.path is not None:
             img_bytes = self.path.read_bytes()
             if as_base64:
-                return BytesIO(base64.b64encode(img_bytes))
+                result = base64.b64encode(img_bytes)
+                if mimetype:
+                    prefix = f"data:{mimetype};base64,"
+                    result = prefix.encode() + result
+                return BytesIO(result)
             return BytesIO(img_bytes)
         elif self.url is not None:
             # load image from URL
             response = requests.get(str(self.url))
             img_bytes = response.content
             if as_base64:
-                return BytesIO(base64.b64encode(img_bytes))
+                result = base64.b64encode(img_bytes)
+                if mimetype:
+                    prefix = f"data:{mimetype};base64,"
+                    result = prefix.encode() + result
+                return BytesIO(result)
             return BytesIO(img_bytes)
         else:
             raise ValueError("No image found in the chat message!")
