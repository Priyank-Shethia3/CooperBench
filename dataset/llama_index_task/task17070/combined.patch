diff --git a/llama-index-core/llama_index/core/evaluation/retrieval/metrics.py b/llama-index-core/llama_index/core/evaluation/retrieval/metrics.py
index 612e547ce..ed31940d2 100644
--- a/llama-index-core/llama_index/core/evaluation/retrieval/metrics.py
+++ b/llama-index-core/llama_index/core/evaluation/retrieval/metrics.py
@@ -330,10 +330,12 @@ class NDCG(BaseRetrievalMetric):
     Attributes:
         metric_name (str): The name of the metric.
         mode (DiscountedGainMode): Determines the formula for each item in the summation.
+        ignore_missing_ids (bool): If True, skips None/empty entries in retrieved_ids.
     """
 
     metric_name: ClassVar[str] = "ndcg"
     mode: DiscountedGainMode = "linear"
+    ignore_missing_ids: bool = False
 
     def compute(
         self,
@@ -342,6 +344,7 @@ class NDCG(BaseRetrievalMetric):
         retrieved_ids: Optional[List[str]] = None,
         expected_texts: Optional[List[str]] = None,
         retrieved_texts: Optional[List[str]] = None,
+        relevance_scores: Optional[Dict[str, float]] = None,
         **kwargs: Any,
     ) -> RetrievalMetricResult:
         """Compute NDCG based on the provided inputs and selected method.
@@ -371,23 +374,46 @@ class NDCG(BaseRetrievalMetric):
         mode = self.mode
         expected_set = set(expected_ids)
 
-        # Calculate DCG
-        dcg = sum(
-            discounted_gain(rel=docid in expected_set, i=i, mode=mode)
-            for i, docid in enumerate(retrieved_ids, start=1)
-        )
+        if self.ignore_missing_ids:
+            retrieved_ids = [docid for docid in retrieved_ids if docid]
+ 
+        # Compute relevance values (float) for each retrieved doc
+        if relevance_scores is not None:
+            get_rel = lambda docid: relevance_scores.get(docid, 0.0)
+        else:
+            get_rel = lambda docid: 1.0 if docid in expected_set else 0.0
 
-        # Calculate IDCG using min(len(retrieved_ids), len(expected_ids))
-        # Since we can't achieve better than perfect ranking of all relevant docs
-        ideal_length = min(len(retrieved_ids), len(expected_ids))
-        idcg = sum(
-            discounted_gain(rel=True, i=i, mode=mode)
-            for i in range(1, ideal_length + 1)
-        )
+        if relevance_scores is None:
+            dcg = sum(
+                discounted_gain(rel=docid in expected_set, i=i, mode=mode)
+                for i, docid in enumerate(retrieved_ids, start=1)
+            )
+        else:
+            dcg = sum(
+             discounted_gain(rel=get_rel(docid), i=i, mode=mode)
+             for i, docid in enumerate(retrieved_ids, start=1)
+         )
+
+        if relevance_scores is not None:
+            ideal_rels = sorted(
+                [relevance_scores.get(docid, 0.0) for docid in expected_ids],
+                reverse=True,
+            )
+        else:
+            ideal_rels = [1.0] * len(expected_ids)
+
+        ideal_length = min(len(retrieved_ids), len(ideal_rels))
 
-        # Handle edge case where there are no relevant documents
-        if idcg == 0:
-            return RetrievalMetricResult(score=0.0)
+        if relevance_scores is None:
+            idcg = sum(
+                discounted_gain(rel=True, i=i, mode=mode)
+                for i in range(1, len(expected_ids) + 1)
+            )
+        else:
+            idcg = sum(
+            discounted_gain(rel=rel, i=i, mode=mode)
+            for i, rel in enumerate(ideal_rels[:ideal_length], start=1)
+         )
 
         ndcg_score = dcg / idcg
         return RetrievalMetricResult(score=ndcg_score)
