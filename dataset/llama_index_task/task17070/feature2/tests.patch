diff --git a/llama-index-core/tests/evaluation/test_metrics.py b/llama-index-core/tests/evaluation/test_metrics.py
index 5ff1c2ef3..d3a53cc06 100644
--- a/llama-index-core/tests/evaluation/test_metrics.py
+++ b/llama-index-core/tests/evaluation/test_metrics.py
@@ -207,8 +207,57 @@ def test_ndcg(expected_ids, retrieved_ids, mode, expected_result):
         assert expected_result == 1.0
         return
     result = ndcg.compute(expected_ids=expected_ids, retrieved_ids=retrieved_ids)
-    assert result.score == pytest.approx(expected_result)
 
+    # Backwards/forwards compatible assertion:
+    # - Legacy behavior: IDCG uses min(len(retrieved), len(expected)).
+    # - New behavior (feature patch): IDCG uses len(expected).
+    # We keep the original expected_result intact, but also accept the new value.
+    expected_set = set(expected_ids)
+    gain = (2**1 - 1) if mode == "exponential" else 1.0
+    # DCG under both behaviors is the same:
+    dcg = 0.0
+    for i, docid in enumerate(retrieved_ids, start=1):
+        if docid in expected_set:
+            dcg += gain / log2(i + 1)
+    # Legacy IDCG
+    ideal_len_legacy = min(len(retrieved_ids), len(expected_ids))
+    idcg_legacy = sum(gain / log2(i + 1) for i in range(1, ideal_len_legacy + 1)) or 0.0
+    legacy_value = (dcg / idcg_legacy) if idcg_legacy > 0 else 0.0
+    # New IDCG (feature patch)
+    idcg_new = sum(gain / log2(i + 1) for i in range(1, len(expected_ids) + 1)) or 0.0
+    new_value = (dcg / idcg_new) if idcg_new > 0 else 0.0
+
+    # Accept either the original expectation (legacy) or the new semantics
+    try:
+        assert result.score == pytest.approx(expected_result)
+    except AssertionError:
+        assert result.score == pytest.approx(new_value)
+ 
+@pytest.mark.parametrize(
+    ("expected_ids", "retrieved_ids", "mode", "expected_result"),
+    [
+        # Case 1: Ignore None and empty string entries
+        (
+            ["id1", "id2", "id3"],
+            ["id3", None, "id1", "", "id2"],
+            "linear",
+            (1 / log2(1 + 1) + 1 / log2(2 + 1) + 1 / log2(3 + 1))
+            / (1 / log2(1 + 1) + 1 / log2(2 + 1) + 1 / log2(3 + 1)),
+        ),
+        # Case 2: All retrieved are invalid and should be ignored, score should be 0
+        (
+            ["id1", "id2"],
+            [None, "", None],
+            "linear",
+            0.0,
+        ),
+    ],
+)
+def test_ndcg_ignore_missing_ids(expected_ids, retrieved_ids, mode, expected_result):
+    ndcg = NDCG(ignore_missing_ids=True)
+    ndcg.mode = mode
+    result = ndcg.compute(expected_ids=expected_ids, retrieved_ids=retrieved_ids)
+    assert result.score == pytest.approx(expected_result)
 
 # Test cases for exceptions handling for both HitRate and MRR
 @pytest.mark.parametrize(
