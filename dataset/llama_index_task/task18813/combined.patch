diff --git a/llama-index-core/llama_index/core/base/llms/types.py b/llama-index-core/llama_index/core/base/llms/types.py
index dedf4ad1e..059777ea4 100644
--- a/llama-index-core/llama_index/core/base/llms/types.py
+++ b/llama-index-core/llama_index/core/base/llms/types.py
@@ -110,21 +110,43 @@ class ImageBlock(BaseModel):
             guess = filetype.guess(img_data)
             self.image_mimetype = guess.mime if guess else None
 
-    def resolve_image(self, as_base64: bool = False) -> BytesIO:
+    def resolve_image(self, as_base64: bool = False, max_bytes: Optional[int] = None) -> BytesIO:
         """
         Resolve an image such that PIL can read it.
 
         Args:
             as_base64 (bool): whether the resolved image should be returned as base64-encoded bytes
+            max_bytes (Optional[int]): maximum allowed byte size of the resolved image
 
         """
-        return resolve_binary(
+        data_buffer = resolve_binary(
             raw_bytes=self.image,
             path=self.path,
             url=str(self.url) if self.url else None,
             as_base64=as_base64,
         )
 
+        # Check size by seeking to end and getting position
+        data_buffer.seek(0, 2)  # Seek to end
+        size = data_buffer.tell()
+        data_buffer.seek(0)     # Reset to beginning
+
+        if size == 0:
+            raise ValueError("resolve_image returned zero bytes")
+        elif max_bytes is not None and size > max_bytes:
+            raise ValueError(f"resolve_image exceeds maximum allowed size ({size} > {max_bytes})")
+        return data_buffer
+ 
+    def resolve_image_with_size(self, as_base64: bool = False) -> tuple[BytesIO, int]:
+        """
+        Resolve an image and return (BytesIO, size in bytes).
+        """
+        buf = self.resolve_image(as_base64=as_base64)
+        buf.seek(0, 2)
+        size = buf.tell()
+        buf.seek(0)
+        return buf, size
+
 
 class AudioBlock(BaseModel):
     block_type: Literal["audio"] = "audio"
@@ -170,20 +192,56 @@ class AudioBlock(BaseModel):
             guess = filetype.guess(audio_data)
             self.format = guess.extension if guess else None
 
-    def resolve_audio(self, as_base64: bool = False) -> BytesIO:
+    def resolve_audio(self, as_base64: bool = False, trim: bool = False, max_bytes: Optional[int] = None, on_resolve: Optional[Callable[[int], None]] = None,) -> BytesIO:
         """
         Resolve an audio such that PIL can read it.
 
         Args:
             as_base64 (bool): whether the resolved audio should be returned as base64-encoded bytes
+            trim (bool): whether the audio data needs to be trimmed or not
+            max_bytes (Optional[int]): maximum allowed byte size of the resolved audio
 
         """
-        return resolve_binary(
+        # Support mimetype/format override for empty buffer resolution.
+        if (not self.audio or len(self.audio) == 0) and self.format:
+            buf = BytesIO(b"")
+            setattr(buf, "mimetype", self.format)
+            if as_base64:
+                setattr(buf, "as_base64", True)
+            return buf
+
+        data_buffer = resolve_binary(
             raw_bytes=self.audio,
             path=self.path,
             url=str(self.url) if self.url else None,
             as_base64=as_base64,
         )
+        # Check size by seeking to end and getting position
+        data_buffer.seek(0, 2)  # Seek to end
+        size = data_buffer.tell()
+        data_buffer.seek(0)     # Reset to beginning
+        audio_bytes = data_buffer.getvalue()
+
+        if size == 0:
+            raise ValueError("resolve_image returned zero bytes")
+        elif max_bytes is not None and size > max_bytes:
+            raise ValueError(f"resolve_audio exceeds maximum allowed size ({size} > {max_bytes})")
+        elif trim or on_resolve:
+            trimmed = audio_bytes.lstrip(b'\x00').rstrip(b'\x00')
+            if on_resolve is not None:
+                on_resolve(len(trimmed))
+            return BytesIO(trimmed)
+        return data_buffer
+
+    def resolve_audio_with_size(self, as_base64: bool = False) -> tuple[BytesIO, int]:
+        """
+        Resolve audio and return (BytesIO, size in bytes).
+        """
+        buf = self.resolve_audio(as_base64=False)
+        buf.seek(0, 2)
+        size = buf.tell()
+        buf.seek(0)
+        return buf, size
 
 class DocumentBlock(BaseModel):
     block_type: Literal["document"] = "document"
@@ -211,16 +269,38 @@ class DocumentBlock(BaseModel):
 
         return self
 
-    def resolve_document(self) -> BytesIO:
+    def resolve_document(self, max_bytes: Optional[int] = None) -> BytesIO:
         """
         Resolve a document such that it is represented by a BufferIO object.
+
+        max_bytes (Optional[int]): maximum allowed byte size of the resolved document
         """
-        return resolve_binary(
+        data_buffer = resolve_binary(
             raw_bytes=self.data,
             path=self.path,
             url=str(self.url) if self.url else None,
             as_base64=False,
         )
+        # Check size by seeking to end and getting position
+        data_buffer.seek(0, 2)  # Seek to end
+        size = data_buffer.tell()
+        data_buffer.seek(0)     # Reset to beginning
+
+        if size == 0:
+            raise ValueError("resolve_image returned zero bytes")
+        elif max_bytes is not None and size > max_bytes:
+            raise ValueError(f"resolve_document exceeds maximum allowed size ({size} > {max_bytes})")
+        return data_buffer
+ 
+    def resolve_document_with_size(self) -> tuple[BytesIO, int]:
+        """
+        Resolve document and return (BytesIO, size in bytes).
+        """
+        buf = self.resolve_document()
+        buf.seek(0, 2)
+        size = buf.tell()
+        buf.seek(0)
+        return buf, size
 
     def _get_b64_string(self, data_buffer: BytesIO) -> str:
         """
