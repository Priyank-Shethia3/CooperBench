diff --git a/llama-index-core/llama_index/core/base/llms/types.py b/llama-index-core/llama_index/core/base/llms/types.py
index dedf4ad1e..5fba7dc72 100644
--- a/llama-index-core/llama_index/core/base/llms/types.py
+++ b/llama-index-core/llama_index/core/base/llms/types.py
@@ -110,21 +110,29 @@ class ImageBlock(BaseModel):
             guess = filetype.guess(img_data)
             self.image_mimetype = guess.mime if guess else None
 
-    def resolve_image(self, as_base64: bool = False) -> BytesIO:
+    def resolve_image(self, as_base64: bool = False, max_bytes: Optional[int] = None) -> BytesIO:
         """
         Resolve an image such that PIL can read it.
 
         Args:
             as_base64 (bool): whether the resolved image should be returned as base64-encoded bytes
+            max_bytes (Optional[int]): maximum allowed byte size of the resolved image
 
         """
-        return resolve_binary(
+        data_buffer = resolve_binary(
             raw_bytes=self.image,
             path=self.path,
             url=str(self.url) if self.url else None,
             as_base64=as_base64,
         )
 
+        data_buffer.seek(0, 2)
+        size = data_buffer.tell()
+        data_buffer.seek(0)
+        if max_bytes is not None and size > max_bytes:
+            raise ValueError(f"resolve_image exceeds maximum allowed size ({size} > {max_bytes})")
+        return data_buffer
+
 
 class AudioBlock(BaseModel):
     block_type: Literal["audio"] = "audio"
@@ -170,21 +178,29 @@ class AudioBlock(BaseModel):
             guess = filetype.guess(audio_data)
             self.format = guess.extension if guess else None
 
-    def resolve_audio(self, as_base64: bool = False) -> BytesIO:
+    def resolve_audio(self, as_base64: bool = False, max_bytes: Optional[int] = None) -> BytesIO:
         """
         Resolve an audio such that PIL can read it.
 
         Args:
             as_base64 (bool): whether the resolved audio should be returned as base64-encoded bytes
+            max_bytes (Optional[int]): maximum allowed byte size of the resolved audio
 
         """
-        return resolve_binary(
+        data_buffer = resolve_binary(
             raw_bytes=self.audio,
             path=self.path,
             url=str(self.url) if self.url else None,
             as_base64=as_base64,
         )
 
+        data_buffer.seek(0, 2)
+        size = data_buffer.tell()
+        data_buffer.seek(0)
+        if max_bytes is not None and size > max_bytes:
+            raise ValueError(f"resolve_audio exceeds maximum allowed size ({size} > {max_bytes})")
+        return data_buffer
+
 class DocumentBlock(BaseModel):
     block_type: Literal["document"] = "document"
     data: Optional[bytes] = None
@@ -211,17 +227,25 @@ class DocumentBlock(BaseModel):
 
         return self
 
-    def resolve_document(self) -> BytesIO:
+    def resolve_document(self, max_bytes: Optional[int] = None) -> BytesIO:
         """
         Resolve a document such that it is represented by a BufferIO object.
+        max_bytes (Optional[int]): maximum allowed byte size of the resolved document
         """
-        return resolve_binary(
+        data_buffer = resolve_binary(
             raw_bytes=self.data,
             path=self.path,
             url=str(self.url) if self.url else None,
             as_base64=False,
         )
 
+        data_buffer.seek(0, 2)
+        size = data_buffer.tell()
+        data_buffer.seek(0)
+        if max_bytes is not None and size > max_bytes:
+            raise ValueError(f"resolve_document exceeds maximum allowed size ({size} > {max_bytes})")
+        return data_buffer
+
     def _get_b64_string(self, data_buffer: BytesIO) -> str:
         """
         Get base64-encoded string from a BytesIO buffer.

