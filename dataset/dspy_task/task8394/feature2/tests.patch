diff --git a/tests/clients/test_cache_namespace.py b/tests/clients/test_cache_namespace.py
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/tests/clients/test_cache_namespace.py
@@ -0,0 +288 @@
+import pytest
+
+from dspy.clients.cache import Cache
+
+
+# Local fixtures to avoid importing from test_cache.py
+@pytest.fixture
+def cache_config(tmp_path):
+    return {
+        "enable_disk_cache": True,
+        "enable_memory_cache": True,
+        "disk_cache_dir": str(tmp_path),
+        "disk_size_limit_bytes": 1024 * 1024,
+        "memory_max_entries": 100,
+    }
+
+
+@pytest.fixture
+def cache(cache_config):
+    return Cache(**cache_config)
+
+
+# Tests for namespaced caching feature
+def test_namespace_key_isolation(cache):
+    """Test that namespace creates different cache keys for same request."""
+    request = {"prompt": "Hello", "model": "openai/gpt-4o-mini", "temperature": 0.7}
+
+    cache.set_namespace("experiment-1")
+    key_with_ns1 = cache.cache_key(request)
+
+    cache.set_namespace("experiment-2")
+    key_with_ns2 = cache.cache_key(request)
+
+    assert key_with_ns1 != key_with_ns2
+
+    cache.set_namespace(None)
+    key_no_namespace = cache.cache_key(request)
+    assert key_no_namespace != key_with_ns1
+    assert key_no_namespace != key_with_ns2
+
+
+def test_namespace_cache_isolation(cache):
+    """Test that different namespaces isolate cache entries."""
+    request = {"prompt": "Hello", "model": "openai/gpt-4o-mini", "temperature": 0.7}
+
+    cache.set_namespace("exp-1")
+    cache.put(request, "Response from exp-1")
+
+    result = cache.get(request)
+    assert result == "Response from exp-1"
+
+    cache.set_namespace("exp-2")
+
+    result = cache.get(request)
+    assert result is None
+
+    cache.put(request, "Response from exp-2")
+    result = cache.get(request)
+    assert result == "Response from exp-2"
+
+    cache.set_namespace("exp-1")
+    result = cache.get(request)
+    assert result == "Response from exp-1"
+
+    cache.set_namespace(None)
+    result = cache.get(request)
+    assert result is None
+
+    cache.put(request, "Response without namespace")
+    result = cache.get(request)
+    assert result == "Response without namespace"
+
+
+def test_request_cache_decorator_with_namespace(cache):
+    """Test the request_cache decorator with namespace parameter."""
+    from dspy.clients.cache import request_cache
+    from unittest.mock import patch
+
+    with patch("dspy.cache", cache):
+        @request_cache(namespace="test-namespace")
+        def test_function(prompt, model):
+            return f"Response for {prompt} with {model}"
+
+        result1 = test_function(prompt="Hello", model="openai/gpt-4o-mini")
+        assert result1 == "Response for Hello with openai/gpt-4o-mini"
+
+        result2 = test_function(prompt="Hello", model="openai/gpt-4o-mini")
+        assert result2 == "Response for Hello with openai/gpt-4o-mini"
+
+        @request_cache(namespace="different-namespace")
+        def test_function_different_ns(prompt, model):
+            return f"Different response for {prompt} with {model}"
+
+        result3 = test_function_different_ns(prompt="Hello", model="openai/gpt-4o-mini")
+        assert result3 == "Different response for Hello with openai/gpt-4o-mini"
+
+        @request_cache()
+        def test_function_no_ns(prompt, model):
+            return f"No namespace response for {prompt} with {model}"
+
+        result4 = test_function_no_ns(prompt="Hello", model="openai/gpt-4o-mini")
+        assert result4 == "No namespace response for Hello with openai/gpt-4o-mini"
+
+
+def test_namespace_utility_helpers(cache):
+    """Test set_namespace method and namespace context manager."""
+    request = {"prompt": "Hello", "model": "openai/gpt-4o-mini", "temperature": 0.7}
+
+    cache.set_namespace("run-42")
+    cache.put(request, "Response from run-42")
+
+    result = cache.get(request)
+    assert result == "Response from run-42"
+
+    with cache.namespace("ablation-A"):
+        result = cache.get(request)
+        assert result is None
+
+        cache.put(request, "Response from ablation-A")
+        result = cache.get(request)
+        assert result == "Response from ablation-A"
+
+    result = cache.get(request)
+    assert result == "Response from run-42"
+
+    with cache.namespace("level-1"):
+        cache.put(request, "Response from level-1")
+
+        with cache.namespace("level-2"):
+            cache.put(request, "Response from level-2")
+            result = cache.get(request)
+            assert result == "Response from level-2"
+
+        result = cache.get(request)
+        assert result == "Response from level-1"
+
+    result = cache.get(request)
+    assert result == "Response from run-42"
+
+    cache.set_namespace(None)
+    result = cache.get(request)
+    assert result is None
+
+
+def test_namespace_thread_isolation(cache):
+    """Test that namespace settings are thread-local but cache data is shared."""
+    import threading
+    import time
+    from unittest.mock import patch
+
+    request = {"prompt": "Hello", "model": "openai/gpt-4o-mini", "temperature": 0.7}
+    results = {}
+    exceptions = []
+
+    def worker_thread_a():
+        try:
+            with patch("dspy.cache", cache):
+                cache.set_namespace("namespace-A")
+                cache.put(request, "Response from namespace-A")
+                time.sleep(0.1)
+                result = cache.get(request)
+                results["thread_a_own"] = result
+                cache.set_namespace("namespace-B")
+                result_b = cache.get(request)
+                results["thread_a_other"] = result_b
+        except Exception as e:
+            exceptions.append(e)
+
+    def worker_thread_b():
+        try:
+            with patch("dspy.cache", cache):
+                cache.set_namespace("namespace-B")
+                cache.put(request, "Response from namespace-B")
+                time.sleep(0.1)
+                result = cache.get(request)
+                results["thread_b_own"] = result
+                cache.set_namespace("namespace-A")
+                result_a = cache.get(request)
+                results["thread_b_sees_a"] = result_a
+        except Exception as e:
+            exceptions.append(e)
+
+    def worker_thread_c():
+        try:
+            with patch("dspy.cache", cache):
+                cache.set_namespace("namespace-A")
+                time.sleep(0.2)
+                result = cache.get(request)
+                results["thread_c_sees_a"] = result
+        except Exception as e:
+            exceptions.append(e)
+
+    threads = [
+        threading.Thread(target=worker_thread_a),
+        threading.Thread(target=worker_thread_b),
+        threading.Thread(target=worker_thread_c),
+    ]
+
+    for thread in threads:
+        thread.start()
+
+    for thread in threads:
+        thread.join()
+
+    assert len(exceptions) == 0, f"Exceptions occurred: {exceptions}"
+    assert results["thread_a_own"] == "Response from namespace-A"
+    assert results["thread_a_other"] == "Response from namespace-B"
+    assert results["thread_b_own"] == "Response from namespace-B"
+    assert results["thread_b_sees_a"] == "Response from namespace-A"
+    assert results["thread_c_sees_a"] == "Response from namespace-A"
+
+
+def test_configure_cache_with_namespace(cache_config, tmp_path):
+    """Test that configure_cache function supports namespace parameter."""
+    from dspy.clients import configure_cache
+
+    namespace = "test-experiment"
+    configure_cache(
+        namespace=namespace,
+        enable_disk_cache=True,
+        enable_memory_cache=True,
+        disk_cache_dir=str(tmp_path),
+        disk_size_limit_bytes=1024 * 1024,
+        memory_max_entries=100,
+    )
+
+    import dspy
+
+    assert hasattr(dspy.cache, "namespace")
+    assert dspy.cache.namespace == namespace
diff --git a/tests/clients/test_cache_namespace.py b/tests/clients/test_cache_namespace.py
new file mode 100644
index 00000000..12e552e9
--- /dev/null
+++ b/tests/clients/test_cache_namespace.py
@@ -0,0 +1,305 @@
+import pytest
+
+from dspy.clients.cache import Cache
+
+
+# Local fixtures to avoid importing from test_cache.py
+@pytest.fixture
+def cache_config(tmp_path):
+    return {
+        "enable_disk_cache": True,
+        "enable_memory_cache": True,
+        "disk_cache_dir": str(tmp_path),
+        "disk_size_limit_bytes": 1024 * 1024,
+        "memory_max_entries": 100,
+    }
+
+
+@pytest.fixture
+def cache(cache_config):
+    return Cache(**cache_config)
+
+
+# Tests for namespaced caching feature
+def test_namespace_key_isolation(cache):
+    """Test that namespace creates different cache keys for same request."""
+    request = {"prompt": "Hello", "model": "openai/gpt-4o-mini", "temperature": 0.7}
+
+    # Set namespace and generate key
+    cache.set_namespace("experiment-1")
+    key_with_ns1 = cache.cache_key(request)
+
+    # Set different namespace and generate key
+    cache.set_namespace("experiment-2")
+    key_with_ns2 = cache.cache_key(request)
+
+    # Keys should be different even for same request
+    assert key_with_ns1 != key_with_ns2
+
+    # Test that key without namespace is different from both
+    cache.set_namespace(None)
+    key_no_namespace = cache.cache_key(request)
+    assert key_no_namespace != key_with_ns1
+    assert key_no_namespace != key_with_ns2
+
+
+def test_namespace_cache_isolation(cache):
+    """Test that different namespaces isolate cache entries."""
+    request = {"prompt": "Hello", "model": "openai/gpt-4o-mini", "temperature": 0.7}
+
+    # Store value in namespace "exp-1"
+    cache.set_namespace("exp-1")
+    cache.put(request, "Response from exp-1")
+
+    # Should be able to retrieve from same namespace
+    result = cache.get(request)
+    assert result == "Response from exp-1"
+
+    # Switch to namespace "exp-2"
+    cache.set_namespace("exp-2")
+
+    # Should not find the value from exp-1
+    result = cache.get(request)
+    assert result is None
+
+    # Store different value in exp-2
+    cache.put(request, "Response from exp-2")
+    result = cache.get(request)
+    assert result == "Response from exp-2"
+
+    # Switch back to exp-1, should still have original value
+    cache.set_namespace("exp-1")
+    result = cache.get(request)
+    assert result == "Response from exp-1"
+
+    # Test with None namespace (default behavior)
+    cache.set_namespace(None)
+    result = cache.get(request)
+    assert result is None  # Should not find namespaced entries
+
+    # Store value without namespace
+    cache.put(request, "Response without namespace")
+    result = cache.get(request)
+    assert result == "Response without namespace"
+
+
+def test_request_cache_decorator_with_namespace(cache):
+    """Test the request_cache decorator with namespace parameter."""
+    from dspy.clients.cache import request_cache
+    from unittest.mock import patch
+
+    # Mock the dspy.cache attribute
+    with patch("dspy.cache", cache):
+        # Test decorator with namespace parameter
+        @request_cache(namespace="test-namespace")
+        def test_function(prompt, model):
+            return f"Response for {prompt} with {model}"
+
+        # First call should compute the result
+        result1 = test_function(prompt="Hello", model="openai/gpt-4o-mini")
+        assert result1 == "Response for Hello with openai/gpt-4o-mini"
+
+        # Second call with same arguments should use cache
+        result2 = test_function(prompt="Hello", model="openai/gpt-4o-mini")
+        assert result2 == "Response for Hello with openai/gpt-4o-mini"
+
+        # Test with different namespace decorator
+        @request_cache(namespace="different-namespace")
+        def test_function_different_ns(prompt, model):
+            return f"Different response for {prompt} with {model}"
+
+        # Should compute new result even with same arguments due to different namespace
+        result3 = test_function_different_ns(prompt="Hello", model="openai/gpt-4o-mini")
+        assert result3 == "Different response for Hello with openai/gpt-4o-mini"
+
+        # Test decorator without namespace (default behavior)
+        @request_cache()
+        def test_function_no_ns(prompt, model):
+            return f"No namespace response for {prompt} with {model}"
+
+        result4 = test_function_no_ns(prompt="Hello", model="openai/gpt-4o-mini")
+        assert result4 == "No namespace response for Hello with openai/gpt-4o-mini"
+
+
+def test_namespace_utility_helpers(cache):
+    """Test set_namespace method and namespace context manager."""
+    request = {"prompt": "Hello", "model": "openai/gpt-4o-mini", "temperature": 0.7}
+
+    # Test set_namespace utility
+    cache.set_namespace("run-42")
+    cache.put(request, "Response from run-42")
+
+    result = cache.get(request)
+    assert result == "Response from run-42"
+
+    # Test namespace context manager
+    with cache.namespace("ablation-A"):
+        # Should not find value from run-42
+        result = cache.get(request)
+        assert result is None
+
+        # Store value in ablation-A namespace
+        cache.put(request, "Response from ablation-A")
+        result = cache.get(request)
+        assert result == "Response from ablation-A"
+
+    # After exiting context, should return to previous namespace (run-42)
+    result = cache.get(request)
+    assert result == "Response from run-42"
+
+    # Test nested context managers
+    with cache.namespace("level-1"):
+        cache.put(request, "Response from level-1")
+
+        with cache.namespace("level-2"):
+            cache.put(request, "Response from level-2")
+            result = cache.get(request)
+            assert result == "Response from level-2"
+
+        # Back to level-1
+        result = cache.get(request)
+        assert result == "Response from level-1"
+
+    # Back to run-42
+    result = cache.get(request)
+    assert result == "Response from run-42"
+
+    # Test setting namespace to None
+    cache.set_namespace(None)
+    result = cache.get(request)
+    assert result is None  # Should not find namespaced entries
+
+
+def test_namespace_thread_isolation(cache):
+    """Test that namespace settings are thread-local but cache data is shared."""
+    import threading
+    import time
+    from unittest.mock import patch
+
+    request = {"prompt": "Hello", "model": "openai/gpt-4o-mini", "temperature": 0.7}
+    results = {}
+    exceptions = []
+
+    def worker_thread_a():
+        """Worker that uses namespace-A."""
+        try:
+            with patch("dspy.cache", cache):
+                # Set namespace A for this thread
+                cache.set_namespace("namespace-A")
+
+                # Store a value in namespace A
+                cache.put(request, "Response from namespace-A")
+
+                # Small delay to ensure interleaving
+                time.sleep(0.1)
+
+                # Should be able to retrieve our value
+                result = cache.get(request)
+                results["thread_a_own"] = result
+
+                # Switch to namespace B - should not see namespace A's value
+                cache.set_namespace("namespace-B")
+                result_b = cache.get(request)
+                results["thread_a_other"] = result_b
+
+        except Exception as e:
+            exceptions.append(e)
+
+    def worker_thread_b():
+        """Worker that uses namespace-B."""
+        try:
+            with patch("dspy.cache", cache):
+                # Set namespace B for this thread
+                cache.set_namespace("namespace-B")
+
+                # Store a value in namespace B
+                cache.put(request, "Response from namespace-B")
+
+                # Small delay to ensure interleaving
+                time.sleep(0.1)
+
+                # Should be able to retrieve our value
+                result = cache.get(request)
+                results["thread_b_own"] = result
+
+                # Switch to namespace A - should see namespace A's value (shared cache)
+                cache.set_namespace("namespace-A")
+                result_a = cache.get(request)
+                results["thread_b_sees_a"] = result_a
+
+        except Exception as e:
+            exceptions.append(e)
+
+    def worker_thread_c():
+        """Another worker that uses namespace-A (should share with thread A)."""
+        try:
+            with patch("dspy.cache", cache):
+                # Set namespace A for this thread (same as thread A)
+                cache.set_namespace("namespace-A")
+
+                # Small delay to let thread A store its value
+                time.sleep(0.2)
+
+                # Should see thread A's value because we share the namespace
+                result = cache.get(request)
+                results["thread_c_sees_a"] = result
+
+        except Exception as e:
+            exceptions.append(e)
+
+    # Create and start threads
+    threads = [
+        threading.Thread(target=worker_thread_a),
+        threading.Thread(target=worker_thread_b),
+        threading.Thread(target=worker_thread_c),
+    ]
+
+    for thread in threads:
+        thread.start()
+
+    for thread in threads:
+        thread.join()
+
+    # Check that no exceptions occurred
+    assert len(exceptions) == 0, f"Exceptions occurred: {exceptions}"
+
+    # Thread A should see its own value in namespace A
+    assert results["thread_a_own"] == "Response from namespace-A"
+
+    # Thread A should see namespace B's value when switched to namespace B (shared cache)
+    assert results["thread_a_other"] == "Response from namespace-B"
+
+    # Thread B should see its own value in namespace B
+    assert results["thread_b_own"] == "Response from namespace-B"
+
+    # Thread B should see namespace A's value when switched to namespace A (shared cache)
+    assert results["thread_b_sees_a"] == "Response from namespace-A"
+
+    # Thread C should see thread A's value because they share namespace A
+    assert results["thread_c_sees_a"] == "Response from namespace-A"
+
+
+def test_configure_cache_with_namespace(cache_config, tmp_path):
+    """Test that configure_cache function supports namespace parameter."""
+    from dspy.clients import configure_cache
+
+    # This test verifies that the configure_cache function can accept a namespace parameter
+    # and that the created cache properly uses that namespace
+
+    # Test configure_cache with namespace
+    namespace = "test-experiment"
+    configure_cache(
+        namespace=namespace,
+        enable_disk_cache=True,
+        enable_memory_cache=True,
+        disk_cache_dir=str(tmp_path),
+        disk_size_limit_bytes=1024 * 1024,
+        memory_max_entries=100,
+    )
+
+    # Import dspy to check the configured cache
+    import dspy
+
+    # Test that the cache namespace is set
+    assert hasattr(dspy.cache, 'namespace'), "Cache should have namespace attribute"
+    assert dspy.cache.namespace == namespace, "Cache namespace should match configured value"
