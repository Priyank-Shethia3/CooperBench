diff --git a/dspy/clients/cache.py b/dspy/clients/cache.py
index bfa7dbde..666c7d10 100644
--- a/dspy/clients/cache.py
+++ b/dspy/clients/cache.py
@@ -1,7 +1,9 @@
 import copy
+import contextvars
 import inspect
 import logging
 import threading
+from contextlib import contextmanager
 from functools import wraps
 from hashlib import sha256
 from typing import Any, Dict, Optional
@@ -14,6 +16,9 @@ from diskcache import FanoutCache
 
 logger = logging.getLogger(__name__)
 
+# Context variable for cache bypass functionality
+_cache_bypass_context: contextvars.ContextVar[bool] = contextvars.ContextVar("dspy_cache_bypass", default=False)
+
 
 class Cache:
     """DSPy Cache
@@ -97,6 +102,10 @@ class Cache:
         return sha256(ujson.dumps(params, sort_keys=True).encode()).hexdigest()
 
     def get(self, request: Dict[str, Any], ignored_args_for_cache_key: Optional[list[str]] = None) -> Any:
+        # Check if cache bypass is active - if so, return None to force cache miss
+        if _cache_bypass_context.get():
+            return None
+
         try:
             key = self.cache_key(request, ignored_args_for_cache_key)
         except Exception:
@@ -168,6 +177,33 @@ class Cache:
             with open(filepath, "rb") as f:
                 self.memory_cache = cloudpickle.load(f)
 
+    @contextmanager
+    def bypass(self):
+        """
+        Context manager for bypassing cache reads while still allowing cache writes.
+ 
+        When inside this context, cache.get() will always return None (cache miss),
+        but cache.put() will still work normally to store new values.
+ 
+        This is useful for forcing fresh LM calls while still benefiting from caching
+        for subsequent calls.
+ 
+        Example:
+            with cache.bypass():
+                # This will force a fresh LM call even if cached
+                result = some_cached_function()
+ 
+            # After exiting bypass, the fresh result is available from cache
+            cached_result = some_cached_function()
+        """
+        # Set bypass flag to True
+        token = _cache_bypass_context.set(True)
+        try:
+            yield
+        finally:
+            # Reset bypass flag
+            _cache_bypass_context.reset(token)
+
 
 def request_cache(
     cache_arg_name: Optional[str] = None,
