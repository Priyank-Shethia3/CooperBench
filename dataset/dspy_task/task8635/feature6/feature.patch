diff --git a/dspy/propose/grounded_proposer.py b/dspy/propose/grounded_proposer.py
index 13722b4b..cb4a5d12 100644
--- a/dspy/propose/grounded_proposer.py
+++ b/dspy/propose/grounded_proposer.py
@@ -131,6 +131,26 @@ def generate_instruction_class(
 
     return dspy.Predict(GenerateSingleModuleInstruction)
 
+# Signature used to rephrase/shorten overly long instructions
+class ShortenInstruction(dspy.Signature):
+    (
+        """Shorten the provided instruction to be concise while preserving meaning."""
+    )
+    long_instruction = dspy.InputField(
+        format=str,
+        desc="The original, overly long instruction.",
+        prefix="INSTRUCTION:",
+    )
+    max_chars = dspy.InputField(
+        format=int,
+        desc="The maximum number of characters allowed for the shortened instruction.",
+        prefix="MAX:",
+    )
+    proposed_instruction = dspy.OutputField(
+        desc="Shortened, concise instruction.",
+        prefix="SHORTENED INSTRUCTION:",
+    )
+
 ### CLASS RESPONSIBLE FOR GENERATING A NEW INSTRUCTION, USING THE HELPER SIGNATURES ABOVE ###
 
 class GenerateModuleInstruction(dspy.Module):
@@ -266,6 +286,68 @@ class GenerateModuleInstruction(dspy.Module):
 
         return dspy.Prediction(proposed_instruction=proposed_instruction)
 
+
+def _process_instruction_length_bounds(instruction, min_chars, max_chars, rephrase_when_too_long, 
+                                     basic_instruction, prompt_model, verbose=False):
+    """
+    Process instruction to ensure it meets length bounds.
+ 
+    Args:
+        instruction: The proposed instruction to process
+        min_chars: Minimum character length required
+        max_chars: Maximum character length allowed
+        rephrase_when_too_long: Whether to rephrase long instructions
+        basic_instruction: Fallback instruction if too short
+        prompt_model: Language model for rephrasing
+        verbose: Whether to log actions
+ 
+    Returns:
+        Processed instruction that meets length bounds
+    """
+    # Handle too short instructions
+    if len(instruction) < min_chars:
+        if verbose:
+            print(f"Instruction too short ({len(instruction)} chars < {min_chars}), falling back to basic instruction")
+        return basic_instruction
+ 
+    # Handle too long instructions
+    if len(instruction) > max_chars:
+        if rephrase_when_too_long:
+            if verbose:
+                print(f"Instruction too long ({len(instruction)} chars > {max_chars}), rephrasing to be more concise")
+
+            # Make one LM call to shorten the instruction using a dedicated Signature
+            with dspy.settings.context(lm=prompt_model):
+                rephraser = dspy.Predict(ShortenInstruction)
+                shortened = rephraser(long_instruction=instruction, max_chars=max_chars).proposed_instruction
+                # Ensure the shortened instruction respects the max bound
+                if len(shortened) > max_chars:
+                    shortened = shortened[:max_chars]
+                return shortened
+        else:
+            if verbose:
+                print(f"Instruction too long ({len(instruction)} chars > {max_chars}), trimming at sentence boundary")
+ 
+            # Trim at sentence boundary and add ...
+            import re
+            # Find the last sentence boundary before max_chars
+            sentence_pattern = r'[.!?]+\s+'
+            matches = list(re.finditer(sentence_pattern, instruction))
+ 
+            if matches:
+                # Find the last sentence boundary that's within max_chars
+                for match in reversed(matches):
+                    end_pos = match.end()
+                    if end_pos <= max_chars - 1:  # Leave room for the single-character ellipsis
+                        return instruction[:end_pos].strip() + "…"
+ 
+            # If no good sentence boundary found, just truncate
+            return instruction[:max_chars-1].strip() + "…"
+ 
+    # Instruction is within bounds
+    return instruction
+
+
 ### CLASS USED TO GENERATE THE FULL SET OF INSTRUCTIONS GIVEN THE SPECIFIED CRITERIA ###
 
 class GroundedProposer(Proposer):
@@ -284,7 +366,10 @@ class GroundedProposer(Proposer):
         set_tip_randomly=True,
         set_history_randomly=True,
         verbose=False,
-        rng=None
+        rng=None,
+        min_instr_chars=30,
+        max_instr_chars=600,
+        rephrase_when_too_long=False
     ):
         super().__init__()
         self.program_aware = program_aware
@@ -297,6 +382,9 @@ class GroundedProposer(Proposer):
         self.set_history_randomly=set_history_randomly
         self.verbose = verbose
         self.rng = rng or random
+        self.min_instr_chars = min_instr_chars
+        self.max_instr_chars = max_instr_chars
+        self.rephrase_when_too_long = rephrase_when_too_long
 
         self.prompt_model = get_prompt_model(prompt_model)
 
@@ -439,4 +527,18 @@ class GroundedProposer(Proposer):
             self.prompt_model.inspect_history(n=1)
             print(f"PROPOSED INSTRUCTION: {proposed_instruction}")
 
-        return strip_prefix(proposed_instruction)
+        # Get the basic instruction for fallback if needed
+        basic_instruction = get_signature(program.predictors()[pred_i]).instructions
+ 
+        # Apply length bounds processing
+        processed_instruction = _process_instruction_length_bounds(
+            instruction=proposed_instruction,
+            min_chars=self.min_instr_chars,
+            max_chars=self.max_instr_chars,
+            rephrase_when_too_long=self.rephrase_when_too_long,
+            basic_instruction=basic_instruction,
+            prompt_model=self.prompt_model,
+            verbose=self.verbose
+        )
+
+        return strip_prefix(processed_instruction)
