diff --git a/tests/propose/test_grounded_proposer1.py b/tests/propose/test_grounded_proposer1.py
new file mode 100644
index 00000000..3a735698
--- /dev/null
+++ b/tests/propose/test_grounded_proposer1.py
@@ -0,0 +1,204 @@
+import pytest
+
+import dspy
+from dspy.predict import Predict
+from dspy.propose.grounded_proposer import GroundedProposer
+from dspy.utils.dummies import DummyLM
+import random
+from unittest.mock import Mock, patch
+
+
+
+# FEATURE SPEC TEST 1: No kwargs mutation (temperature modulation removed)
+def test_no_temperature_modification():
+    """Assert temperature is never mutated (even temporarily) during proposal."""
+
+    class RecordingDict(dict):
+        def __init__(self, *args, **kwargs):
+            super().__init__(*args, **kwargs)
+            self.set_events = []
+        def __setitem__(self, key, value):
+            self.set_events.append((key, value))
+            return super().__setitem__(key, value)
+
+    # Use a BaseLM-compatible DummyLM
+    prompt_model = DummyLM([{"proposed_instruction": "instruction"}] * 10)
+    # Provide kwargs with a recording wrapper to detect any writes
+    base_kwargs = {"temperature": 0.7, "max_tokens": 100}
+    prompt_model.kwargs = RecordingDict(base_kwargs)
+    original_kwargs_snapshot = dict(prompt_model.kwargs)
+
+    program = Predict("question -> answer")
+    proposer = GroundedProposer(
+        prompt_model=prompt_model,
+        program=program,
+        trainset=[],
+        verbose=False,
+        rng=random.Random(42),
+    )
+
+    # Run the proposal
+    _ = proposer.propose_instruction_for_predictor(
+        program=program,
+        predictor=None,
+        pred_i=0,
+        T=0.5,
+        demo_candidates=None,
+        demo_set_i=0,
+        trial_logs={},
+        tip=None,
+    )
+
+    # Assert kwargs are unchanged after
+    assert dict(prompt_model.kwargs) == original_kwargs_snapshot
+    # Critically: ensure no writes occurred at all (no temporary modulation)
+    assert not any(k == "temperature" for k, _ in prompt_model.kwargs.set_events)
+
+
+# FEATURE SPEC TEST 2: Reproducible salt
+def test_reproducible_salt():
+    """With a fixed seed, two proposers produce the same salt for the same (pred_i, demo_set_i)."""
+    seed = 42
+    program = Predict("question -> answer")
+
+    proposer1 = GroundedProposer(
+        prompt_model=DummyLM([{"proposed_instruction": "instruction"}] * 10),
+        program=program,
+        trainset=[],
+        verbose=False,
+        rng=random.Random(seed),
+    )
+
+    proposer2 = GroundedProposer(
+        prompt_model=DummyLM([{"proposed_instruction": "instruction"}] * 10),
+        program=program,
+        trainset=[],
+        verbose=False,
+        rng=random.Random(seed),
+    )
+
+    # Same seed + same indices -> same salt
+    salt1 = proposer1._cache_salt(pred_i=0, demo_set_i=0)
+    salt2 = proposer2._cache_salt(pred_i=0, demo_set_i=0)
+    assert salt1 == salt2
+
+    # Different indices -> different salts
+    salt3 = proposer1._cache_salt(pred_i=1, demo_set_i=0)
+    assert salt1 != salt3
+
+
+# FEATURE SPEC TEST 3: Backward compatibility
+@pytest.mark.parametrize("use_dataset_summary", [True, False])
+@pytest.mark.parametrize("program_aware", [True, False])
+def test_backward_compatibility(use_dataset_summary, program_aware):
+    """Test that proposal still works with different flag combinations."""
+    long_resp = "This is a sufficiently long instruction for testing purposes."
+    prompt_model = DummyLM([{"proposed_instruction": long_resp}] * 10)
+    program = Predict("question -> answer")
+
+    proposer = GroundedProposer(
+        prompt_model=prompt_model,
+        program=program,
+        trainset=[],
+        verbose=False,
+        use_dataset_summary=use_dataset_summary,
+        program_aware=program_aware,
+    )
+
+    # Should not raise exceptions
+    result = proposer.propose_instruction_for_predictor(
+        program=program,
+        predictor=None,
+        pred_i=0,
+        T=0.5,
+        demo_candidates=None,
+        demo_set_i=0,
+        trial_logs={},
+        tip=None,
+    )
+
+    # Should still return a proposed instruction
+    assert isinstance(result, str)
+    assert result == long_resp
+
+
+# Test cache salt format and properties
+def test_cache_salt_format():
+    """Test that cache salt follows the specified format (ASCII only, 13 characters)."""
+    program = Predict("question -> answer")
+
+    proposer = GroundedProposer(
+        prompt_model=DummyLM([{"proposed_instruction": "instruction"}] * 10),
+        program=program,
+        trainset=[],
+        verbose=False,
+        rng=random.Random(42),
+    )
+
+    salt = proposer._cache_salt(pred_i=0, demo_set_i=0)
+
+    # Check length
+    assert len(salt) == 13
+
+    # Check all characters are in the specified alphabet
+    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
+    assert all(c in alphabet for c in salt)
+
+    # Check no exotic characters
+    assert salt.isascii()
+
+
+# Test that different proposals get different salts
+def test_different_proposals_get_different_salts():
+    """Different (pred_i, demo_set_i) combinations yield different salts."""
+    program = Predict("question -> answer")
+
+    proposer = GroundedProposer(
+        prompt_model=DummyLM([{"proposed_instruction": "instruction"}] * 10),
+        program=program,
+        trainset=[],
+        verbose=False,
+        rng=random.Random(42),
+    )
+
+    # Different pred_i values
+    salt1 = proposer._cache_salt(pred_i=0, demo_set_i=0)
+    salt2 = proposer._cache_salt(pred_i=1, demo_set_i=0)
+    assert salt1 != salt2
+
+    # Different demo_set_i values
+    salt3 = proposer._cache_salt(pred_i=0, demo_set_i=1)
+    assert salt1 != salt3
+    assert salt2 != salt3
+
+    # Combination of both
+    salt4 = proposer._cache_salt(pred_i=1, demo_set_i=1)
+    assert salt4 not in [salt1, salt2, salt3]
+
+
+# Test that cache salt is deterministic and well-distributed
+def test_cache_salt_distribution():
+    """Cache salts are deterministic and show good uniqueness across combinations."""
+    program = Predict("question -> answer")
+
+    proposer = GroundedProposer(
+        prompt_model=DummyLM([{"proposed_instruction": "instruction"}] * 200),
+        program=program,
+        trainset=[],
+        verbose=False,
+        rng=random.Random(42),
+    )
+
+    salts = set()
+    for pred_i in range(5):
+        for demo_set_i in range(5):
+            salts.add(proposer._cache_salt(pred_i=pred_i, demo_set_i=demo_set_i))
+
+    # Should have many unique salts (at least 20 out of 25 possible)
+    assert len(salts) >= 20
+
+    # All salts should follow the same format
+    for s in salts:
+        assert len(s) == 13
+        alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
+        assert all(c in alphabet for c in s)
