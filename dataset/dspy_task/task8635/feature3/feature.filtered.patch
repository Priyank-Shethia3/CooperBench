diff --git a/dspy/propose/grounded_proposer.py b/dspy/propose/grounded_proposer.py
index 13722b4b..1682fad7 100644
--- a/dspy/propose/grounded_proposer.py
+++ b/dspy/propose/grounded_proposer.py
@@ -284,7 +284,8 @@ class GroundedProposer(Proposer):
         set_tip_randomly=True,
         set_history_randomly=True,
         verbose=False,
-        rng=None
+        rng=None,
+        tip_weights=None
     ):
         super().__init__()
         self.program_aware = program_aware
@@ -297,6 +298,7 @@ class GroundedProposer(Proposer):
         self.set_history_randomly=set_history_randomly
         self.verbose = verbose
         self.rng = rng or random
+        self.tip_weights = tip_weights
 
         self.prompt_model = get_prompt_model(prompt_model)
 
@@ -323,6 +325,43 @@ class GroundedProposer(Proposer):
                 self.use_dataset_summary = False
                 print("")
 
+    def _select_tip_with_weights(self):
+        """Select a tip using weighted random selection or uniform selection if no weights provided"""
+        if self.tip_weights is None:
+            # Preserve uniform draw using rng.choice
+            selected_tip_key = self.rng.choice(list(TIPS.keys()))
+        else:
+            # Normalize weights and use cumulative distribution
+            available_tips = list(TIPS.keys())
+ 
+            # Create normalized weights with fallback to 1.0 for missing keys
+            normalized_weights = []
+            for tip in available_tips:
+                weight = self.tip_weights.get(tip, 1.0)  # Fallback: if weight key missing, default to 1.0
+                normalized_weights.append(weight)
+ 
+            # Normalize to probabilities
+            total_weight = sum(normalized_weights)
+            if total_weight > 0:
+                probabilities = [w / total_weight for w in normalized_weights]
+ 
+                # Use cumulative distribution for selection
+                rand_val = self.rng.random()
+                cumulative_prob = 0
+                for i, prob in enumerate(probabilities):
+                    cumulative_prob += prob
+                    if rand_val <= cumulative_prob:
+                        selected_tip_key = available_tips[i]
+                        break
+                else:
+                    # Fallback to last tip if rounding errors occur
+                    selected_tip_key = available_tips[-1]
+            else:
+                # Fallback to uniform selection if all weights are 0
+                selected_tip_key = self.rng.choice(available_tips)
+ 
+        return selected_tip_key
+
     def propose_instructions_for_program(
         self,
         trainset,
@@ -362,7 +401,7 @@ class GroundedProposer(Proposer):
                     if self.verbose:
                         print("Using a randomly generated configuration for our grounded proposer.")
                     # Randomly select the tip
-                    selected_tip_key = self.rng.choice(list(TIPS.keys()))
+                    selected_tip_key = self._select_tip_with_weights()
                     selected_tip = TIPS[selected_tip_key]
                     self.use_tip = bool(
                         selected_tip,

