diff --git a/dspy/adapters/types/tool.py b/dspy/adapters/types/tool.py
index 843eceed..7ca42b1d 100644
--- a/dspy/adapters/types/tool.py
+++ b/dspy/adapters/types/tool.py
@@ -1,5 +1,6 @@
 import asyncio
 import inspect
+import re
 from typing import TYPE_CHECKING, Any, Callable, Type, get_origin, get_type_hints
 
 from jsonschema import ValidationError, validate
@@ -16,6 +17,92 @@ if TYPE_CHECKING:
 _TYPE_MAPPING = {"string": str, "integer": int, "number": float, "boolean": bool, "array": list, "object": dict}
 
 
+def _coerce_args(kwargs: dict[str, Any], schema: dict[str, Any]) -> dict[str, Any]:
+    """Apply minimal type coercion to tool arguments before validation.
+ 
+    This function converts common LM-emitted string values into proper Python types
+    and normalized units so that existing schema validation succeeds more often.
+ 
+    Args:
+        kwargs: The arguments to coerce
+        schema: The JSON schema for the tool arguments
+ 
+    Returns:
+        A shallow copy of kwargs with coerced values
+    """
+ 
+    coerced_kwargs = kwargs.copy()
+ 
+    for key, value in kwargs.items():
+        if key not in schema or not isinstance(value, str):
+            continue
+ 
+        field_schema = schema[key]
+        field_type = field_schema.get("type")
+        field_format = field_schema.get("format")
+ 
+        # Strip whitespace
+        value = value.strip()
+ 
+        # Boolean coercion: "true"/"false" → True/False (case-insensitive)
+        if field_type == "boolean":
+            if value.lower() == "true":
+                coerced_kwargs[key] = True
+            elif value.lower() == "false":
+                coerced_kwargs[key] = False
+            continue
+ 
+        # Numeric coercion: "42"→42, "3.14"→3.14
+        if field_type in ("integer", "number"):
+            try:
+                # Try to convert to float first
+                float_val = float(value)
+                # If it's an integer field and the value is a whole number, convert to int
+                if field_type == "integer" and float_val.is_integer():
+                    coerced_kwargs[key] = int(float_val)
+                else:
+                    coerced_kwargs[key] = float_val
+                continue
+            except (ValueError, TypeError):
+                pass
+ 
+        # Duration coercion: (\d+)(ms|s|m|h) → seconds as float
+        if field_type == "number" or (field_format == "duration"):
+            duration_match = re.match(r'^(\d+(?:\.\d+)?)\s*(ms|s|m|h)$', value)
+            if duration_match:
+                number, unit = duration_match.groups()
+                number = float(number)
+                if unit == "ms":
+                    coerced_kwargs[key] = number / 1000
+                elif unit == "s":
+                    coerced_kwargs[key] = number
+                elif unit == "m":
+                    coerced_kwargs[key] = number * 60
+                elif unit == "h":
+                    coerced_kwargs[key] = number * 3600
+                continue
+ 
+        # Size coercion: (\d+(?:\.\d+)?)(KB|MB|GB) → bytes as int
+        if field_type in ("integer", "number") or (field_format == "bytes"):
+            size_match = re.match(r'^(\d+(?:\.\d+)?)\s*(KB|MB|GB)$', value)
+            if size_match:
+                number, unit = size_match.groups()
+                number = float(number)
+ 
+                # Use decimal (1000) base as specified in the spec
+                base = 1000
+ 
+                if unit == "KB":
+                    coerced_kwargs[key] = int(number * base)
+                elif unit == "MB":
+                    coerced_kwargs[key] = int(number * base ** 2)
+                elif unit == "GB":
+                    coerced_kwargs[key] = int(number * base ** 3)
+                continue
+ 
+    return coerced_kwargs
+
+
 class Tool(Type):
     """Tool class.
 
@@ -116,6 +203,9 @@ class Tool(Type):
         self.has_kwargs = any(param.kind == param.VAR_KEYWORD for param in sig.parameters.values())
 
     def _validate_and_parse_args(self, **kwargs):
+        # Coerce the arguments to the correct type.
+        kwargs = _coerce_args(kwargs, self.args)
+
         # Validate the args value comply to the json schema.
         for k, v in kwargs.items():
             if k not in self.args:

