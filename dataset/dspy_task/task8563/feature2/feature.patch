diff --git a/dspy/adapters/types/tool.py b/dspy/adapters/types/tool.py
index 843eceed..88189eb3 100644
--- a/dspy/adapters/types/tool.py
+++ b/dspy/adapters/types/tool.py
@@ -1,9 +1,10 @@
 import asyncio
+import ast
 import inspect
 from typing import TYPE_CHECKING, Any, Callable, Type, get_origin, get_type_hints
 
 from jsonschema import ValidationError, validate
-from pydantic import BaseModel, TypeAdapter, create_model
+from pydantic import BaseModel, TypeAdapter, create_model, model_validator
 
 from dspy.adapters.types.base_type import Type
 from dspy.dsp.utils.settings import settings
@@ -284,6 +285,30 @@ class ToolCalls(Type):
         tool_calls = [cls.ToolCall(**item) for item in tool_calls_dicts]
         return cls(tool_calls=tool_calls)
 
+    @classmethod
+    def validate_input(cls, data: Any) -> Any:
+        """Validate and normalize input data for ToolCalls.
+ 
+        If the input is a string, it will be parsed as Python function calls.
+        Otherwise, the data is returned as-is for normal Pydantic validation.
+ 
+        Args:
+            data: Input data (string, dict, list, or ToolCalls instance)
+ 
+        Returns:
+            Normalized data ready for Pydantic validation
+        """
+        if isinstance(data, str):
+            # Parse Python function call syntax
+            return parse_python_calls(data)
+        return data
+
+    @model_validator(mode="before")
+    @classmethod
+    def validate_input_before(cls, data: Any) -> Any:
+        """Validate and normalize input data before Pydantic processing."""
+        return cls.validate_input(data)
+
     @classmethod
     def description(cls) -> str:
         return (
@@ -336,6 +361,113 @@ def _resolve_json_schema_reference(schema: dict) -> dict:
     return resolved_schema
 
 
+def parse_python_calls(text: str) -> dict[str, Any]:
+    """Parse Python function call syntax into ToolCalls format.
+ 
+    This function safely parses Python-style function calls from a string and converts
+    them into the standard ToolCalls format. It only accepts literal values and
+    keyword arguments for security.
+ 
+    Args:
+        text: String containing Python function calls
+ 
+    Returns:
+        Dict in the format {"tool_calls": [{"name": ..., "args": {...}}, ...]}
+ 
+    Raises:
+        ValueError: If the input contains unsupported syntax (positional args, variables, etc.)
+    """
+    if not text or not text.strip():
+        raise ValueError("No function calls found")
+ 
+    try:
+        tree = ast.parse(text, mode="exec")
+    except SyntaxError as e:
+        raise ValueError(f"Invalid Python syntax: {e}")
+ 
+    tool_calls = []
+ 
+    for node in tree.body:
+        if isinstance(node, ast.Expr) and isinstance(node.value, ast.Call):
+            # This is a function call
+            call = node.value
+ 
+            # Extract function name (handle dotted names)
+            if isinstance(call.func, ast.Name):
+                func_name = call.func.id
+            elif isinstance(call.func, ast.Attribute):
+                # For dotted names like 'utils.search', extract just 'search'
+                func_name = call.func.attr
+            else:
+                raise ValueError("Only simple function names are allowed")
+ 
+            # Check for positional arguments
+            if call.args:
+                raise ValueError("Only keyword arguments supported; found positional")
+ 
+            # Parse keyword arguments
+            args = {}
+            for kw in call.keywords:
+                if kw.arg is None:  # **kwargs not allowed
+                    raise ValueError("**kwargs not supported")
+ 
+                # Parse the value
+                try:
+                    parsed_value = _parse_literal_value(kw.value)
+                    args[kw.arg] = parsed_value
+                except ValueError as e:
+                    raise ValueError(f"Invalid value for argument '{kw.arg}': {e}")
+ 
+            tool_calls.append({"name": func_name, "args": args})
+ 
+        elif isinstance(node, ast.Expr):
+            # Other expressions are not allowed
+            raise ValueError("Only top-level function calls are allowed")
+        else:
+            # Other statements are not allowed
+            raise ValueError("Only top-level function calls are allowed")
+ 
+    if not tool_calls:
+        raise ValueError("No function calls found")
+ 
+    return {"tool_calls": tool_calls}
+
+
+def _parse_literal_value(node: ast.AST) -> Any:
+    """Parse an AST node into a literal value.
+ 
+    Only allows safe literal values: strings, numbers, booleans, None,
+    and basic data structures containing these.
+    """
+    if isinstance(node, ast.Constant):
+        return node.value
+ 
+    elif isinstance(node, ast.UnaryOp):
+        if isinstance(node.op, (ast.UAdd, ast.USub)) and isinstance(node.operand, ast.Constant):
+            if isinstance(node.operand.value, (int, float)):
+                if isinstance(node.op, ast.UAdd):
+                    return node.operand.value
+                else:  # USub
+                    return -node.operand.value
+        raise ValueError("Only unary +/- on numeric constants are allowed")
+ 
+    elif isinstance(node, ast.List):
+        return [_parse_literal_value(item) for item in node.elts]
+ 
+    elif isinstance(node, ast.Tuple):
+        # Convert tuples to lists for JSON compatibility
+        return [_parse_literal_value(item) for item in node.elts]
+ 
+    elif isinstance(node, ast.Dict):
+        if not all(isinstance(k, ast.Constant) and isinstance(k.value, str) for k in node.keys):
+            raise ValueError("Only string keys are allowed in dictionaries")
+ 
+        return {k.value: _parse_literal_value(v) for k, v in zip(node.keys, node.values)}
+ 
+    else:
+        raise ValueError("Only literal values are allowed")
+
+
 def convert_input_schema_to_tool_args(
     schema: dict[str, Any],
 ) -> tuple[dict[str, Any], dict[str, Type], dict[str, str]]:
