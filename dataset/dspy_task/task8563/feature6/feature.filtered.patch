diff --git a/dspy/adapters/types/tool.py b/dspy/adapters/types/tool.py
index 843eceed..4921cb24 100644
--- a/dspy/adapters/types/tool.py
+++ b/dspy/adapters/types/tool.py
@@ -1,5 +1,7 @@
 import asyncio
 import inspect
+import json
+import re
 from typing import TYPE_CHECKING, Any, Callable, Type, get_origin, get_type_hints
 
 from jsonschema import ValidationError, validate
@@ -261,6 +263,62 @@ class ToolCalls(Type):
 
     tool_calls: list[ToolCall]
 
+    @classmethod
+    def validate_input(cls, data: Any) -> Any:
+        """Validate and preprocess input data for ToolCalls.
+ 
+        This method implements a pre-processing step that detects when a string input 
+        contains a code-fenced block (e.g., ```json ... ```), extracts the inner content, 
+        and attempts to parse it as JSON before normal validation.
+ 
+        Args:
+            data: Input data that can be a dict, list, or string
+ 
+        Returns:
+            Parsed data (dict/list if JSON parsing succeeds, original string if it fails)
+        """
+        # If data is not a string, return as-is
+        if not isinstance(data, str):
+            return data
+ 
+        # Check if the string contains code fences
+        if '```' not in data:
+            # No code fences, try to parse as regular JSON
+            try:
+                return json.loads(data)
+            except json.JSONDecodeError:
+                return data
+ 
+        # Extract content from the first code-fenced block
+        # Use string operations instead of regex for more reliable extraction
+        if '```' in data:
+            # Find the first opening fence
+            start_idx = data.find('```')
+            if start_idx != -1:
+                # Find the end of the language tag (if any) and the newline
+                after_fence = data[start_idx + 3:]
+                # Skip over language tag and newline
+                newline_idx = after_fence.find('\n')
+                if newline_idx != -1:
+                    content_start = start_idx + 3 + newline_idx + 1
+                    # Find the closing fence
+                    closing_fence = data.find('```', content_start)
+                    if closing_fence != -1:
+                        # Extract content between fences and trim whitespace
+                        extracted_content = data[content_start:closing_fence].strip()
+                        # Try to parse as JSON
+                        try:
+                            return json.loads(extracted_content)
+                        except json.JSONDecodeError:
+                            # JSON parsing failed, fall back to original string
+                            pass
+ 
+        # No code fences found or extraction failed, try to parse as regular JSON
+        try:
+            return json.loads(data)
+        except json.JSONDecodeError:
+            return data
+
     @classmethod
     def from_dict_list(cls, tool_calls_dicts: list[dict[str, Any]]) -> "ToolCalls":
         """Convert a list of dictionaries to a ToolCalls instance.

