diff --git a/dspy/adapters/types/tool.py b/dspy/adapters/types/tool.py
index 843eceed1..470c0f302 100644
--- a/dspy/adapters/types/tool.py
+++ b/dspy/adapters/types/tool.py
@@ -258,15 +258,25 @@ class ToolCalls(Type):
     class ToolCall(BaseModel):
         name: str
         args: dict[str, Any]
+        # Metadata fields (optional, non-execution)
+        note: str | None = None
+        comment: str | None = None
+        annotation: str | None = None
+        tags: list[str] | None = None
+        priority: str | int | None = None
+        meta: dict[str, Any] | None = None
 
     tool_calls: list[ToolCall]
 
     @classmethod
-    def from_dict_list(cls, tool_calls_dicts: list[dict[str, Any]]) -> "ToolCalls":
+    def from_dict_list(cls, tool_calls_dicts: list[dict[str, Any]], comments: list[str] | None = None) -> "ToolCalls":
         """Convert a list of dictionaries to a ToolCalls instance.
 
         Args:
-            dict_list: A list of dictionaries, where each dictionary should have 'name' and 'args' keys.
+            tool_calls_dicts: A list of dictionaries, where each dictionary should have 'name' and 'args' keys.
+                Additional metadata fields (note, comment, annotation, tags, priority, meta) are supported.
+            comments: Optional list of Python comment strings to be parsed into note metadata.
+                If provided, these comments will override any explicit note fields.
 
         Returns:
             A ToolCalls instance.
@@ -275,15 +285,109 @@ class ToolCalls(Type):
 
             ```python
             tool_calls_dict = [
-                {"name": "search", "args": {"query": "hello"}},
-                {"name": "translate", "args": {"text": "world"}}
+                {"name": "search", "args": {"query": "hello"}, "note": "Search for user query"},
+                {"name": "translate", "args": {"text": "world"}, "priority": "high"}
             ]
-            tool_calls = ToolCalls.from_dict_list(tool_calls_dict)
+            comments = ["This search may take time", "User requested this"]
+            tool_calls = ToolCalls.from_dict_list(tool_calls_dict, comments=comments)
             ```
         """
-        tool_calls = [cls.ToolCall(**item) for item in tool_calls_dicts]
+        tool_calls = []
+ 
+        # Process comments if provided
+        combined_comment = None
+        if comments:
+            # Strip whitespace and combine multiple comments with newlines
+            stripped_comments = [comment.strip() for comment in comments if comment.strip()]
+            if stripped_comments:
+                combined_comment = "\n".join(stripped_comments)
+ 
+        for item in tool_calls_dicts:
+            # Separate execution fields from metadata fields
+            execution_fields = {"name": item["name"], "args": item["args"]}
+ 
+            # Extract metadata fields if present
+            metadata_fields = {}
+            metadata_keys = ["note", "comment", "annotation", "tags", "priority", "meta"]
+            for key in metadata_keys:
+                if key in item:
+                    metadata_fields[key] = item[key]
+ 
+            # Python comments take precedence over explicit comment fields
+            if combined_comment is not None:
+                metadata_fields["comment"] = combined_comment
+ 
+            # Create ToolCall with both execution and metadata fields
+            tool_call_data = {**execution_fields, **metadata_fields}
+            tool_calls.append(cls.ToolCall(**tool_call_data))
+ 
         return cls(tool_calls=tool_calls)
 
+    @classmethod
+    def from_string(cls, input_string: str) -> "ToolCalls":
+        """Parse a string containing tool calls and Python comments into a ToolCalls instance.
+
+        Args:
+            input_string: A string containing JSON tool calls and optional Python comments.
+                Comments can appear on separate lines or after JSON objects.
+
+        Returns:
+            A ToolCalls instance.
+
+        Example:
+
+            ```python
+            input_string = '''# This search may take time
+            {
+                "name": "search",
+                "args": {"query": "hello"}
+            }  # User requested this'''
+ 
+            tool_calls = ToolCalls.from_string(input_string)
+            ```
+        """
+        import json
+        import re
+ 
+        # Extract all Python comments (lines starting with #)
+        comment_pattern = r'^\s*#\s*(.+)$'
+        comments = []
+        for line in input_string.split('\n'):
+            # Check for line comments (lines starting with #)
+            match = re.match(comment_pattern, line)
+            if match:
+                comments.append(match.group(1).strip())
+            else:
+                # Check for inline comments (everything after # on the same line)
+                inline_match = re.search(r'#\s*(.+)$', line)
+                if inline_match:
+                    comments.append(inline_match.group(1).strip())
+ 
+        # Remove comment lines and inline comments to get clean JSON
+        clean_lines = []
+        for line in input_string.split('\n'):
+            # Skip lines that are just comments
+            if re.match(comment_pattern, line):
+                continue
+            # Remove inline comments (everything after #)
+            clean_line = re.sub(r'\s*#.*$', '', line)
+            if clean_line.strip():  # Only add non-empty lines
+                clean_lines.append(clean_line)
+ 
+        clean_string = '\n'.join(clean_lines)
+ 
+        # Parse the clean JSON and use existing from_dict_list method
+        try:
+            tool_calls_data = json.loads(clean_string)
+            if isinstance(tool_calls_data, dict):
+                tool_calls_data = [tool_calls_data]
+            elif not isinstance(tool_calls_data, list):
+                raise ValueError("Input must be a single tool call or list of tool calls")
+        except json.JSONDecodeError as e:
+            raise ValueError(f"Invalid JSON format: {e}")
+ 
+        return cls.from_dict_list(tool_calls_data, comments=comments)
+
     @classmethod
     def description(cls) -> str:
         return (
@@ -309,6 +413,39 @@ class ToolCalls(Type):
             }
         ]
 
+    def format_with_metadata(self) -> list[dict[str, Any]]:
+        """Format tool calls including metadata fields for debugging purposes.
+ 
+        This method includes all metadata fields in addition to the execution fields,
+        making it useful for logging, debugging, and UI display.
+ 
+        Returns:
+            A list containing tool calls with metadata fields included.
+        """
+        return [
+            {
+                "type": "tool_calls",
+                "tool_calls": [
+                    {
+                        "type": "function",
+                        "function": {
+                            "name": tool_call.name,
+                            "arguments": tool_call.args,
+                        },
+                        **{k: v for k, v in {
+                            "note": tool_call.note,
+                            "comment": tool_call.comment,
+                            "annotation": tool_call.annotation,
+                            "tags": tool_call.tags,
+                            "priority": tool_call.priority,
+                            "meta": tool_call.meta,
+                        }.items() if v is not None}
+                    }
+                    for tool_call in self.tool_calls
+                ],
+            }
+        ]
+
 
 def _resolve_json_schema_reference(schema: dict) -> dict:
     """Recursively resolve json model schema, expanding all references."""
