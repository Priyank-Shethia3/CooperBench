diff --git a/tests/streaming/test_streaming.py b/tests/streaming/test_streaming.py
index fe67bd6d..23517262 100644
--- a/tests/streaming/test_streaming.py
+++ b/tests/streaming/test_streaming.py
@@ -91,6 +91,203 @@ async def test_default_status_streaming():
     assert status_messages[0].message == "Calling tool generate_question..."
     assert status_messages[1].message == "Tool calling finished! Querying the LLM with tool calling results..."
 
+@pytest.mark.anyio
+async def test_stream_listener_on_chunk_callback_basic():
+    """Test that StreamListener properly calls on_chunk callback when provided."""
+    callback_calls = []
+ 
+    def on_chunk_callback(response):
+        callback_calls.append(response)
+ 
+    listener = dspy.streaming.StreamListener(
+        signature_field_name="answer",
+        on_chunk=on_chunk_callback
+    )
+    listener.predict_name = "test_predict"
+ 
+    # Simulate a StreamResponse being created
+    response = dspy.streaming.StreamResponse("test_predict", "answer", "test chunk")
+ 
+    # Manually trigger the callback to test it works
+    if listener.on_chunk:
+        listener.on_chunk(response)
+ 
+    assert len(callback_calls) == 1
+    assert callback_calls[0] == response
+    assert callback_calls[0].predict_name == "test_predict"
+    assert callback_calls[0].signature_field_name == "answer"
+    assert callback_calls[0].chunk == "test chunk"
+
+
+@pytest.mark.anyio
+async def test_stream_listener_on_chunk_callback_none():
+    """Test that StreamListener works normally when on_chunk is None (default behavior)."""
+    listener = dspy.streaming.StreamListener(signature_field_name="answer")
+ 
+    # Verify on_chunk is None by default
+    assert listener.on_chunk is None
+ 
+    # Verify the listener can still be used normally
+    assert listener.signature_field_name == "answer"
+    assert listener.predict_name is None
+
+
+@pytest.mark.anyio
+async def test_stream_listener_on_chunk_callback_integration():
+    """Test that on_chunk callback is properly integrated with streaming functionality."""
+    callback_calls = []
+ 
+    def on_chunk_callback(response):
+        callback_calls.append(response)
+ 
+    class MyProgram(dspy.Module):
+        def __init__(self):
+            super().__init__()
+            self.predict = dspy.Predict("question->answer")
+
+        def forward(self, question, **kwargs):
+            return self.predict(question=question, **kwargs)
+
+    async def simple_stream(*args, **kwargs):
+        yield ModelResponseStream(model="test", choices=[StreamingChoices(delta=Delta(content="[[ ## answer ## ]]\n"))])
+        yield ModelResponseStream(model="test", choices=[StreamingChoices(delta=Delta(content="Hello"))])
+        yield ModelResponseStream(model="test", choices=[StreamingChoices(delta=Delta(content=" world"))])
+        yield ModelResponseStream(model="test", choices=[StreamingChoices(delta=Delta(content="!"))])
+        yield ModelResponseStream(model="test", choices=[StreamingChoices(delta=Delta(content="\n\n[[ ## completed ## ]]"))])
+
+    with mock.patch("litellm.acompletion", side_effect=simple_stream):
+        program = dspy.streamify(
+            MyProgram(),
+            stream_listeners=[
+                dspy.streaming.StreamListener(
+                    signature_field_name="answer",
+                    on_chunk=on_chunk_callback
+                ),
+            ],
+        )
+ 
+        with dspy.context(lm=dspy.LM("test", cache=False), adapter=dspy.ChatAdapter()):
+            output = program(question="What is the answer?")
+ 
+            # Collect all chunks
+            chunks = []
+            async for value in output:
+                if isinstance(value, dspy.streaming.StreamResponse):
+                    chunks.append(value)
+ 
+            # Verify we got chunks
+            assert len(chunks) > 0
+ 
+            # Verify callback was called for each chunk
+            assert len(callback_calls) == len(chunks)
+ 
+            # Verify callback received the correct data
+            for i, chunk in enumerate(chunks):
+                assert callback_calls[i] == chunk
+                assert callback_calls[i].predict_name == chunk.predict_name
+                assert callback_calls[i].signature_field_name == chunk.signature_field_name
+                assert callback_calls[i].chunk == chunk.chunk
+
+
+@pytest.mark.anyio
+async def test_stream_listener_on_chunk_callback_timing():
+    """Test that on_chunk callback is called at the right time with the right data."""
+    callback_data = []
+ 
+    def on_chunk_callback(response):
+        # Capture the exact response object and its attributes
+        callback_data.append({
+            'predict_name': response.predict_name,
+            'signature_field_name': response.signature_field_name,
+            'chunk': response.chunk,
+            'response_object': response
+        })
+ 
+    listener = dspy.streaming.StreamListener(
+        signature_field_name="answer",
+        on_chunk=on_chunk_callback
+    )
+    listener.predict_name = "test_predict"
+ 
+    # Test that callback is called when StreamResponse is created
+    response = dspy.streaming.StreamResponse("test_predict", "answer", "test chunk")
+ 
+    # Manually call the callback to simulate what happens in receive()
+    if listener.on_chunk:
+        listener.on_chunk(response)
+ 
+    # Verify callback was called with correct data
+    assert len(callback_data) == 1
+    assert callback_data[0]['predict_name'] == "test_predict"
+    assert callback_data[0]['signature_field_name'] == "answer"
+    assert callback_data[0]['chunk'] == "test chunk"
+    assert callback_data[0]['response_object'] is response  # Same object reference
+
+
+@pytest.mark.anyio
+async def test_stream_listener_on_chunk_callback_multiple_listeners():
+    """Test that multiple StreamListeners with different on_chunk callbacks work correctly."""
+    callback1_calls = []
+    callback2_calls = []
+ 
+    def on_chunk_callback1(response):
+        callback1_calls.append(response)
+ 
+    def on_chunk_callback2(response):
+        callback2_calls.append(response)
+ 
+    class MyProgram(dspy.Module):
+        def __init__(self):
+            super().__init__()
+            self.predict = dspy.Predict("question->answer")
+
+        def forward(self, question, **kwargs):
+            return self.predict(question=question, **kwargs)
+
+    async def simple_stream(*args, **kwargs):
+        yield ModelResponseStream(model="test", choices=[StreamingChoices(delta=Delta(content="[[ ## answer ## ]]\n"))])
+        yield ModelResponseStream(model="test", choices=[StreamingChoices(delta=Delta(content="Hello"))])
+        yield ModelResponseStream(model="test", choices=[StreamingChoices(delta=Delta(content=" world"))])
+        yield ModelResponseStream(model="test", choices=[StreamingChoices(delta=Delta(content="!"))])
+        yield ModelResponseStream(model="test", choices=[StreamingChoices(delta=Delta(content="\n\n[[ ## completed ## ]]"))])
+
+    with mock.patch("litellm.acompletion", side_effect=simple_stream):
+        program = dspy.streamify(
+            MyProgram(),
+            stream_listeners=[
+                dspy.streaming.StreamListener(
+                    signature_field_name="answer",
+                    on_chunk=on_chunk_callback1
+                ),
+                dspy.streaming.StreamListener(
+                    signature_field_name="answer",  # Same field, different callback
+                    on_chunk=on_chunk_callback2
+                ),
+            ],
+        )
+ 
+        with dspy.context(lm=dspy.LM("test", cache=False), adapter=dspy.ChatAdapter()):
+            output = program(question="What is the answer?")
+ 
+            # Collect all chunks
+            chunks = []
+            async for value in output:
+                if isinstance(value, dspy.streaming.StreamResponse):
+                    chunks.append(value)
+ 
+            # Verify we got chunks
+            assert len(chunks) > 0
+ 
+            # Verify each callback was called appropriately
+            # Both callbacks should be called for the same field
+            assert len(callback1_calls) == len(chunks)
+            assert len(callback2_calls) == len(chunks)
+ 
+            # Verify callbacks received the correct data
+            for i, chunk in enumerate(chunks):
+                assert callback1_calls[i] == chunk
+                assert callback2_calls[i] == chunk
+
 
 @pytest.mark.anyio
 async def test_custom_status_streaming():
