diff --git a/dspy/streaming/streaming_listener.py b/dspy/streaming/streaming_listener.py
index 98fd4aca..80a1a93d 100644
--- a/dspy/streaming/streaming_listener.py
+++ b/dspy/streaming/streaming_listener.py
@@ -1,4 +1,5 @@
 import re
+import logging
 from collections import defaultdict
 from queue import Queue
 from typing import TYPE_CHECKING, Any
@@ -26,6 +27,8 @@ class StreamListener:
         predict: Any = None,
         predict_name: str | None = None,
         allow_reuse: bool = False,
+        debug: bool = False,
+        debug_logger: logging.Logger | None = None,
     ):
         """
         Args:
@@ -36,6 +39,8 @@ class StreamListener:
                 automatically look for the predictor that has the `signature_field_name` in its signature.
             allow_reuse: If True, the stream listener can be reused for multiple streams. Please note that this could
                 hurt the performance because the same stream chunk is sent to multiple listeners.
+            debug: If True, enables debug logging for key state transitions.
+            debug_logger: Optional custom logger for debug messages. If None, uses default logger.
         """
         self.signature_field_name = signature_field_name
         self.predict = predict
@@ -47,6 +52,10 @@ class StreamListener:
         self.stream_end = False
         self.cache_hit = False
         self.allow_reuse = allow_reuse
+ 
+        # Debug mode setup
+        self.debug = debug
+        self._logger = debug_logger or logging.getLogger("dspy.streaming.listener")
 
         self.adapter_identifiers = {
             "ChatAdapter": {
@@ -66,6 +75,19 @@ class StreamListener:
             },
         }
 
+    def _safe_truncate(self, text: str, max_length: int = 80) -> str:
+        """Safely truncate text to avoid large string formatting in logs."""
+        if len(text) <= max_length:
+            return text
+ 
+        half_length = max_length // 2
+        return f"{text[:half_length]}...{text[-half_length:]}"
+
+    def _log_debug(self, message: str):
+        """Log debug message only when debug mode is enabled and logger is enabled for DEBUG level."""
+        if self.debug and self._logger.isEnabledFor(logging.DEBUG):
+            self._logger.debug(message)
+
     def _buffered_message_end_with_start_identifier(self, concat_message: str, start_identifier: str) -> str:
         for i in range(len(concat_message)):
             if start_identifier.startswith(concat_message[len(concat_message) - i - 1 :]):
@@ -91,6 +113,8 @@ class StreamListener:
                 self.field_start_queue = []
                 self.field_end_queue = Queue()
                 self.stream_start = False
+                # Log state reset when allow_reuse=True
+                self._log_debug(f"State reset for field '{self.signature_field_name}' (allow_reuse=True)")
             else:
                 return
 
@@ -112,6 +136,11 @@ class StreamListener:
                 self.cache_hit = True
                 self.stream_start = True
                 self.stream_end = True
+                # Log start detection for cache hit case
+                self._log_debug(
+                    f"Start detection: adapter={adapter_name}, field='{self.signature_field_name}', "
+                    f"stream_start=True, buffer_preview='{self._safe_truncate(message_after_start_identifier)}'"
+                )
                 return
 
         if len(self.field_start_queue) == 0 and not self.stream_start and start_indicator in chunk_message:
@@ -138,6 +167,12 @@ class StreamListener:
                     # For JSONAdapter, we need to remove the leading ". We cannot do this with the start_identifier
                     # because there could be a few splitters between ':' and '"', e.g., '"name": "value"'.
                     chunk_message = chunk_message[1:]
+ 
+                # Log start detection
+                self._log_debug(
+                    f"Start detection: adapter={adapter_name}, field='{self.signature_field_name}', "
+                    f"stream_start=True, buffer_preview='{self._safe_truncate(chunk_message)}'"
+                )
 
             elif self._buffered_message_end_with_start_identifier(concat_message.strip(), start_identifier):
                 # If the buffered message ends with part of the start_identifier, we keep looking for the
@@ -164,8 +199,19 @@ class StreamListener:
                 last_token = self.flush()
                 token = token + last_token if token else last_token
                 token = token.rstrip()  # Remove the trailing \n\n
+ 
+                # Log rolling end check
+                self._log_debug(
+                    f"Rolling end check: adapter={adapter_name}, field='{self.signature_field_name}', "
+                    f"reason='regex_match', buffered_size={len(concat_message)}"
+                )
 
             if token:
+                # Log emit chunk
+                self._log_debug(
+                    f"Emit chunk: len(token)={len(token)}, queue_size={self.field_end_queue.qsize()}, "
+                    f"is_last_chunk={self.stream_end}"
+                )
                 return StreamResponse(self.predict_name, self.signature_field_name, token)
 
     def flush(self) -> str:
@@ -177,6 +223,14 @@ class StreamListener:
         """
         last_tokens = "".join(self.field_end_queue.queue)
         self.field_end_queue = Queue()
+ 
+        # Log flush
+        adapter_name = settings.adapter.__class__.__name__ if settings.adapter else "ChatAdapter"
+        self._log_debug(
+            f"Flush: adapter={adapter_name}, field='{self.signature_field_name}', "
+            f"truncated_buffer_length={len(last_tokens)}"
+        )
+ 
         if isinstance(settings.adapter, JSONAdapter):
             match = re.search(r'",|"\s*}', last_tokens)
             if match:

