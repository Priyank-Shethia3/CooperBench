diff --git a/dspy/streaming/streaming_listener.py b/dspy/streaming/streaming_listener.py
index 98fd4aca..2417b862 100644
--- a/dspy/streaming/streaming_listener.py
+++ b/dspy/streaming/streaming_listener.py
@@ -43,11 +43,17 @@ class StreamListener:
 
         self.field_start_queue = []
         self.field_end_queue = Queue()
-        self.stream_start = False
-        self.stream_end = False
+        self._stream_start = False
+        self._stream_end = False
         self.cache_hit = False
         self.allow_reuse = allow_reuse
 
+        # Stats tracking attributes
+        self._chunk_count = 0
+        self._char_count = 0
+        self._t0 = None  # First chunk timestamp
+        self._t_last = None  # Last chunk timestamp
+
         self.adapter_identifiers = {
             "ChatAdapter": {
                 "start_identifier": f"[[ ## {self.signature_field_name} ## ]]",
@@ -66,6 +72,96 @@ class StreamListener:
             },
         }
 
+    @property
+    def stream_start(self):
+        return self._stream_start
+
+    @stream_start.setter
+    def stream_start(self, value):
+        self._stream_start = value
+        if value:  # When stream starts, reset stats
+            self._reset_stats()
+
+    @property
+    def stream_end(self):
+        return self._stream_end
+
+    @stream_end.setter
+    def stream_end(self, value):
+        self._stream_end = value
+        if value:  # When stream ends, reset stats
+            self._reset_stats()
+
+    def _reset_stats(self):
+        """Reset all stats counters and timestamps."""
+        self._chunk_count = 0
+        self._char_count = 0
+        self._t0 = None
+        self._t_last = None
+
+    def _handle_stream_end(self):
+        """Handle stream end - stats are now automatically reset by the property setter."""
+        pass  # No longer needed since property setter handles reset
+
+    def _update_stats(self, chunk: str):
+        """Update stats when a chunk is emitted."""
+        import time
+ 
+        current_time = time.time()
+        self._chunk_count += 1
+        self._char_count += len(chunk)
+ 
+        # Set first timestamp on first chunk
+        if self._t0 is None:
+            self._t0 = current_time
+ 
+        # Update last timestamp on every chunk
+        self._t_last = current_time
+
+    def stats(self) -> dict:
+        """Return streaming statistics as a stable, serialization-friendly dict.
+ 
+        Returns:
+            Dict with keys: predict_name, field, chunk_count, char_count, 
+            first_ts, last_ts, duration_s, avg_chunk_chars
+        """
+        duration_s = None
+        if self._t0 is not None and self._t_last is not None:
+            duration_s = self._t_last - self._t0
+ 
+        avg_chunk_chars = 0
+        if self._chunk_count > 0:
+            avg_chunk_chars = self._char_count / self._chunk_count
+ 
+        return {
+            "predict_name": self.predict_name,
+            "field": self.signature_field_name,
+            "chunk_count": self._chunk_count,
+            "char_count": self._char_count,
+            "first_ts": self._t0,
+            "last_ts": self._t_last,
+            "duration_s": duration_s,
+            "avg_chunk_chars": avg_chunk_chars,
+        }
+
+    def push_stats_to_usage_tracker(self) -> bool:
+        """Push current stats to the usage tracker if it exists.
+ 
+        Returns:
+            True if stats were pushed successfully, False otherwise.
+        """
+        try:
+            if hasattr(settings, 'usage_tracker') and settings.usage_tracker is not None:
+                stats = self.stats()
+                # Add a "streaming" key to identify this as streaming stats
+                streaming_stats = {"streaming": stats}
+                settings.usage_tracker.push(streaming_stats)
+                return True
+        except Exception:
+            # Silently fail to avoid breaking streaming functionality
+            pass
+        return False
+
     def _buffered_message_end_with_start_identifier(self, concat_message: str, start_identifier: str) -> str:
         for i in range(len(concat_message)):
             if start_identifier.startswith(concat_message[len(concat_message) - i - 1 :]):
@@ -83,14 +179,15 @@ class StreamListener:
         end_identifier = self.adapter_identifiers[adapter_name]["end_identifier"]
         start_indicator = self.adapter_identifiers[adapter_name]["start_indicator"]
 
-        if self.stream_end:
+        if self._stream_end:
             if self.allow_reuse:
                 # Clear up the state for the next stream.
-                self.stream_end = False
+                self._stream_end = False
                 self.cache_hit = False
                 self.field_start_queue = []
                 self.field_end_queue = Queue()
-                self.stream_start = False
+                self._stream_start = False
+                # Stats are already reset by the property setter when stream_end was set to True
             else:
                 return
 
@@ -112,6 +209,13 @@ class StreamListener:
                 self.cache_hit = True
                 self.stream_start = True
                 self.stream_end = True
+ 
+                # Handle stats for cache hit case - there might be content to emit
+                content_after_start = message_after_start_identifier[:message_after_start_identifier.find("[[")]
+                if content_after_start.strip():
+                    # Update stats for the content we're about to emit
+                    self._update_stats(content_after_start.strip())
+                    return StreamResponse(self.predict_name, self.signature_field_name, content_after_start.strip())
                 return
 
         if len(self.field_start_queue) == 0 and not self.stream_start and start_indicator in chunk_message:
@@ -166,6 +270,8 @@ class StreamListener:
                 token = token.rstrip()  # Remove the trailing \n\n
 
             if token:
+                # Update stats before emitting the chunk
+                self._update_stats(token)
                 return StreamResponse(self.predict_name, self.signature_field_name, token)
 
     def flush(self) -> str:

