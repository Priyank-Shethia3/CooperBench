diff --git a/tests/streaming/test_streaming.py b/tests/streaming/test_streaming.py
index fe67bd6d..536107bf 100644
--- a/tests/streaming/test_streaming.py
+++ b/tests/streaming/test_streaming.py
@@ -763,6 +763,215 @@ async def test_stream_listener_allow_reuse():
     # The listener functions twice.
     assert concat_message == "To get to the other side!To get to the other side!"
 
+
+@pytest.mark.anyio
+async def test_stream_listener_stats_initialization():
+    """Test that StreamListener properly initializes stats counters and timestamps."""
+    listener = dspy.streaming.StreamListener(signature_field_name="answer")
+ 
+    # Test initial state
+    stats = listener.stats()
+    assert stats["predict_name"] is None
+    assert stats["field"] == "answer"
+    assert stats["chunk_count"] == 0
+    assert stats["char_count"] == 0
+    assert stats["first_ts"] is None
+    assert stats["last_ts"] is None
+    assert stats["duration_s"] is None
+    assert stats["avg_chunk_chars"] == 0
+
+
+@pytest.mark.anyio
+async def test_stream_listener_stats_update_on_emission():
+    """Test that stats are updated when StreamResponse objects are emitted."""
+    listener = dspy.streaming.StreamListener(signature_field_name="answer")
+    listener.predict_name = "test_predict"
+ 
+    # Simulate receiving chunks that would emit StreamResponse
+    # First chunk - should set first timestamp
+    listener._chunk_count = 1
+    listener._char_count = 5
+    listener._t0 = 100.0
+    listener._t_last = 100.0
+ 
+    stats = listener.stats()
+    assert stats["chunk_count"] == 1
+    assert stats["char_count"] == 5
+    assert stats["first_ts"] == 100.0
+    assert stats["last_ts"] == 100.0
+    assert stats["duration_s"] == 0.0
+    assert stats["avg_chunk_chars"] == 5.0
+ 
+    # Second chunk - should update last timestamp and counts
+    listener._chunk_count = 2
+    listener._char_count = 12
+    listener._t_last = 105.0
+ 
+    stats = listener.stats()
+    assert stats["chunk_count"] == 2
+    assert stats["char_count"] == 12
+    assert stats["first_ts"] == 100.0
+    assert stats["last_ts"] == 105.0
+    assert stats["duration_s"] == 5.0
+    assert stats["avg_chunk_chars"] == 6.0
+
+
+@pytest.mark.anyio
+async def test_stream_listener_stats_reset_on_stream_end():
+    """Test that stats are reset when a stream ends."""
+    listener = dspy.streaming.StreamListener(signature_field_name="answer")
+    listener.predict_name = "test_predict"
+ 
+    # Set some stats
+    listener._chunk_count = 3
+    listener._char_count = 15
+    listener._t0 = 100.0
+    listener._t_last = 110.0
+ 
+    # Verify stats are set
+    stats = listener.stats()
+    assert stats["chunk_count"] == 3
+    assert stats["char_count"] == 15
+ 
+    # Simulate stream end (this should trigger reset)
+    listener.stream_end = True
+    # The reset logic should be called when stream_end becomes True
+ 
+    # Verify stats are reset
+    stats = listener.stats()
+    assert stats["chunk_count"] == 0
+    assert stats["char_count"] == 0
+    assert stats["first_ts"] is None
+    assert stats["last_ts"] is None
+    assert stats["duration_s"] is None
+    assert stats["avg_chunk_chars"] == 0
+
+
+@pytest.mark.anyio
+async def test_stream_listener_stats_reset_on_allow_reuse():
+    """Test that stats are reset when allow_reuse=True and stream is reused."""
+    listener = dspy.streaming.StreamListener(signature_field_name="answer", allow_reuse=True)
+    listener.predict_name = "test_predict"
+ 
+    # Set some stats
+    listener._chunk_count = 2
+    listener._char_count = 10
+    listener._t0 = 100.0
+    listener._t_last = 105.0
+ 
+    # Verify stats are set
+    stats = listener.stats()
+    assert stats["chunk_count"] == 2
+    assert stats["char_count"] == 10
+ 
+    # Simulate stream end and reuse (this should trigger reset)
+    listener.stream_end = True
+    # The allow_reuse logic should reset stats when stream_end becomes True
+ 
+    # Verify stats are reset
+    stats = listener.stats()
+    assert stats["chunk_count"] == 0
+    assert stats["char_count"] == 0
+    assert stats["first_ts"] is None
+    assert stats["last_ts"] is None
+    assert stats["duration_s"] is None
+    assert stats["avg_chunk_chars"] == 0
+
+
+@pytest.mark.anyio
+async def test_stream_listener_stats_structure():
+    """Test that stats() returns the exact structure specified in the feature spec."""
+    listener = dspy.streaming.StreamListener(signature_field_name="test_field")
+    listener.predict_name = "test_predict"
+ 
+    stats = listener.stats()
+ 
+    # Verify all required keys exist
+    required_keys = {
+        "predict_name", "field", "chunk_count", "char_count", 
+        "first_ts", "last_ts", "duration_s", "avg_chunk_chars"
+    }
+    assert set(stats.keys()) == required_keys
+ 
+    # Verify data types and values
+    assert stats["predict_name"] == "test_predict"
+    assert stats["field"] == "test_field"
+    assert isinstance(stats["chunk_count"], int)
+    assert isinstance(stats["char_count"], int)
+    assert stats["first_ts"] is None or isinstance(stats["first_ts"], (int, float))
+    assert stats["last_ts"] is None or isinstance(stats["last_ts"], (int, float))
+    assert stats["duration_s"] is None or isinstance(stats["duration_s"], (int, float))
+    assert isinstance(stats["avg_chunk_chars"], (int, float))
+
+
+@pytest.mark.anyio
+async def test_stream_listener_stats_edge_cases():
+    """Test edge cases for stats calculation."""
+    listener = dspy.streaming.StreamListener(signature_field_name="answer")
+    listener.predict_name = "test_predict"
+ 
+    # Test with no chunks
+    stats = listener.stats()
+    assert stats["avg_chunk_chars"] == 0
+ 
+    # Test with single chunk
+    listener._chunk_count = 1
+    listener._char_count = 0
+    stats = listener.stats()
+    assert stats["avg_chunk_chars"] == 0
+ 
+    # Test with multiple chunks, some empty
+    listener._chunk_count = 3
+    listener._char_count = 5
+    stats = listener.stats()
+    assert stats["avg_chunk_chars"] == 5/3  # Should handle division correctly
+
+
+@pytest.mark.anyio
+async def test_stream_listener_stats_integration_with_streaming():
+    """Test that stats are properly updated during actual streaming."""
+    class MyProgram(dspy.Module):
+        def __init__(self):
+            super().__init__()
+            self.predict = dspy.Predict("question->answer")
+
+        def forward(self, question, **kwargs):
+            return self.predict(question=question, **kwargs)
+
+    async def simple_stream(*args, **kwargs):
+        yield ModelResponseStream(model="test", choices=[StreamingChoices(delta=Delta(content="[[ ## answer ## ]]\n"))])
+        yield ModelResponseStream(model="test", choices=[StreamingChoices(delta=Delta(content="Hello"))])
+        yield ModelResponseStream(model="test", choices=[StreamingChoices(delta=Delta(content=" world"))])
+        yield ModelResponseStream(model="test", choices=[StreamingChoices(delta=Delta(content="!"))])
+        yield ModelResponseStream(model="test", choices=[StreamingChoices(delta=Delta(content="\n\n[[ ## completed ## ]]"))])
+
+    with mock.patch("litellm.acompletion", side_effect=simple_stream):
+        program = dspy.streamify(
+            MyProgram(),
+            stream_listeners=[
+                dspy.streaming.StreamListener(signature_field_name="answer"),
+            ],
+        )
+ 
+        with dspy.context(lm=dspy.LM("test", cache=False), adapter=dspy.ChatAdapter()):
+            output = program(question="What is the answer?")
+ 
+            # Collect all chunks
+            chunks = []
+            async for value in output:
+                if isinstance(value, dspy.streaming.StreamResponse):
+                    chunks.append(value)
+ 
+            # Verify we got chunks
+            assert len(chunks) > 0
+ 
+            # Get the listener from the program to check its stats
+            # Note: In a real implementation, we'd need access to the listener instance
+            # For now, we'll test that the streaming works and produces chunks
+            assert all(isinstance(chunk, dspy.streaming.StreamResponse) for chunk in chunks)
+            assert all(chunk.signature_field_name == "answer" for chunk in chunks)
+
+
 @pytest.mark.anyio
 async def test_stream_listener_returns_correct_chunk_xml_adapter():
     class MyProgram(dspy.Module):
