diff --git a/src/jinja2/loaders.py b/src/jinja2/loaders.py
index d7d9bd04..ff0b4e83 100644
--- a/src/jinja2/loaders.py
+++ b/src/jinja2/loaders.py
@@ -71,6 +71,32 @@ class BaseLoader:
     #: .. versionadded:: 2.4
     has_source_access = True
 
+    def __init__(self) -> None:
+        self.aliases: t.Dict[str, str] = {}
+
+    def add_alias(self, alias: str, target: str) -> None:
+        """Add a template path alias.
+ 
+        :param alias: The alias name for the template
+        :param target: The actual template path
+        """
+        self.aliases[alias] = target
+
+    def remove_alias(self, alias: str) -> None:
+        """Remove a template path alias.
+ 
+        :param alias: The alias name to remove
+        """
+        self.aliases.pop(alias, None)
+
+    def resolve_template_name(self, template: str) -> str:
+        """Resolve template name through aliases.
+ 
+        :param template: The template name (possibly an alias)
+        :return: The actual template path
+        """
+        return self.aliases.get(template, template)
+
     def get_source(
         self, environment: "Environment", template: str
     ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:
@@ -181,6 +207,7 @@ class FileSystemLoader(BaseLoader):
         encoding: str = "utf-8",
         followlinks: bool = False,
     ) -> None:
+        super().__init__()
         if not isinstance(searchpath, abc.Iterable) or isinstance(searchpath, str):
             searchpath = [searchpath]
 
@@ -191,6 +218,7 @@ class FileSystemLoader(BaseLoader):
     def get_source(
         self, environment: "Environment", template: str
     ) -> t.Tuple[str, str, t.Callable[[], bool]]:
+        template = self.resolve_template_name(template)
         pieces = split_template_path(template)
         for searchpath in self.searchpath:
             filename = os.path.join(searchpath, *pieces)
@@ -270,6 +298,7 @@ class PackageLoader(BaseLoader):
         package_path: "str" = "templates",
         encoding: str = "utf-8",
     ) -> None:
+        super().__init__()
         package_path = os.path.normpath(package_path).rstrip(os.path.sep)
 
         # normpath preserves ".", which isn't valid in zip paths.
@@ -326,6 +355,7 @@ class PackageLoader(BaseLoader):
     def get_source(
         self, environment: "Environment", template: str
     ) -> t.Tuple[str, str, t.Optional[t.Callable[[], bool]]]:
+        template = self.resolve_template_name(template)
         p = os.path.join(self._template_root, *split_template_path(template))
         up_to_date: t.Optional[t.Callable[[], bool]]
 
@@ -402,11 +432,13 @@ class DictLoader(BaseLoader):
     """
 
     def __init__(self, mapping: t.Mapping[str, str]) -> None:
+        super().__init__()
         self.mapping = mapping
 
     def get_source(
         self, environment: "Environment", template: str
     ) -> t.Tuple[str, None, t.Callable[[], bool]]:
+        template = self.resolve_template_name(template)
         if template in self.mapping:
             source = self.mapping[template]
             return source, None, lambda: source == self.mapping.get(template)
@@ -445,11 +477,13 @@ class FunctionLoader(BaseLoader):
             ],
         ],
     ) -> None:
+        super().__init__()
         self.load_func = load_func
 
     def get_source(
         self, environment: "Environment", template: str
     ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:
+        template = self.resolve_template_name(template)
         rv = self.load_func(template)
 
         if rv is None:
@@ -479,6 +513,7 @@ class PrefixLoader(BaseLoader):
     def __init__(
         self, mapping: t.Mapping[str, BaseLoader], delimiter: str = "/"
     ) -> None:
+        super().__init__()
         self.mapping = mapping
         self.delimiter = delimiter
 
@@ -539,6 +574,7 @@ class ChoiceLoader(BaseLoader):
     """
 
     def __init__(self, loaders: t.Sequence[BaseLoader]) -> None:
+        super().__init__()
         self.loaders = loaders
 
     def get_source(
@@ -594,6 +630,7 @@ class ModuleLoader(BaseLoader):
     def __init__(
         self, path: t.Union[str, os.PathLike, t.Sequence[t.Union[str, os.PathLike]]]
     ) -> None:
+        super().__init__()
         package_name = f"_jinja2_module_templates_{id(self):x}"
 
         # create a fake module that looks for the templates in the

