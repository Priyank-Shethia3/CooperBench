diff --git a/src/jinja2/loaders.py b/src/jinja2/loaders.py
index d7d9bd04..fb38d480 100644
--- a/src/jinja2/loaders.py
+++ b/src/jinja2/loaders.py
@@ -165,26 +165,70 @@ class FileSystemLoader(BaseLoader):
 
         loader = FileSystemLoader(["/override/templates", "/default/templates"])
 
+    Paths can be assigned priorities to control search order:
+
+    .. code-block:: python
+
+        loader = FileSystemLoader([
+            ("/high/priority", 100),
+            ("/low/priority", 10),
+            "/default/templates"  # priority 0 by default
+        ])
+
     :param searchpath: A path, or list of paths, to the directory that
-        contains the templates.
+        contains the templates. Each path can be a string/PathLike or a
+        tuple of (path, priority) where priority is a numeric value.
+        Higher priority paths are searched first.
     :param encoding: Use this encoding to read the text from template
         files.
     :param followlinks: Follow symbolic links in the path.
 
     .. versionchanged:: 2.8
         Added the ``followlinks`` parameter.
+    .. versionchanged:: 3.1
+        Added support for path priorities.
     """
 
     def __init__(
         self,
-        searchpath: t.Union[str, os.PathLike, t.Sequence[t.Union[str, os.PathLike]]],
+        searchpath: t.Union[
+            str, 
+            os.PathLike, 
+            t.Sequence[t.Union[str, os.PathLike, t.Tuple[t.Union[str, os.PathLike], int]]]
+        ],
         encoding: str = "utf-8",
         followlinks: bool = False,
     ) -> None:
         if not isinstance(searchpath, abc.Iterable) or isinstance(searchpath, str):
             searchpath = [searchpath]
 
-        self.searchpath = [os.fspath(p) for p in searchpath]
+        # Process paths and priorities
+        path_priority_pairs = []
+        for i, item in enumerate(searchpath):
+            if isinstance(item, tuple) and len(item) == 2:
+                path, priority = item
+                path_priority_pairs.append((os.fspath(path), priority, i))
+            else:
+                # Handle invalid tuples by treating them as regular paths
+                if isinstance(item, tuple):
+                    # For invalid tuples, try to use the first element as the path
+                    if len(item) > 0:
+                        try:
+                            path_priority_pairs.append((os.fspath(item[0]), 0, i))
+                        except (TypeError, IndexError):
+                            # Skip invalid items that can't be converted to paths
+                            continue
+                    else:
+                        # Skip empty tuples
+                        continue
+                else:
+                    path_priority_pairs.append((os.fspath(item), 0, i))
+ 
+        # Sort by priority (highest first), then by original order for same priority
+        path_priority_pairs.sort(key=lambda x: (-x[1], x[2]))
+ 
+        self.searchpath = [path for path, _, _ in path_priority_pairs]
+        self._path_priorities = {path: priority for path, priority, _ in path_priority_pairs}
         self.encoding = encoding
         self.followlinks = followlinks
 
