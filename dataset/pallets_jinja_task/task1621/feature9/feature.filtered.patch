diff --git a/src/jinja2/loaders.py b/src/jinja2/loaders.py
index d7d9bd04..d0b39567 100644
--- a/src/jinja2/loaders.py
+++ b/src/jinja2/loaders.py
@@ -11,6 +11,7 @@ from collections import abc
 from hashlib import sha1
 from importlib import import_module
 from types import ModuleType
+import threading
 
 from .exceptions import TemplateNotFound
 from .utils import internalcode
@@ -180,6 +181,7 @@ class FileSystemLoader(BaseLoader):
         searchpath: t.Union[str, os.PathLike, t.Sequence[t.Union[str, os.PathLike]]],
         encoding: str = "utf-8",
         followlinks: bool = False,
+        auto_reload: bool = True,
     ) -> None:
         if not isinstance(searchpath, abc.Iterable) or isinstance(searchpath, str):
             searchpath = [searchpath]
@@ -187,10 +189,159 @@ class FileSystemLoader(BaseLoader):
         self.searchpath = [os.fspath(p) for p in searchpath]
         self.encoding = encoding
         self.followlinks = followlinks
+        # Whether to run the background watcher for automatic cache invalidation
+        self.auto_reload = auto_reload
+
+        # Monitoring state
+        self._environments: "weakref.WeakSet" = weakref.WeakSet() if auto_reload else weakref.WeakSet()
+        self._searchpath_abs = [os.path.abspath(p) for p in self.searchpath]
+        self._snapshot: t.Dict[str, float] = {}
+        self._lock = threading.Lock()
+        self._stop_event = threading.Event()
+        self._poll_interval = 1.0  # seconds
+        self._watcher_thread: t.Optional[threading.Thread] = None
+
+        # Build initial snapshot safely
+        try:
+            self._snapshot = self._build_snapshot()
+        except Exception:
+            self._snapshot = {}
+
+        # Start watcher thread if enabled
+        if self.auto_reload:
+            self._watcher_thread = threading.Thread(
+                target=self._watch_paths,
+                name=f"jinja2.FileSystemLoader.watch.{id(self):x}",
+                daemon=True,
+            )
+            self._watcher_thread.start()
+
+
+    def _register_environment(self, environment: "Environment") -> None:
+        """Track environments that use this loader via weak references."""
+        if self.auto_reload:
+            try:
+                self._environments.add(environment)
+            except Exception:
+                pass
+
+    def _build_snapshot(self) -> t.Dict[str, float]:
+        """Walk all search paths and return a mapping of absolute file path to mtime."""
+        snapshot: t.Dict[str, float] = {}
+        for root in self._searchpath_abs:
+            if not os.path.isdir(root):
+                continue
+            for dirpath, _, filenames in os.walk(root, followlinks=self.followlinks):
+                for fname in filenames:
+                    fpath = os.path.join(dirpath, fname)
+                    try:
+                        snapshot[fpath] = os.path.getmtime(fpath)
+                    except OSError:
+                        # File might have been removed between list and stat
+                        continue
+        return snapshot
+
+    def _path_to_template_name(self, abs_path: str) -> t.Optional[str]:
+        for root in self._searchpath_abs:
+            # Ensure root ends with a path separator when comparing prefixes
+            root_prefix = root.rstrip(os.path.sep) + os.path.sep
+            if abs_path.startswith(root_prefix) or abs_path == root:
+                rel = os.path.relpath(abs_path, root)
+                template = rel.replace(os.path.sep, "/").lstrip("./")
+                return template
+        return None
+
+    def _invalidate_names(self, names: t.Set[str]) -> None:
+        if not names:
+            return
+        # Iterate over a list copy to avoid issues if the WeakSet changes
+        for env in list(self._environments):
+            if env is None:
+                continue
+            cache = getattr(env, "cache", None)
+            if not cache:
+                continue
+            to_delete: t.List[t.Tuple[weakref.ref, str]] = []
+            for key in list(cache.keys()):
+                try:
+                    loader_ref, name = key
+                except Exception:
+                    continue
+                if name in names:
+                    obj = loader_ref()
+                    if obj is self:
+                        to_delete.append(key)
+            for key in to_delete:
+                try:
+                    del cache[key]
+                except Exception:
+                    pass
+
+    def _on_template_changed(self, file_paths: t.List[str]) -> None:
+        """Manual cache invalidation method for testing purposes.
+
+        Takes a list of absolute file paths that have changed and
+        invalidates corresponding template cache entries.
+        """
+        changed_names: t.Set[str] = set()
+        for file_path in file_paths:
+            name = self._path_to_template_name(file_path)
+            if name:
+                changed_names.add(name)
+        if changed_names:
+            self._invalidate_names(changed_names)
+
+    def scan_once(self) -> t.Set[str]:
+        """Run a single scan for changed files and invalidate caches.
+
+        Returns the set of template names that were invalidated. Can be
+        used in tests regardless of auto_reload setting.
+        """
+        with self._lock:
+            new_snapshot = self._build_snapshot()
+            old_snapshot = self._snapshot
+            added_paths = set(new_snapshot) - set(old_snapshot)
+            removed_paths = set(old_snapshot) - set(new_snapshot)
+            modified_paths = {
+                p for p, m in new_snapshot.items() if old_snapshot.get(p) != m
+            }
+            self._snapshot = new_snapshot
+
+        changed_paths = added_paths | removed_paths | modified_paths
+        changed_names: t.Set[str] = set()
+        for p in changed_paths:
+            name = self._path_to_template_name(p)
+            if name:
+                changed_names.add(name)
+        if changed_names:
+            self._invalidate_names(changed_names)
+        return changed_names
+
+    def _watch_paths(self) -> None:
+        while not self._stop_event.is_set():
+            try:
+                self.scan_once()
+            except Exception:
+                # Ignore errors to keep the watcher alive
+                pass
+            # Use the event to sleep so that close() can wake this up
+            self._stop_event.wait(self._poll_interval)
+
+    def close(self) -> None:
+        """Stop the background watcher thread if it's running."""
+        self._stop_event.set()
+        t = self._watcher_thread
+        if t is not None and t.is_alive():
+            try:
+                t.join(timeout=0.5)
+            except Exception:
+                pass
 
     def get_source(
         self, environment: "Environment", template: str
     ) -> t.Tuple[str, str, t.Callable[[], bool]]:
+        # Register this environment to enable cache invalidation across instances
+        self._register_environment(environment)
         pieces = split_template_path(template)
         for searchpath in self.searchpath:
             filename = os.path.join(searchpath, *pieces)

