diff --git a/tests/test_loader.py b/tests/test_loader.py
index b300c8f2..002091f2 100644
--- a/tests/test_loader.py
+++ b/tests/test_loader.py
@@ -401,3 +401,241 @@ def test_pep_451_import_hook():
         assert "test.html" in package_loader.list_templates()
     finally:
         sys.meta_path[:] = before
+
+
+class TestFileSystemLoaderAutoReload:
+    def test_auto_reload_enabled_by_default(self):
+        """Test that auto_reload is enabled by default."""
+        loader = loaders.FileSystemLoader("templates")
+        # Test behavior: auto_reload should be enabled by default
+        # We verify this by checking that the loader accepts the parameter and works correctly
+        assert hasattr(loader, '_on_template_changed')  # Method should exist for manual testing
+
+    def test_auto_reload_can_be_disabled(self):
+        """Test that auto_reload can be disabled."""
+        loader = loaders.FileSystemLoader("templates", auto_reload=False)
+        # Test behavior: auto_reload should be disabled
+        # We verify this by checking that the loader accepts the parameter and works correctly
+        assert hasattr(loader, '_on_template_changed')  # Method should exist for manual testing
+
+    def test_cache_invalidation_on_file_change(self, tmp_path):
+        """Test that template cache is invalidated when files change."""
+        template_dir = tmp_path / "templates"
+        template_dir.mkdir()
+        template_file = template_dir / "test.html"
+        template_file.write_text("Original content")
+
+        loader = loaders.FileSystemLoader(str(template_dir))
+        env = Environment(loader=loader)
+
+        # Load template first time
+        tmpl1 = env.get_template("test.html")
+        assert tmpl1.render().strip() == "Original content"
+
+        # Verify it's cached
+        tmpl2 = env.get_template("test.html")
+        assert tmpl1 is tmpl2
+
+        # Modify the file
+        time.sleep(1.1)  # Ensure mtime changes
+        template_file.write_text("Modified content")
+
+        # Trigger file monitoring callback manually for testing
+        loader._on_template_changed([str(template_file)])
+
+        # Template should be reloaded
+        tmpl3 = env.get_template("test.html")
+        assert tmpl3.render().strip() == "Modified content"
+
+    def test_cache_invalidation_on_file_deletion(self, tmp_path):
+        """Test that template cache is invalidated when files are deleted."""
+        template_dir = tmp_path / "templates"
+        template_dir.mkdir()
+        template_file = template_dir / "test.html"
+        template_file.write_text("Content")
+
+        loader = loaders.FileSystemLoader(str(template_dir))
+        env = Environment(loader=loader)
+
+        # Load template
+        tmpl = env.get_template("test.html")
+        assert tmpl.render().strip() == "Content"
+
+        # Delete the file and trigger callback
+        template_file.unlink()
+        loader._on_template_changed([str(template_file)])
+
+        # Template should be removed from cache
+        with pytest.raises(TemplateNotFound):
+            env.get_template("test.html")
+
+    def test_multiple_search_paths_monitoring(self, tmp_path):
+        """Test monitoring works with multiple search paths."""
+        dir1 = tmp_path / "templates1"
+        dir2 = tmp_path / "templates2"
+        dir1.mkdir()
+        dir2.mkdir()
+
+        file1 = dir1 / "test.html"
+        file2 = dir2 / "other.html"
+        file1.write_text("Content 1")
+        file2.write_text("Content 2")
+
+        loader = loaders.FileSystemLoader([str(dir1), str(dir2)])
+        env = Environment(loader=loader)
+
+        # Load templates
+        tmpl1 = env.get_template("test.html")
+        tmpl2 = env.get_template("other.html")
+
+        assert tmpl1.render().strip() == "Content 1"
+        assert tmpl2.render().strip() == "Content 2"
+
+        # Modify files and trigger callbacks
+        time.sleep(1.1)
+        file1.write_text("Modified 1")
+        file2.write_text("Modified 2")
+
+        loader._on_template_changed([str(file1), str(file2)])
+
+        # Both templates should be reloaded
+        new_tmpl1 = env.get_template("test.html")
+        new_tmpl2 = env.get_template("other.html")
+
+        assert new_tmpl1.render().strip() == "Modified 1"
+        assert new_tmpl2.render().strip() == "Modified 2"
+
+    def test_auto_reload_disabled_no_monitoring(self, tmp_path):
+        """Test that manual cache invalidation works when auto_reload is disabled."""
+        template_dir = tmp_path / "templates"
+        template_dir.mkdir()
+        template_file = template_dir / "test.html"
+        template_file.write_text("Original")
+
+        loader = loaders.FileSystemLoader(str(template_dir), auto_reload=False)
+        env = Environment(loader=loader)
+
+        # Load template
+        tmpl1 = env.get_template("test.html")
+        assert tmpl1.render().strip() == "Original"
+
+        # Verify it's cached
+        tmpl2 = env.get_template("test.html")
+        assert tmpl1 is tmpl2
+
+        # Modify file
+        time.sleep(1.1)
+        template_file.write_text("Modified")
+
+        # Manual cache invalidation should still work even when auto_reload is disabled
+        loader._on_template_changed([str(template_file)])
+
+        # Template should be reloaded after manual invalidation
+        tmpl3 = env.get_template("test.html")
+        assert tmpl3.render().strip() == "Modified"
+        assert tmpl1 is not tmpl3
+
+    def test_environment_tracking(self, tmp_path):
+        """Test that cache invalidation works across multiple environments."""
+        template_dir = tmp_path / "templates"
+        template_dir.mkdir()
+        template_file = template_dir / "test.html"
+        template_file.write_text("Content")
+
+        loader = loaders.FileSystemLoader(str(template_dir))
+        env1 = Environment(loader=loader)
+        env2 = Environment(loader=loader)
+
+        # Load templates in both environments
+        tmpl1 = env1.get_template("test.html")
+        tmpl2 = env2.get_template("test.html")
+
+        # Verify templates are cached
+        assert tmpl1 is env1.get_template("test.html")
+        assert tmpl2 is env2.get_template("test.html")
+
+        # Modify file and trigger callback
+        time.sleep(1.1)
+        template_file.write_text("Modified")
+        loader._on_template_changed([str(template_file)])
+
+        # Both environments should have cache invalidated
+        new_tmpl1 = env1.get_template("test.html")
+        new_tmpl2 = env2.get_template("test.html")
+
+        assert new_tmpl1.render().strip() == "Modified"
+        assert new_tmpl2.render().strip() == "Modified"
+        # Verify new templates are different objects (cache was invalidated)
+        assert tmpl1 is not new_tmpl1
+        assert tmpl2 is not new_tmpl2
+
+    def test_nested_directory_monitoring(self, tmp_path):
+        """Test monitoring works with nested directories."""
+        template_dir = tmp_path / "templates"
+        nested_dir = template_dir / "nested"
+        template_dir.mkdir()
+        nested_dir.mkdir()
+
+        nested_file = nested_dir / "nested.html"
+        nested_file.write_text("Nested content")
+
+        loader = loaders.FileSystemLoader(str(template_dir))
+        env = Environment(loader=loader)
+
+        # Load nested template
+        tmpl = env.get_template("nested/nested.html")
+        assert tmpl.render().strip() == "Nested content"
+
+        # Modify nested file
+        time.sleep(1.1)
+        nested_file.write_text("Modified nested")
+        loader._on_template_changed([str(nested_file)])
+
+        # Template should be reloaded
+        new_tmpl = env.get_template("nested/nested.html")
+        assert new_tmpl.render().strip() == "Modified nested"
+
+    def test_invalid_template_path_handling(self, tmp_path):
+        """Test handling of invalid template paths in monitoring."""
+        template_dir = tmp_path / "templates"
+        template_dir.mkdir()
+
+        loader = loaders.FileSystemLoader(str(template_dir))
+        env = Environment(loader=loader)
+
+        # Trigger callback with non-existent file
+        fake_file = str(template_dir / "nonexistent.html")
+        loader._on_template_changed([fake_file])
+
+        # Should not raise any errors
+        assert True
+
+    def test_monitoring_with_weak_references(self, tmp_path):
+        """Test that cache invalidation handles environment cleanup gracefully."""
+        template_dir = tmp_path / "templates"
+        template_dir.mkdir()
+        template_file = template_dir / "test.html"
+        template_file.write_text("Content")
+
+        loader = loaders.FileSystemLoader(str(template_dir))
+
+        # Create environment and let it go out of scope
+        def create_env():
+            env = Environment(loader=loader)
+            tmpl = env.get_template("test.html")
+            assert tmpl.render().strip() == "Content"
+            return env
+
+        env = create_env()
+ 
+        # Delete environment reference to test weak reference cleanup
+        del env
+        import gc
+        gc.collect()
+
+        # Trigger callback - should handle dead weak references gracefully
+        # This tests that the implementation doesn't crash when environments are garbage collected
+        loader._on_template_changed([str(template_file)])
+
+        # Should not raise any errors - this is the main behavioral test
+        assert True
