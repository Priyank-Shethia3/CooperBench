diff --git a/src/jinja2/loaders.py b/src/jinja2/loaders.py
index d7d9bd04..8240a379 100644
--- a/src/jinja2/loaders.py
+++ b/src/jinja2/loaders.py
@@ -11,6 +11,9 @@ from collections import abc
 from hashlib import sha1
 from importlib import import_module
 from types import ModuleType
+import fnmatch
+import re
+
 
 from .exceptions import TemplateNotFound
 from .utils import internalcode
@@ -71,6 +74,100 @@ class BaseLoader:
     #: .. versionadded:: 2.4
     has_source_access = True
 
+    # Internal container for filter objects that control list_templates output.
+    # A template is excluded if any filter matches it (OR logic).
+    #
+    # Supported filter types:
+    # - str: glob-style pattern, matched with fnmatch.fnmatchcase
+    # - compiled regex: any object with a .search callable attribute
+    # - callable: a function taking (path: str) -> bool indicating exclusion
+    _template_filters: t.List[t.Any]
+
+    def __init__(self) -> None:  # type: ignore[override]
+        # Keep backward compatibility: existing subclasses might not call super().__init__.
+        # Ensure attribute exists when BaseLoader is constructed.
+        self._template_filters = []
+
+    def add_filter(self, filter_pattern: t.Any) -> None:
+        """Register a filter used to exclude template names from list_templates().
+
+        The filter can be one of:
+        - str: Glob pattern (e.g., "*.txt", "admin/*").
+        - compiled regex: object with a callable .search attribute.
+        - callable: function(path: str) -> bool; return True to exclude.
+
+        Filters use OR logic: if any filter matches a path, it is excluded
+        from list_templates(). Does not affect get_source() or load().
+
+        .. versionadded:: 3.1
+           Template path filtering for loader listings.
+        """
+        # Initialize lazily in case subclass __init__ didn't call super().__init__
+        if not hasattr(self, "_template_filters"):
+            self._template_filters = []  # type: ignore[attr-defined]
+
+        is_valid = False
+        if isinstance(filter_pattern, str):
+            is_valid = True
+        elif hasattr(filter_pattern, "search") and callable(getattr(filter_pattern, "search")):
+            # compiled regex-like object
+            is_valid = True
+        elif callable(filter_pattern):
+            is_valid = True
+
+        if not is_valid:
+            raise TypeError(
+                "Unsupported filter type. Use a glob string, compiled regex with .search, or a callable."
+            )
+
+        self._template_filters.append(filter_pattern)
+
+    def clear_filters(self) -> None:
+        """Remove all registered filters.
+
+        After calling this method, list_templates() will return all templates
+        without any filtering, restoring the original behavior.
+
+        .. versionadded:: 3.1
+           Template path filtering for loader listings.
+        """
+        # Initialize lazily in case subclass __init__ didn't call super().__init__
+        if not hasattr(self, "_template_filters"):
+            self._template_filters = []  # type: ignore[attr-defined]
+        else:
+            self._template_filters.clear()
+
+    def _apply_filters(self, names: t.Iterable[str]) -> t.List[str]:
+        """Apply registered filters to an iterable of template names.
+
+        Returns a list excluding names that match any filter. If no filters
+        are registered, returns the input as a list unchanged.
+        """
+        filters = getattr(self, "_template_filters", [])  # type: ignore[attr-defined]
+        if not filters:
+            # Return as list to ensure consistent return type
+            return list(names)
+
+        def matches_any(path: str) -> bool:
+            for f in filters:
+                try:
+                    if isinstance(f, str):
+                        if fnmatch.fnmatchcase(path, f):
+                            return True
+                    elif hasattr(f, "search") and callable(getattr(f, "search")):
+                        if bool(f.search(path)):
+                            return True
+                    elif callable(f):
+                        if bool(f(path)):
+                            return True
+                except Exception:
+                    # Defensive: ignore misbehaving filters during matching
+                    # and treat as non-matching rather than failing listing.
+                    continue
+            return False
+
+        return [n for n in names if not matches_any(n)]
+
     def get_source(
         self, environment: "Environment", template: str
     ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:
@@ -181,6 +278,7 @@ class FileSystemLoader(BaseLoader):
         encoding: str = "utf-8",
         followlinks: bool = False,
     ) -> None:
+        super().__init__()
         if not isinstance(searchpath, abc.Iterable) or isinstance(searchpath, str):
             searchpath = [searchpath]
 
@@ -228,7 +326,8 @@ class FileSystemLoader(BaseLoader):
                         template = template[2:]
                     if template not in found:
                         found.add(template)
-        return sorted(found)
+        names = sorted(found)
+        return self._apply_filters(names)
 
 
 class PackageLoader(BaseLoader):
@@ -270,6 +369,7 @@ class PackageLoader(BaseLoader):
         package_path: "str" = "templates",
         encoding: str = "utf-8",
     ) -> None:
+        super().__init__()
         package_path = os.path.normpath(package_path).rstrip(os.path.sep)
 
         # normpath preserves ".", which isn't valid in zip paths.
@@ -389,7 +489,7 @@ class PackageLoader(BaseLoader):
                     results.append(name[offset:].replace(os.path.sep, "/"))
 
         results.sort()
-        return results
+        return self._apply_filters(results)
 
 
 class DictLoader(BaseLoader):
@@ -402,6 +502,7 @@ class DictLoader(BaseLoader):
     """
 
     def __init__(self, mapping: t.Mapping[str, str]) -> None:
+        super().__init__()
         self.mapping = mapping
 
     def get_source(
@@ -413,7 +514,8 @@ class DictLoader(BaseLoader):
         raise TemplateNotFound(template)
 
     def list_templates(self) -> t.List[str]:
-        return sorted(self.mapping)
+        names = sorted(self.mapping)
+        return self._apply_filters(names)
 
 
 class FunctionLoader(BaseLoader):
@@ -445,6 +547,7 @@ class FunctionLoader(BaseLoader):
             ],
         ],
     ) -> None:
+        super().__init__()
         self.load_func = load_func
 
     def get_source(
@@ -479,6 +582,7 @@ class PrefixLoader(BaseLoader):
     def __init__(
         self, mapping: t.Mapping[str, BaseLoader], delimiter: str = "/"
     ) -> None:
+        super().__init__()
         self.mapping = mapping
         self.delimiter = delimiter
 
@@ -521,7 +625,7 @@ class PrefixLoader(BaseLoader):
         for prefix, loader in self.mapping.items():
             for template in loader.list_templates():
                 result.append(prefix + self.delimiter + template)
-        return result
+        return self._apply_filters(result)
 
 
 class ChoiceLoader(BaseLoader):
@@ -539,6 +643,7 @@ class ChoiceLoader(BaseLoader):
     """
 
     def __init__(self, loaders: t.Sequence[BaseLoader]) -> None:
+        super().__init__()
         self.loaders = loaders
 
     def get_source(
@@ -569,7 +674,8 @@ class ChoiceLoader(BaseLoader):
         found = set()
         for loader in self.loaders:
             found.update(loader.list_templates())
-        return sorted(found)
+        names = sorted(found)
+        return self._apply_filters(names)
 
 
 class _TemplateModule(ModuleType):

