diff --git a/tests/test_loader.py b/tests/test_loader.py
index b300c8f2..4eed5484 100644
--- a/tests/test_loader.py
+++ b/tests/test_loader.py
@@ -401,3 +401,219 @@ def test_pep_451_import_hook():
         assert "test.html" in package_loader.list_templates()
     finally:
         sys.meta_path[:] = before
+
+
+class TestTemplateFiltering:
+    def test_filesystem_loader_glob_filter(self, filesystem_loader):
+        # Add glob pattern filter
+        filesystem_loader.add_filter("*.txt")
+        templates = filesystem_loader.list_templates()
+
+        # Should exclude .txt files but include .html files
+        assert "test.html" in templates
+        assert "foo/test.html" in templates
+        assert "mojibake.txt" not in templates
+
+    def test_filesystem_loader_regex_filter(self, filesystem_loader):
+        import re
+        # Add regex pattern filter
+        filesystem_loader.add_filter(re.compile(r".*\.txt$"))
+        templates = filesystem_loader.list_templates()
+
+        # Should exclude .txt files but include .html files
+        assert "test.html" in templates
+        assert "foo/test.html" in templates
+        assert "mojibake.txt" not in templates
+
+    def test_filesystem_loader_callable_filter(self, filesystem_loader):
+        # Add callable filter
+        filesystem_loader.add_filter(lambda path: path.startswith("foo/"))
+        templates = filesystem_loader.list_templates()
+
+        # Should exclude files in foo/ directory
+        assert "test.html" in templates
+        assert "foo/test.html" not in templates
+
+    def test_dict_loader_filter(self):
+        mapping = {
+            "index.html": "content1",
+            "admin.html": "content2",
+            "secret.txt": "content3",
+            "public.html": "content4"
+        }
+        loader = loaders.DictLoader(mapping)
+
+        # Add filter to exclude admin and secret files
+        loader.add_filter("admin.*")
+        loader.add_filter("secret.*")
+
+        templates = loader.list_templates()
+        assert "index.html" in templates
+        assert "public.html" in templates
+        assert "admin.html" not in templates
+        assert "secret.txt" not in templates
+
+    def test_package_loader_filter(self, package_loader):
+        # Add filter to exclude foo directory
+        package_loader.add_filter("foo/*")
+        templates = package_loader.list_templates()
+
+        # Should exclude files in foo/ directory
+        assert "test.html" in templates
+        assert "foo/test.html" not in templates
+
+    def test_multiple_filters(self, filesystem_loader):
+        import re
+        # Add multiple filters
+        filesystem_loader.add_filter("*.txt")  # Glob filter
+        filesystem_loader.add_filter(re.compile(r"broken\.html$"))  # Regex filter
+        filesystem_loader.add_filter(lambda path: "sub" in path)  # Callable filter
+
+        templates = filesystem_loader.list_templates()
+
+        # Should exclude files matching any filter
+        assert "test.html" in templates
+        assert "foo/test.html" in templates
+        assert "mojibake.txt" not in templates
+        assert "broken.html" not in templates
+        assert "subbroken.html" not in templates
+
+    def test_choice_loader_filter(self, choice_loader):
+        # Add filter to one of the underlying loaders
+        choice_loader.loaders[0].add_filter("*.html")
+        templates = choice_loader.list_templates()
+
+        # Should still include templates from other loaders
+        assert len(templates) > 0
+
+    def test_prefix_loader_filter(self, prefix_loader):
+        # Add filter to one of the underlying loaders
+        prefix_loader.mapping["a"].add_filter("*.html")
+        templates = prefix_loader.list_templates()
+
+        # Should exclude filtered templates with prefix
+        filtered_templates = [t for t in templates if t.startswith("a/") and t.endswith(".html")]
+        assert len(filtered_templates) == 0
+
+        # Should still include templates from other prefixes
+        b_templates = [t for t in templates if t.startswith("b/")]
+        assert len(b_templates) > 0
+
+    def test_filter_does_not_affect_get_source(self, filesystem_loader):
+        # Add filter
+        filesystem_loader.add_filter("*.txt")
+
+        # Should still be able to load filtered templates directly
+        env = Environment(loader=filesystem_loader)
+        # This should work even though mojibake.txt is filtered
+        template = env.get_template("mojibake.txt")
+        assert template is not None
+
+    def test_empty_filter_list(self, filesystem_loader):
+        # No filters added - should return all templates
+        templates_before = filesystem_loader.list_templates()
+
+        # Add and remove filter
+        filesystem_loader.add_filter("*.txt")
+        filesystem_loader.clear_filters()
+        templates_after = filesystem_loader.list_templates()
+
+        assert templates_before == templates_after
+
+    def test_filter_edge_cases(self):
+        mapping = {
+            "": "empty_name",
+            ".hidden": "hidden_file",
+            "normal.html": "normal_file"
+        }
+        loader = loaders.DictLoader(mapping)
+
+        # Filter empty and hidden files
+        loader.add_filter("")
+        loader.add_filter(".*")
+
+        templates = loader.list_templates()
+        assert "" not in templates
+        assert ".hidden" not in templates
+        assert "normal.html" in templates
+
+    def test_backward_compatibility(self, filesystem_loader):
+        # Test that loaders without filters behave exactly as before
+        templates_original = filesystem_loader.list_templates()
+ 
+        # Add a filter, then clear it
+        filesystem_loader.add_filter("*.nonexistent")
+        filesystem_loader.clear_filters()
+        templates_after_clear = filesystem_loader.list_templates()
+ 
+        # Should be identical
+        assert templates_original == templates_after_clear
+
+    def test_invalid_filter_types(self):
+        loader = loaders.DictLoader({"test.html": "content"})
+ 
+        # Should raise TypeError for invalid filter types
+        with pytest.raises(TypeError):
+            loader.add_filter(123)  # Invalid type
+ 
+        with pytest.raises(TypeError):
+            loader.add_filter(None)  # Invalid type
+
+    def test_filter_persistence(self, filesystem_loader):
+        # Test that filters persist across multiple list_templates() calls
+        filesystem_loader.add_filter("*.txt")
+ 
+        templates1 = filesystem_loader.list_templates()
+        templates2 = filesystem_loader.list_templates()
+ 
+        # Should be identical and exclude .txt files
+        assert templates1 == templates2
+        assert "mojibake.txt" not in templates1
+        assert "mojibake.txt" not in templates2
+
+    def test_filter_order_independence(self):
+        mapping = {
+            "file1.txt": "content1",
+            "file2.html": "content2",
+            "file3.py": "content3"
+        }
+ 
+        loader1 = loaders.DictLoader(mapping)
+        loader2 = loaders.DictLoader(mapping)
+ 
+        # Add filters in different orders
+        loader1.add_filter("*.txt")
+        loader1.add_filter("*.py")
+ 
+        loader2.add_filter("*.py")
+        loader2.add_filter("*.txt")
+ 
+        templates1 = loader1.list_templates()
+        templates2 = loader2.list_templates()
+ 
+        # Results should be identical regardless of filter order
+        assert sorted(templates1) == sorted(templates2)
+        assert "file2.html" in templates1
+        assert "file1.txt" not in templates1
+        assert "file3.py" not in templates1
+
+    def test_callable_filter_exception_handling(self):
+        mapping = {"test.html": "content", "error.html": "content"}
+        loader = loaders.DictLoader(mapping)
+ 
+        def problematic_filter(path):
+            if path == "error.html":
+                raise ValueError("Filter error")
+            return False
+ 
+        loader.add_filter(problematic_filter)
+ 
+        # Should handle filter exceptions gracefully
+        # The exact behavior may vary, but it shouldn't crash
+        try:
+            templates = loader.list_templates()
+            # If it succeeds, verify basic functionality
+            assert isinstance(templates, list)
+        except ValueError:
+            # If it propagates the exception, that's also acceptable behavior
+            pass
