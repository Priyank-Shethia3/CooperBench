diff --git a/src/jinja2/loaders.py b/src/jinja2/loaders.py
index d7d9bd04..56b56e66 100644
--- a/src/jinja2/loaders.py
+++ b/src/jinja2/loaders.py
@@ -11,6 +11,9 @@ from collections import abc
 from hashlib import sha1
 from importlib import import_module
 from types import ModuleType
+import fnmatch
+import re
+import threading
 
 from .exceptions import TemplateNotFound
 from .utils import internalcode
@@ -21,10 +24,43 @@ if t.TYPE_CHECKING:
     from .environment import Template
 
 
+def validate_template_path(template: str) -> None:
+    """Validate template path for security issues and malformed paths.
+
+    Raises TemplateNotFound if the path contains:
+    - Null bytes
+    - Absolute paths (starting with /)
+    - Windows drive letters (C:, D:, etc.)
+    - Control characters
+    """
+    if not template:
+        raise TemplateNotFound(template)
+
+    # Check for null bytes
+    if '\x00' in template:
+        raise TemplateNotFound(template)
+
+    # Check for absolute paths
+    if template.startswith('/') or template.startswith('\\'):
+        raise TemplateNotFound(template)
+
+    # Check for Windows drive letters (C:, D:, etc.)
+    if len(template) >= 2 and template[1] == ':' and template[0].isalpha():
+        raise TemplateNotFound(template)
+
+    # Check for control characters (except tab, newline, carriage return)
+    for char in template:
+        if ord(char) < 32 and char not in '\t\n\r':
+            raise TemplateNotFound(template)
+
+
 def split_template_path(template: str) -> t.List[str]:
     """Split a path into segments and perform a sanity check.  If it detects
     '..' in the path it will raise a `TemplateNotFound` error.
     """
+    # Validate the template path first
+    validate_template_path(template)
+
     pieces = []
     for piece in template.split("/"):
         if (
@@ -71,6 +107,113 @@ class BaseLoader:
     #: .. versionadded:: 2.4
     has_source_access = True
 
+    # Internal container for filter objects that control list_templates output.
+    _template_filters: t.List[t.Any]
+
+    def __init__(self, path_transform: t.Optional[t.Callable[[str], str]] = None) -> None:
+        """Initialize the loader with an optional path transformation function.
+
+        :param path_transform: Optional function that takes a template path
+            and returns a transformed path. This allows for custom path
+            rewriting rules during template lookup.
+        """
+        self.path_transform = path_transform
+        self.aliases: t.Dict[str, str] = {}
+        self._template_filters = []
+
+    def add_filter(self, filter_pattern: t.Any) -> None:
+        """Register a filter used to exclude template names from list_templates().
+
+        The filter can be one of:
+        - str: Glob pattern (e.g., "*.txt", "admin/*").
+        - compiled regex: object with a callable .search attribute.
+        - callable: function(path: str) -> bool; return True to exclude.
+
+        Filters use OR logic: if any filter matches a path, it is excluded
+        from list_templates(). Does not affect get_source() or load().
+        """
+        if not hasattr(self, "_template_filters"):
+            self._template_filters = []
+
+        is_valid = False
+        if isinstance(filter_pattern, str):
+            is_valid = True
+        elif hasattr(filter_pattern, "search") and callable(getattr(filter_pattern, "search")):
+            is_valid = True
+        elif callable(filter_pattern):
+            is_valid = True
+
+        if not is_valid:
+            raise TypeError(
+                "Unsupported filter type. Use a glob string, compiled regex with .search, or a callable."
+            )
+
+        self._template_filters.append(filter_pattern)
+
+    def clear_filters(self) -> None:
+        """Remove all registered filters."""
+        if not hasattr(self, "_template_filters"):
+            self._template_filters = []
+        else:
+            self._template_filters.clear()
+
+    def _apply_filters(self, names: t.Iterable[str]) -> t.List[str]:
+        """Apply registered filters to an iterable of template names."""
+        filters = getattr(self, "_template_filters", [])
+        if not filters:
+            return list(names)
+
+        def matches_any(path: str) -> bool:
+            for f in filters:
+                try:
+                    if isinstance(f, str):
+                        if fnmatch.fnmatchcase(path, f):
+                            return True
+                    elif hasattr(f, "search") and callable(getattr(f, "search")):
+                        if bool(f.search(path)):
+                            return True
+                    elif callable(f):
+                        if bool(f(path)):
+                            return True
+                except Exception:
+                    continue
+            return False
+
+        return [n for n in names if not matches_any(n)]
+
+    def add_alias(self, alias: str, target: str) -> None:
+        """Add a template path alias.
+
+        :param alias: The alias name for the template
+        :param target: The actual template path
+        """
+        self.aliases[alias] = target
+
+    def remove_alias(self, alias: str) -> None:
+        """Remove a template path alias.
+
+        :param alias: The alias name to remove
+        """
+        self.aliases.pop(alias, None)
+
+    def resolve_template_name(self, template: str) -> str:
+        """Resolve template name through aliases.
+
+        :param template: The template name (possibly an alias)
+        :return: The actual template path
+        """
+        return self.aliases.get(template, template)
+
+    def transform_path(self, template: str) -> str:
+        """Transform a template path using the configured transformation function.
+
+        :param template: The original template path
+        :return: The transformed template path
+        """
+        if self.path_transform is not None:
+            return self.path_transform(template)
+        return template
+
     def get_source(
         self, environment: "Environment", template: str
     ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:
@@ -165,33 +308,270 @@ class FileSystemLoader(BaseLoader):
 
         loader = FileSystemLoader(["/override/templates", "/default/templates"])
 
+    Paths can be assigned priorities to control search order:
+
+    .. code-block:: python
+
+        loader = FileSystemLoader([
+            ("/high/priority", 100),
+            ("/low/priority", 10),
+            "/default/templates"  # priority 0 by default
+        ])
+
     :param searchpath: A path, or list of paths, to the directory that
-        contains the templates.
+        contains the templates. Each path can be a string/PathLike or a
+        tuple of (path, priority) where priority is a numeric value.
+        Higher priority paths are searched first.
     :param encoding: Use this encoding to read the text from template
         files.
     :param followlinks: Follow symbolic links in the path.
+    :param fallback_searchpath: A path, or list of paths, to fallback
+        directories that are searched when templates are not found in
+        primary searchpath.
+    :param path_transform: Optional function that takes a template path
+        and returns a transformed path.
 
     .. versionchanged:: 2.8
         Added the ``followlinks`` parameter.
+    .. versionchanged:: 3.1
+        Added support for path priorities.
     """
 
     def __init__(
         self,
-        searchpath: t.Union[str, os.PathLike, t.Sequence[t.Union[str, os.PathLike]]],
+        searchpath: t.Union[
+            str,
+            os.PathLike,
+            t.Sequence[t.Union[str, os.PathLike, t.Tuple[t.Union[str, os.PathLike], int]]]
+        ],
         encoding: str = "utf-8",
         followlinks: bool = False,
+        fallback_searchpath: t.Optional[t.Union[str, os.PathLike, t.Sequence[t.Union[str, os.PathLike]]]] = None,
+        path_transform: t.Optional[t.Callable[[str], str]] = None,
+        auto_reload: bool = True,
     ) -> None:
+        super().__init__(path_transform=path_transform)
         if not isinstance(searchpath, abc.Iterable) or isinstance(searchpath, str):
             searchpath = [searchpath]
 
-        self.searchpath = [os.fspath(p) for p in searchpath]
+        # Helper to expand path with env vars and user home
+        def expand_path(p: t.Union[str, os.PathLike]) -> str:
+            path_str = os.fspath(p)
+            return os.path.expanduser(os.path.expandvars(path_str))
+
+        # Process paths and priorities
+        path_priority_pairs = []
+        for i, item in enumerate(searchpath):
+            if isinstance(item, tuple) and len(item) == 2:
+                path, priority = item
+                path_priority_pairs.append((expand_path(path), priority, i))
+            else:
+                # Handle invalid tuples by treating them as regular paths
+                if isinstance(item, tuple):
+                    if len(item) > 0:
+                        try:
+                            path_priority_pairs.append((expand_path(item[0]), 0, i))
+                        except (TypeError, IndexError):
+                            continue
+                    else:
+                        continue
+                else:
+                    path_priority_pairs.append((expand_path(item), 0, i))
+
+        # Sort by priority (highest first), then by original order for same priority
+        path_priority_pairs.sort(key=lambda x: (-x[1], x[2]))
+
+        self.searchpath = [path for path, _, _ in path_priority_pairs]
+        self._path_priorities = {path: priority for path, priority, _ in path_priority_pairs}
         self.encoding = encoding
         self.followlinks = followlinks
 
+        # Handle fallback search paths
+        if fallback_searchpath is None:
+            self.fallback_searchpath = []
+        else:
+            if not isinstance(fallback_searchpath, abc.Iterable) or isinstance(fallback_searchpath, str):
+                fallback_searchpath = [fallback_searchpath]
+            self.fallback_searchpath = [expand_path(p) for p in fallback_searchpath]
+
+        # Initialize path cache
+        self._path_cache: t.Dict[str, t.Optional[str]] = {}
+
+        # Auto-reload monitoring
+        self.auto_reload = auto_reload
+        self._environments: "weakref.WeakSet[Environment]" = weakref.WeakSet()
+        self._searchpath_abs = [os.path.abspath(p) for p in self.searchpath]
+        self._snapshot: t.Dict[str, float] = {}
+        self._lock = threading.Lock()
+        self._stop_event = threading.Event()
+        self._poll_interval = 1.0
+        self._watcher_thread: t.Optional[threading.Thread] = None
+
+        # Build initial snapshot safely
+        try:
+            self._snapshot = self._build_snapshot()
+        except Exception:
+            self._snapshot = {}
+
+        # Start watcher thread if enabled
+        if self.auto_reload:
+            self._watcher_thread = threading.Thread(
+                target=self._watch_paths,
+                name=f"jinja2.FileSystemLoader.watch.{id(self):x}",
+                daemon=True,
+            )
+            self._watcher_thread.start()
+
+    def _register_environment(self, environment: "Environment") -> None:
+        """Track environments that use this loader via weak references."""
+        if self.auto_reload:
+            try:
+                self._environments.add(environment)
+            except Exception:
+                pass
+
+    def _build_snapshot(self) -> t.Dict[str, float]:
+        """Walk all search paths and return a mapping of absolute file path to mtime."""
+        snapshot: t.Dict[str, float] = {}
+        for root in self._searchpath_abs:
+            if not os.path.isdir(root):
+                continue
+            for dirpath, _, filenames in os.walk(root, followlinks=self.followlinks):
+                for fname in filenames:
+                    fpath = os.path.join(dirpath, fname)
+                    try:
+                        snapshot[fpath] = os.path.getmtime(fpath)
+                    except OSError:
+                        continue
+        return snapshot
+
+    def _path_to_template_name(self, abs_path: str) -> t.Optional[str]:
+        for root in self._searchpath_abs:
+            root_prefix = root.rstrip(os.path.sep) + os.path.sep
+            if abs_path.startswith(root_prefix) or abs_path == root:
+                rel = os.path.relpath(abs_path, root)
+                template = rel.replace(os.path.sep, "/").lstrip("./")
+                return template
+        return None
+
+    def _invalidate_names(self, names: t.Set[str]) -> None:
+        if not names:
+            return
+        for env in list(self._environments):
+            if env is None:
+                continue
+            cache = getattr(env, "cache", None)
+            if not cache:
+                continue
+            to_delete: t.List[t.Tuple[weakref.ref, str]] = []
+            for key in list(cache.keys()):
+                try:
+                    loader_ref, name = key
+                except Exception:
+                    continue
+                if name in names:
+                    obj = loader_ref()
+                    if obj is self:
+                        to_delete.append(key)
+            for key in to_delete:
+                try:
+                    del cache[key]
+                except Exception:
+                    pass
+
+    def _on_template_changed(self, file_paths: t.List[str]) -> None:
+        """Manual cache invalidation method for testing purposes."""
+        changed_names: t.Set[str] = set()
+        for file_path in file_paths:
+            name = self._path_to_template_name(file_path)
+            if name:
+                changed_names.add(name)
+        if changed_names:
+            self._invalidate_names(changed_names)
+
+    def scan_once(self) -> t.Set[str]:
+        """Run a single scan for changed files and invalidate caches."""
+        with self._lock:
+            new_snapshot = self._build_snapshot()
+            old_snapshot = self._snapshot
+            added_paths = set(new_snapshot) - set(old_snapshot)
+            removed_paths = set(old_snapshot) - set(new_snapshot)
+            modified_paths = {
+                p for p, m in new_snapshot.items() if old_snapshot.get(p) != m
+            }
+            self._snapshot = new_snapshot
+
+        changed_paths = added_paths | removed_paths | modified_paths
+        changed_names: t.Set[str] = set()
+        for p in changed_paths:
+            name = self._path_to_template_name(p)
+            if name:
+                changed_names.add(name)
+        if changed_names:
+            self._invalidate_names(changed_names)
+        return changed_names
+
+    def _watch_paths(self) -> None:
+        while not self._stop_event.is_set():
+            try:
+                self.scan_once()
+            except Exception:
+                pass
+            self._stop_event.wait(self._poll_interval)
+
+    def close(self) -> None:
+        """Stop the background watcher thread if it's running."""
+        self._stop_event.set()
+        t = self._watcher_thread
+        if t is not None and t.is_alive():
+            try:
+                t.join(timeout=0.5)
+            except Exception:
+                pass
+
     def get_source(
         self, environment: "Environment", template: str
     ) -> t.Tuple[str, str, t.Callable[[], bool]]:
+        # Register this environment to enable cache invalidation
+        self._register_environment(environment)
+
+        # Resolve alias first, then transform
+        template = self.resolve_template_name(template)
+        template = self.transform_path(template)
+        template = os.path.normpath(template)
+
+        # Check path cache first
+        if template in self._path_cache:
+            cached_filename = self._path_cache[template]
+            if cached_filename is not None:
+                # Use cached path directly
+                f = open_if_exists(cached_filename)
+                if f is not None:
+                    try:
+                        contents = f.read().decode(self.encoding)
+                    finally:
+                        f.close()
+
+                    mtime = os.path.getmtime(cached_filename)
+
+                    def uptodate() -> bool:
+                        try:
+                            return os.path.getmtime(cached_filename) == mtime
+                        except OSError:
+                            return False
+
+                    return contents, cached_filename, uptodate
+                else:
+                    # Cached path no longer exists, remove from cache
+                    del self._path_cache[template]
+            else:
+                # Template was cached as not found
+                raise TemplateNotFound(template)
+
+        # Path not cached, perform normal resolution
         pieces = split_template_path(template)
+
+        # First try primary search paths
         for searchpath in self.searchpath:
             filename = os.path.join(searchpath, *pieces)
             f = open_if_exists(filename)
@@ -210,11 +590,41 @@ class FileSystemLoader(BaseLoader):
                 except OSError:
                     return False
 
+            # Cache the resolved path
+            self._path_cache[template] = filename
+            return contents, filename, uptodate
+
+        # If not found in primary paths, try fallback paths
+        for searchpath in self.fallback_searchpath:
+            filename = os.path.join(searchpath, *pieces)
+            f = open_if_exists(filename)
+            if f is None:
+                continue
+            try:
+                contents = f.read().decode(self.encoding)
+            finally:
+                f.close()
+
+            mtime = os.path.getmtime(filename)
+
+            def uptodate() -> bool:
+                try:
+                    return os.path.getmtime(filename) == mtime
+                except OSError:
+                    return False
+
+            # Cache the resolved path
+            self._path_cache[template] = filename
             return contents, filename, uptodate
+
+        # Template not found, cache this result
+        self._path_cache[template] = None
         raise TemplateNotFound(template)
 
     def list_templates(self) -> t.List[str]:
         found = set()
+
+        # Add templates from primary search paths
         for searchpath in self.searchpath:
             walk_dir = os.walk(searchpath, followlinks=self.followlinks)
             for dirpath, _, filenames in walk_dir:
@@ -228,7 +638,23 @@ class FileSystemLoader(BaseLoader):
                         template = template[2:]
                     if template not in found:
                         found.add(template)
-        return sorted(found)
+
+        # Add templates from fallback search paths
+        for searchpath in self.fallback_searchpath:
+            walk_dir = os.walk(searchpath, followlinks=self.followlinks)
+            for dirpath, _, filenames in walk_dir:
+                for filename in filenames:
+                    template = (
+                        os.path.join(dirpath, filename)[len(searchpath) :]
+                        .strip(os.path.sep)
+                        .replace(os.path.sep, "/")
+                    )
+                    if template[:2] == "./":
+                        template = template[2:]
+                    if template not in found:
+                        found.add(template)
+
+        return self._apply_filters(sorted(found))
 
 
 class PackageLoader(BaseLoader):
@@ -270,6 +696,7 @@ class PackageLoader(BaseLoader):
         package_path: "str" = "templates",
         encoding: str = "utf-8",
     ) -> None:
+        super().__init__()
         package_path = os.path.normpath(package_path).rstrip(os.path.sep)
 
         # normpath preserves ".", which isn't valid in zip paths.
@@ -326,6 +753,8 @@ class PackageLoader(BaseLoader):
     def get_source(
         self, environment: "Environment", template: str
     ) -> t.Tuple[str, str, t.Optional[t.Callable[[], bool]]]:
+        template = self.resolve_template_name(template)
+        template = os.path.normpath(template)
         p = os.path.join(self._template_root, *split_template_path(template))
         up_to_date: t.Optional[t.Callable[[], bool]]
 
@@ -389,7 +818,7 @@ class PackageLoader(BaseLoader):
                     results.append(name[offset:].replace(os.path.sep, "/"))
 
         results.sort()
-        return results
+        return self._apply_filters(results)
 
 
 class DictLoader(BaseLoader):
@@ -401,19 +830,27 @@ class DictLoader(BaseLoader):
     Because auto reloading is rarely useful this is disabled per default.
     """
 
-    def __init__(self, mapping: t.Mapping[str, str]) -> None:
+    def __init__(
+        self,
+        mapping: t.Mapping[str, str],
+        path_transform: t.Optional[t.Callable[[str], str]] = None,
+    ) -> None:
+        super().__init__(path_transform=path_transform)
         self.mapping = mapping
 
     def get_source(
         self, environment: "Environment", template: str
     ) -> t.Tuple[str, None, t.Callable[[], bool]]:
-        if template in self.mapping:
-            source = self.mapping[template]
-            return source, None, lambda: source == self.mapping.get(template)
+        # Resolve alias first, then transform
+        template = self.resolve_template_name(template)
+        transformed_template = self.transform_path(template)
+        if transformed_template in self.mapping:
+            source = self.mapping[transformed_template]
+            return source, None, lambda: source == self.mapping.get(transformed_template)
         raise TemplateNotFound(template)
 
     def list_templates(self) -> t.List[str]:
-        return sorted(self.mapping)
+        return self._apply_filters(sorted(self.mapping))
 
 
 class FunctionLoader(BaseLoader):
@@ -444,13 +881,18 @@ class FunctionLoader(BaseLoader):
                 ]
             ],
         ],
+        path_transform: t.Optional[t.Callable[[str], str]] = None,
     ) -> None:
+        super().__init__(path_transform=path_transform)
         self.load_func = load_func
 
     def get_source(
         self, environment: "Environment", template: str
     ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:
-        rv = self.load_func(template)
+        # Resolve alias first, then transform
+        template = self.resolve_template_name(template)
+        transformed_template = self.transform_path(template)
+        rv = self.load_func(transformed_template)
 
         if rv is None:
             raise TemplateNotFound(template)
@@ -479,6 +921,7 @@ class PrefixLoader(BaseLoader):
     def __init__(
         self, mapping: t.Mapping[str, BaseLoader], delimiter: str = "/"
     ) -> None:
+        super().__init__()
         self.mapping = mapping
         self.delimiter = delimiter
 
@@ -521,7 +964,7 @@ class PrefixLoader(BaseLoader):
         for prefix, loader in self.mapping.items():
             for template in loader.list_templates():
                 result.append(prefix + self.delimiter + template)
-        return result
+        return self._apply_filters(result)
 
 
 class ChoiceLoader(BaseLoader):
@@ -539,6 +982,7 @@ class ChoiceLoader(BaseLoader):
     """
 
     def __init__(self, loaders: t.Sequence[BaseLoader]) -> None:
+        super().__init__()
         self.loaders = loaders
 
     def get_source(
@@ -569,7 +1013,7 @@ class ChoiceLoader(BaseLoader):
         found = set()
         for loader in self.loaders:
             found.update(loader.list_templates())
-        return sorted(found)
+        return self._apply_filters(sorted(found))
 
 
 class _TemplateModule(ModuleType):
