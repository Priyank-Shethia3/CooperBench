diff --git a/src/jinja2/filters.py b/src/jinja2/filters.py
index 80ea6504..41371b81 100644
--- a/src/jinja2/filters.py
+++ b/src/jinja2/filters.py
@@ -1,4 +1,5 @@
 """Built-in template filters used with the ``|`` operator."""
+
 import math
 import random
 import re
@@ -122,7 +123,7 @@ def make_multi_attrgetter(
 
 
 def _prepare_attribute_parts(
-    attr: t.Optional[t.Union[str, int]]
+    attr: t.Optional[t.Union[str, int]],
 ) -> t.List[t.Union[str, int]]:
     if attr is None:
         return []
@@ -142,7 +143,7 @@ def do_forceescape(value: "t.Union[str, HasHTML]") -> Markup:
 
 
 def do_urlencode(
-    value: t.Union[str, t.Mapping[str, t.Any], t.Iterable[t.Tuple[str, t.Any]]]
+    value: t.Union[str, t.Mapping[str, t.Any], t.Iterable[t.Tuple[str, t.Any]]],
 ) -> str:
     """Quote data for use in a URL path or query using UTF-8.
 
@@ -1161,8 +1162,9 @@ class _GroupTuple(t.NamedTuple):
 def sync_do_groupby(
     environment: "Environment",
     value: "t.Iterable[V]",
-    attribute: t.Union[str, int],
+    attribute: t.Union[str, int, t.List[t.Union[str, int]]],
     default: t.Optional[t.Any] = None,
+    levels: t.Optional[int] = None,
 ) -> "t.List[t.Tuple[t.Any, t.List[V]]]":
     """Group a sequence of objects by an attribute using Python's
     :func:`itertools.groupby`. The attribute can use dot notation for
@@ -1203,12 +1205,69 @@ def sync_do_groupby(
           <li>{{ city }}: {{ items|map(attribute="name")|join(", ") }}</li>
         {% endfor %}</ul>
 
+    Multi-level grouping is supported by providing a list of attributes
+    and specifying the ``levels`` parameter. For example, to group by
+    department and then by role:
+
+    .. sourcecode:: jinja
+
+        {% for dept_group in users|groupby(["department", "role"], levels=2) %}
+          <h2>{{ dept_group.grouper }}</h2>
+          {% for role_group in dept_group.list %}
+            <h3>{{ role_group.grouper }}</h3>
+            <ul>{% for user in role_group.list %}
+              <li>{{ user.name }}</li>
+            {% endfor %}</ul>
+          {% endfor %}
+        {% endfor %}
+
+    .. versionchanged:: 3.1
+        Added multi-level grouping with ``levels`` parameter.
+
     .. versionchanged:: 3.0
         Added the ``default`` parameter.
 
     .. versionchanged:: 2.6
         The attribute supports dot notation for nested access.
     """
+    # Handle multi-level grouping
+    if levels is not None and levels > 1:
+        if not isinstance(attribute, list):
+            raise FilterArgumentError(
+                "Multi-level grouping requires a list of attributes"
+            )
+        if len(attribute) < levels:
+            raise FilterArgumentError(
+                f"Not enough attributes for {levels} levels of grouping"
+            )
+
+        # First level grouping
+        first_attr = attribute[0]
+        expr = make_attrgetter(environment, first_attr, default=default)
+        first_level_groups = [
+            _GroupTuple(key, list(values))
+            for key, values in groupby(sorted(value, key=expr), expr)
+        ]
+
+        # Apply recursive grouping to each first-level group
+        if levels > 1:
+            for group in first_level_groups:
+                # Recursively group the items in this group
+                remaining_attrs = attribute[1:]
+                remaining_levels = levels - 1
+                group.list[:] = sync_do_groupby(
+                    environment, group.list, remaining_attrs, default, remaining_levels
+                )
+
+        return first_level_groups
+
+    # Single-level grouping (original behavior)
+    if isinstance(attribute, list):
+        if len(attribute) == 1:
+            attribute = attribute[0]
+        else:
+            raise FilterArgumentError("Multiple attributes require levels parameter")
+
     expr = make_attrgetter(environment, attribute, default=default)
     return [
         _GroupTuple(key, list(values))
@@ -1220,14 +1279,15 @@ def sync_do_groupby(
 async def do_groupby(
     environment: "Environment",
     value: "t.Union[t.AsyncIterable[V], t.Iterable[V]]",
-    attribute: t.Union[str, int],
+    attribute: t.Union[str, int, t.List[t.Union[str, int]]],
     default: t.Optional[t.Any] = None,
+    levels: t.Optional[int] = None,
 ) -> "t.List[t.Tuple[t.Any, t.List[V]]]":
-    expr = make_attrgetter(environment, attribute, default=default)
-    return [
-        _GroupTuple(key, await auto_to_list(values))
-        for key, values in groupby(sorted(await auto_to_list(value), key=expr), expr)
-    ]
+    # Convert async iterable to list first
+    value_list = await auto_to_list(value)
+
+    # Use the sync version for the actual grouping logic
+    return sync_do_groupby(environment, value_list, attribute, default, levels)
 
 
 @pass_environment
@@ -1304,13 +1364,11 @@ def do_mark_unsafe(value: str) -> str:
 
 
 @typing.overload
-def do_reverse(value: str) -> str:
-    ...
+def do_reverse(value: str) -> str: ...
 
 
 @typing.overload
-def do_reverse(value: "t.Iterable[V]") -> "t.Iterable[V]":
-    ...
+def do_reverse(value: "t.Iterable[V]") -> "t.Iterable[V]": ...
 
 
 def do_reverse(value: t.Union[str, t.Iterable[V]]) -> t.Union[str, t.Iterable[V]]:
@@ -1365,8 +1423,7 @@ def do_attr(
 @typing.overload
 def sync_do_map(
     context: "Context", value: t.Iterable, name: str, *args: t.Any, **kwargs: t.Any
-) -> t.Iterable:
-    ...
+) -> t.Iterable: ...
 
 
 @typing.overload
@@ -1376,8 +1433,7 @@ def sync_do_map(
     *,
     attribute: str = ...,
     default: t.Optional[t.Any] = None,
-) -> t.Iterable:
-    ...
+) -> t.Iterable: ...
 
 
 @pass_context
@@ -1437,8 +1493,7 @@ def do_map(
     name: str,
     *args: t.Any,
     **kwargs: t.Any,
-) -> t.Iterable:
-    ...
+) -> t.Iterable: ...
 
 
 @typing.overload
@@ -1448,8 +1503,7 @@ def do_map(
     *,
     attribute: str = ...,
     default: t.Optional[t.Any] = None,
-) -> t.Iterable:
-    ...
+) -> t.Iterable: ...
 
 
 @async_variant(sync_do_map)  # type: ignore
