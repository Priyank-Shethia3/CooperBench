diff --git a/src/jinja2/filters.py b/src/jinja2/filters.py
index 80ea6504..735b21ad 100644
--- a/src/jinja2/filters.py
+++ b/src/jinja2/filters.py
@@ -57,13 +57,14 @@ def make_attrgetter(
     attribute: t.Optional[t.Union[str, int]],
     postprocess: t.Optional[t.Callable[[t.Any], t.Any]] = None,
     default: t.Optional[t.Any] = None,
+    separator: str = ".",
 ) -> t.Callable[[t.Any], t.Any]:
     """Returns a callable that looks up the given attribute from a
     passed object with the rules of the environment.  Dots are allowed
     to access attributes of attributes.  Integer parts in paths are
     looked up as integers.
     """
-    parts = _prepare_attribute_parts(attribute)
+    parts = _prepare_attribute_parts(attribute, separator)
 
     def attrgetter(item: t.Any) -> t.Any:
         for part in parts:
@@ -84,6 +85,7 @@ def make_multi_attrgetter(
     environment: "Environment",
     attribute: t.Optional[t.Union[str, int]],
     postprocess: t.Optional[t.Callable[[t.Any], t.Any]] = None,
+    separator: str = ".",
 ) -> t.Callable[[t.Any], t.List[t.Any]]:
     """Returns a callable that looks up the given comma separated
     attributes from a passed object with the rules of the environment.
@@ -100,7 +102,7 @@ def make_multi_attrgetter(
     else:
         split = [attribute]
 
-    parts = [_prepare_attribute_parts(item) for item in split]
+    parts = [_prepare_attribute_parts(item, separator) for item in split]
 
     def attrgetter(item: t.Any) -> t.List[t.Any]:
         items = [None] * len(parts)
@@ -122,13 +124,13 @@ def make_multi_attrgetter(
 
 
 def _prepare_attribute_parts(
-    attr: t.Optional[t.Union[str, int]]
+    attr: t.Optional[t.Union[str, int]], separator: str = "."
 ) -> t.List[t.Union[str, int]]:
     if attr is None:
         return []
 
     if isinstance(attr, str):
-        return [int(x) if x.isdigit() else x for x in attr.split(".")]
+        return [int(x) if x.isdigit() else x for x in attr.split(separator)]
 
     return [attr]
 
@@ -1161,8 +1163,18 @@ class _GroupTuple(t.NamedTuple):
 def sync_do_groupby(
     environment: "Environment",
     value: "t.Iterable[V]",
-    attribute: t.Union[str, int],
+    attribute: t.Union[str, int, t.List[t.Union[str, int]]],
     default: t.Optional[t.Any] = None,
+    case_sensitive: bool = True,
+    reverse: bool = False,
+    separator: str = ".",
+    max_groups: t.Optional[int] = None,
+    include_empty: bool = True,
+    key_transform: t.Optional[t.Callable[[t.Any], t.Any]] = None,
+    stable: bool = False,
+    with_counts: bool = False,
+    levels: t.Optional[int] = None,
+    filter_groups: t.Optional[t.Callable[[t.List[V]], bool]] = None,
 ) -> "t.List[t.Tuple[t.Any, t.List[V]]]":
     """Group a sequence of objects by an attribute using Python's
     :func:`itertools.groupby`. The attribute can use dot notation for
@@ -1209,25 +1221,145 @@ def sync_do_groupby(
     .. versionchanged:: 2.6
         The attribute supports dot notation for nested access.
     """
-    expr = make_attrgetter(environment, attribute, default=default)
-    return [
-        _GroupTuple(key, list(values))
-        for key, values in groupby(sorted(value, key=expr), expr)
-    ]
+    # Handle multi-level grouping
+    if levels is not None and levels > 1:
+        if not isinstance(attribute, list):
+            raise FilterArgumentError(
+                "Multi-level grouping requires a list of attributes"
+            )
+        if len(attribute) < levels:
+            raise FilterArgumentError(
+                f"Not enough attributes for {levels} levels of grouping"
+            )
+
+        # First level grouping
+        first_attr = attribute[0]
+        expr = make_attrgetter(environment, first_attr, default=default, separator=separator)
+ 
+        # Filter empty values if needed
+        if include_empty:
+            filtered_value = list(value)
+        else:
+            filtered_value = [item for item in value if expr(item)]
+
+        # Apply case sensitivity if needed
+        if not case_sensitive and isinstance(first_attr, str):
+            def case_insensitive_key(item):
+                val = expr(item)
+                if isinstance(val, str):
+                    return val.lower()
+                return val
+            sort_key = case_insensitive_key
+        else:
+            sort_key = expr
+
+        first_level_groups = [
+            _GroupTuple(key, list(values))
+            for key, values in groupby(sorted(filtered_value, key=sort_key, reverse=reverse), expr)
+        ]
+
+        # Apply recursive grouping to each first-level group
+        if levels > 1:
+            for group in first_level_groups:
+                # Recursively group the items in this group
+                remaining_attrs = attribute[1:]
+                remaining_levels = levels - 1
+                group.list[:] = sync_do_groupby(
+                    environment, group.list, remaining_attrs, default, case_sensitive, reverse, separator, max_groups, include_empty, key_transform, stable, with_counts, remaining_levels, filter_groups
+                )
+
+        return first_level_groups
+
+    # Single-level grouping (original behavior)
+    if isinstance(attribute, list):
+        if len(attribute) == 1:
+            attribute = attribute[0]
+        else:
+            raise FilterArgumentError("Multiple attributes require levels parameter")
+
+    # Create postprocessor for case insensitive grouping
+    postprocess = None
+    if not case_sensitive and isinstance(attribute, str):
+        def ignore_case(val):
+            if isinstance(val, str):
+                return val.lower()
+            return val
+        postprocess = ignore_case
+
+    expr = make_attrgetter(environment, attribute, postprocess=postprocess, default=default, separator=separator)
+
+    # Handle stable grouping
+    if stable:
+        # stable=True: preserve original input order within each group and
+        # order groups by first-seen key occurrence in the input
+        groups_dict: t.Dict[t.Any, t.List[V]] = {}
+        for item in value:
+            key = expr(item)
+            # Apply include_empty filter
+            if not include_empty and not key:
+                continue
+            groups_dict.setdefault(key, []).append(item)
+
+        groups = [_GroupTuple(key_transform(key) if key_transform else key, items) for key, items in groups_dict.items()]
+    else:
+        # Filter empty values if needed
+        if include_empty:
+            filtered_value = list(value)
+        else:
+            filtered_value = [item for item in value if expr(item)]
+
+        # Create a sort key that handles None values and missing attributes properly
+        def sort_key_func(item):
+            val = expr(item)
+            # Handle Undefined values (missing attributes) by treating them as None
+            from .runtime import Undefined
+            if isinstance(val, Undefined):
+                val = None
+            # Convert None to empty string for sorting consistency
+            return (val is None, val if val is not None else "")
+
+        groups = [
+            _GroupTuple(key_transform(key) if key_transform else key, list(values))
+            for key, values in groupby(sorted(filtered_value, key=sort_key_func, reverse=reverse), expr)
+        ]
+
+    # Apply filter_groups if specified
+    if filter_groups is not None:
+        groups = [group for group in groups if filter_groups(group.list)]
+
+    # Apply max_groups limit
+    if max_groups is not None:
+        groups = groups[:max_groups]
+
+    # Handle with_counts
+    if with_counts:
+        return [(group.grouper, group.list, len(group.list)) for group in groups]
+
+    return groups
 
 
 @async_variant(sync_do_groupby)  # type: ignore
 async def do_groupby(
     environment: "Environment",
     value: "t.Union[t.AsyncIterable[V], t.Iterable[V]]",
-    attribute: t.Union[str, int],
+    attribute: t.Union[str, int, t.List[t.Union[str, int]]],
     default: t.Optional[t.Any] = None,
+    case_sensitive: bool = True,
+    reverse: bool = False,
+    separator: str = ".",
+    max_groups: t.Optional[int] = None,
+    include_empty: bool = True,
+    key_transform: t.Optional[t.Callable[[t.Any], t.Any]] = None,
+    stable: bool = False,
+    with_counts: bool = False,
+    levels: t.Optional[int] = None,
+    filter_groups: t.Optional[t.Callable[[t.List[V]], bool]] = None,
 ) -> "t.List[t.Tuple[t.Any, t.List[V]]]":
-    expr = make_attrgetter(environment, attribute, default=default)
-    return [
-        _GroupTuple(key, await auto_to_list(values))
-        for key, values in groupby(sorted(await auto_to_list(value), key=expr), expr)
-    ]
+    # Convert async iterable to list first
+    value_list = await auto_to_list(value)
+
+    # Use the sync version for the actual grouping logic
+    return sync_do_groupby(environment, value_list, attribute, default, case_sensitive, reverse, separator, max_groups, include_empty, key_transform, stable, with_counts, levels, filter_groups)
 
 
 @pass_environment

diff --git a/tests/test_async_filters.py b/tests/test_async_filters.py
index 5d4f332e..66f1ddcc 100644
--- a/tests/test_async_filters.py
+++ b/tests/test_async_filters.py
@@ -57,6 +57,26 @@ def test_groupby(env_async, items):
     ]
 
 
+@pytest.mark.parametrize(
+    ("case_sensitive", "expect"),
+    [
+        (False, "a: 1, 3\nb: 2\n"),
+        (True, "A: 3\na: 1\nb: 2\n"),
+    ],
+)
+def test_groupby_case(env_async, case_sensitive, expect):
+    tmpl = env_async.from_string(
+        "{% for k, vs in data|groupby('k', case_sensitive=cs) %}"
+        "{{ k }}: {{ vs|join(', ', attribute='v') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(
+        data=[{"k": "a", "v": 1}, {"k": "b", "v": 2}, {"k": "A", "v": 3}],
+        cs=case_sensitive,
+    )
+    assert out == expect
+
+
 @mark_dualiter("items", lambda: [("a", 1), ("a", 2), ("b", 1)])
 def test_groupby_tuple_index(env_async, items):
     tmpl = env_async.from_string(
@@ -94,6 +114,595 @@ def test_groupby_multidot(env_async, articles):
     ]
 
 
+@mark_dualiter(
+    "items",
+    lambda: [
+        {"foo": 1, "bar": 2},
+        {"foo": 2, "bar": 3},
+        {"foo": 1, "bar": 1},
+        {"foo": 3, "bar": 4},
+    ],
+)
+def test_groupby_reverse(env_async, items):
+    tmpl = env_async.from_string(
+        """
+    {%- for grouper, list in items()|groupby('foo', reverse=True) -%}
+        {{ grouper }}{% for x in list %}: {{ x.foo }}, {{ x.bar }}{% endfor %}|
+    {%- endfor %}"""
+    )
+    assert tmpl.render(items=items).split("|") == [
+        "3: 3, 4",
+        "2: 2, 3",
+        "1: 1, 2: 1, 1",
+        "",
+    ]
+
+
+@mark_dualiter(
+    "data",
+    lambda: [
+        {"name": "alice", "score": 95},
+        {"name": "bob", "score": 87},
+        {"name": "charlie", "score": 95},
+        {"name": "david", "score": 72},
+    ],
+)
+def test_groupby_reverse_numeric(env_async, data):
+    tmpl = env_async.from_string(
+        "{% for score, items in data()|groupby('score', reverse=True) %}"
+        "{{ score }}: {{ items|map(attribute='name')|join(', ') }}|"
+        "{% endfor %}"
+    )
+    out = tmpl.render(data=data)
+    assert out == "95: alice, charlie|87: bob|72: david|"
+
+
+def test_groupby_separator(env_async):
+    # Test with double underscore separator (Django-style)
+    tmpl = env_async.from_string(
+        "{% for city, items in users|groupby('profile__city', separator='__') %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(
+        users=[
+            {"name": "alice", "profile": {"city": "NYC"}},
+            {"name": "bob", "profile": {"city": "LA"}},
+            {"name": "charlie", "profile": {"city": "NYC"}},
+        ]
+    )
+    assert out == "LA: bob\nNYC: alice, charlie\n"
+
+
+def test_groupby_separator_with_default(env_async):
+    # Test separator with default value
+    tmpl = env_async.from_string(
+        "{% for city, items in users|groupby('profile__city', default='Unknown', separator='__') %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(
+        users=[
+            {"name": "alice", "profile": {"city": "NYC"}},
+            {"name": "bob"},  # Missing profile
+            {"name": "charlie", "profile": {}},  # Missing city
+        ]
+    )
+    assert out == "NYC: alice\nUnknown: bob, charlie\n"
+
+
+def make_users_for_max_groups():
+    return [
+        {"name": "alice", "city": "NY"},
+        {"name": "bob", "city": "LA"},
+        {"name": "charlie", "city": "SF"},
+        {"name": "david", "city": "NY"},
+        {"name": "eve", "city": "LA"},
+    ]
+
+
+@mark_dualiter("users", make_users_for_max_groups)
+def test_groupby_max_groups(env_async, users):
+    """Test max_groups parameter limits the number of groups returned."""
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', max_groups=2) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users)
+    # Should only return first 2 groups (LA and NY, alphabetically sorted)
+    assert out == "LA: bob, eve\nNY: alice, david\n"
+
+
+@mark_dualiter(
+    "users", lambda: [{"name": "alice", "city": "NY"}, {"name": "bob", "city": "LA"}]
+)
+def test_groupby_max_groups_zero(env_async, users):
+    """Test max_groups=0 returns empty result."""
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', max_groups=0) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users)
+    assert out == ""
+
+
+@mark_dualiter(
+    "users", lambda: [{"name": "alice", "city": "NY"}, {"name": "bob", "city": "LA"}]
+)
+def test_groupby_max_groups_larger_than_available(env_async, users):
+    """Test max_groups larger than available groups returns all groups."""
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', max_groups=10) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users)
+    assert out == "LA: bob\nNY: alice\n"
+
+
+@mark_dualiter("users", lambda: [])
+def test_groupby_max_groups_empty_input(env_async, users):
+    """Test max_groups with empty input."""
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', max_groups=2) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users)
+    assert out == ""
+
+
+def test_groupby_max_groups_none(env_async):
+    """Test max_groups=None returns all groups (default behavior)."""
+    tmpl = env_async.from_string(
+        "{% for city, items in users|groupby('city', max_groups=none) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(
+        users=[
+            {"name": "alice", "city": "NY"},
+            {"name": "bob", "city": "LA"},
+            {"name": "charlie", "city": "SF"},
+        ]
+    )
+    assert out == "LA: bob\nNY: alice\nSF: charlie\n"
+
+
+@mark_dualiter("users", make_users_for_max_groups)
+def test_groupby_max_groups_single_group(env_async, users):
+    """Test max_groups=1 returns only first group."""
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', max_groups=1) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users)
+    # Should return only LA (first alphabetically) with both users in that group
+    assert out == "LA: bob, eve\n"
+
+
+@mark_dualiter("data", lambda: [("a", 1), ("b", 2), ("a", 3), ("c", 4), ("b", 5)])
+def test_groupby_max_groups_with_tuple_index(env_async, data):
+    """Test max_groups works with tuple indexing."""
+    tmpl = env_async.from_string(
+        "{% for grouper, items in data()|groupby(0, max_groups=2) %}"
+        "{{ grouper }}: {{ items|map(attribute='1')|join(',') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(data=data)
+    # Should return first 2 groups: a, b
+    assert out == "a: 1,3\nb: 2,5\n"
+
+
+@mark_dualiter(
+    "users",
+    lambda: [
+        {"name": "alice", "status": "active"},
+        {"name": "bob", "status": ""},
+        {"name": "charlie", "status": "active"},
+        {"name": "dave", "status": None},
+        {"name": "eve"},
+    ],
+)
+def test_groupby_include_empty_true(env_async, users):
+    """Test async groupby with include_empty=True (default behavior)"""
+    tmpl = env_async.from_string(
+        "{% for status, items in users()|groupby('status', include_empty=true) %}"
+        "{{ status }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users)
+    # Should include empty string, None, and missing attribute groups
+    assert "active: alice, charlie\n" in out
+    assert ": bob\n" in out  # empty string group
+    assert "None: dave\n" in out  # None group
+    assert "None: eve\n" in out or ": eve\n" in out  # missing attribute
+
+
+@mark_dualiter(
+    "users",
+    lambda: [
+        {"name": "alice", "status": "active"},
+        {"name": "bob", "status": ""},
+        {"name": "charlie", "status": "active"},
+        {"name": "dave", "status": None},
+        {"name": "eve", "status": 0},
+        {"name": "frank"},
+    ],
+)
+def test_groupby_include_empty_false(env_async, users):
+    """Test async groupby with include_empty=False excludes falsy values"""
+    tmpl = env_async.from_string(
+        "{% for status, items in users()|groupby('status', include_empty=false) %}"
+        "{{ status }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users)
+    # Should only include non-falsy values
+    assert out == "active: alice, charlie\n"
+
+
+@mark_dualiter(
+    "users",
+    lambda: [
+        {"name": "alice", "status": "active"},
+        {"name": "bob", "status": ""},
+        {"name": "charlie", "status": "active"},
+        {"name": "dave", "status": None},
+        {"name": "eve"},
+    ],
+)
+def test_groupby_include_empty_with_default(env_async, users):
+    """Test async groupby with include_empty=False and default value"""
+    tmpl = env_async.from_string(
+        "{% for status, items in users()|groupby('status', default='unknown', include_empty=false) %}"
+        "{{ status }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users)
+    # Should include default value but exclude empty/None
+    assert "active: alice, charlie\n" in out
+    assert "unknown: eve\n" in out
+    # Should not include empty string or None groups
+    assert ": bob" not in out
+    assert "None: dave" not in out
+
+
+@mark_dualiter(
+    "data",
+    lambda: [
+        {"value": "truthy"},
+        {"value": ""},
+        {"value": None},
+        {"value": 0},
+        {"value": []},
+        {"value": {}},
+        {"value": False},
+        {"value": "another"},
+    ],
+)
+def test_groupby_include_empty_edge_cases(env_async, data):
+    """Test async groupby include_empty with various falsy values"""
+    tmpl = env_async.from_string(
+        "{% for val, items in data()|groupby('value', include_empty=false) %}"
+        "{{ val }}: {{ items|length }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(data=data)
+    # Should only include truthy values
+    assert "truthy: 1\n" in out
+    assert "another: 1\n" in out
+    # Should not include any falsy values
+    assert ": 1" not in out.replace("truthy: 1", "").replace("another: 1", "")
+    assert "None:" not in out
+    assert "0:" not in out
+    assert "[]:" not in out
+    assert "{}:" not in out
+    assert "False:" not in out
+
+
+@mark_dualiter(
+    "users",
+    lambda: [
+        {"name": "alice", "status": "active"},
+        {"name": "bob", "status": ""},
+        {"name": "charlie", "status": None},
+    ],
+)
+def test_groupby_include_empty_backward_compatibility(env_async, users):
+    """Test async groupby backward compatibility with include_empty parameter"""
+    # Test without include_empty parameter (should default to True)
+    tmpl1 = env_async.from_string(
+        "{% for status, items in users()|groupby('status') %}"
+        "{{ status }}: {{ items|length }}\n"
+        "{% endfor %}"
+    )
+    # Test with explicit include_empty=True
+    tmpl2 = env_async.from_string(
+        "{% for status, items in users()|groupby('status', include_empty=true) %}"
+        "{{ status }}: {{ items|length }}\n"
+        "{% endfor %}"
+    )
+
+    out1 = tmpl1.render(users=users)
+    out2 = tmpl2.render(users=users)
+
+    # Both should produce identical output
+    assert out1 == out2
+    assert "active: 1\n" in out1
+    assert ": 1\n" in out1  # empty string
+    assert "None: 1\n" in out1  # None value
+
+
+def test_groupby_key_transform(env_async):
+    # Test basic key transformation for async groupby
+    items = [{"foo": 1, "bar": 2}, {"foo": 2, "bar": 3}, {"foo": 1, "bar": 1}]
+
+    tmpl = env_async.from_string(
+        """
+    {%- for grouper, list in items|groupby('foo', key_transform=upper_func) -%}
+        {{ grouper }}{% for x in list %}: {{ x.foo }}, {{ x.bar }}{% endfor %}|
+    {%- endfor %}"""
+    )
+
+    def upper_func(x):
+        return str(x).upper()
+
+    result = tmpl.render(items=items, upper_func=upper_func)
+    assert result.split("|") == ["1: 1, 2: 1, 1", "2: 2, 3", ""]
+
+
+@mark_dualiter(
+    "data",
+    lambda: [
+        {"type": "A", "value": 3},
+        {"type": "B", "value": 1},
+        {"type": "A", "value": 1},
+        {"type": "B", "value": 2},
+        {"type": "A", "value": 2},
+    ],
+)
+def test_groupby_stable_basic(env_async, data):
+    """Test basic stable groupby functionality preserves order within groups."""
+    tmpl = env_async.from_string(
+        "{% for key, items in data()|groupby('type', stable=True) %}"
+        "{{ key }}: {{ items|map(attribute='value')|join(',') }}|"
+        "{% endfor %}"
+    )
+    out = tmpl.render(data=data)
+    assert out == "A: 3,1,2|B: 1,2|"
+
+
+@mark_dualiter(
+    "data",
+    lambda: [
+        {"type": "B", "value": 3},
+        {"type": "A", "value": 2},
+        {"type": "B", "value": 1},
+        {"type": "A", "value": 3},
+        {"type": "A", "value": 1},
+    ],
+)
+def test_groupby_stable_vs_default(env_async, data):
+    """Test that stable=True preserves order while default behavior sorts by key."""
+    # Default behavior (sorts by grouping key first)
+    tmpl_default = env_async.from_string(
+        "{% for key, items in data()|groupby('type') %}"
+        "{{ key }}: {{ items|map(attribute='value')|join(',') }}|"
+        "{% endfor %}"
+    )
+
+    # Stable behavior (preserves original order)
+    tmpl_stable = env_async.from_string(
+        "{% for key, items in data()|groupby('type', stable=True) %}"
+        "{{ key }}: {{ items|map(attribute='value')|join(',') }}|"
+        "{% endfor %}"
+    )
+
+    default_out = tmpl_default.render(data=data)
+    stable_out = tmpl_stable.render(data=data)
+
+    assert default_out == "A: 2,3,1|B: 3,1|"  # sorted by key, groups A then B
+    assert stable_out == "B: 3,1|A: 2,3,1|"  # original order, groups B then A
+
+
+def test_groupby_stable_empty(env_async):
+    """Test stable groupby with empty input."""
+    tmpl = env_async.from_string(
+        "{% for key, items in data|groupby('type', stable=True) %}"
+        "{{ key }}: {{ items|length }}|"
+        "{% endfor %}"
+    )
+    out = tmpl.render(data=[])
+    assert out == ""
+
+
+@mark_dualiter(
+    "data",
+    lambda: [
+        {"type": "A", "value": 1},
+        {"value": 2},  # missing 'type' key
+        {"type": "A", "value": 3},
+    ],
+)
+def test_groupby_stable_with_default(env_async, data):
+    """Test stable groupby with default parameter."""
+    tmpl = env_async.from_string(
+        "{% for key, items in data()|groupby('type', default='X', stable=True) %}"
+        "{{ key }}: {{ items|map(attribute='value')|join(',') }}|"
+        "{% endfor %}"
+    )
+    out = tmpl.render(data=data)
+    assert out == "A: 1,3|X: 2|"
+
+
+@mark_dualiter(
+    "users",
+    lambda: [
+        {"name": "emma", "city": "NY"},
+        {"name": "john", "city": "NY"},
+        {"name": "smith", "city": "WA"},
+    ],
+)
+def test_groupby_with_counts(env_async, users):
+    tmpl = env_async.from_string(
+        "{% for city, items, count in users()|groupby('city', with_counts=true) %}"
+        "{{ city }}: {{ count }} users - {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    assert tmpl.render(users=users) == "NY: 2 users - emma, john\nWA: 1 users - smith\n"
+
+
+def test_groupby_with_counts_empty(env_async):
+    tmpl = env_async.from_string(
+        "{% for key, items, count in data|groupby('type', with_counts=true) %}"
+        "{{ key }}: {{ count }}\n"
+        "{% endfor %}"
+    )
+    assert tmpl.render(data=[]) == ""
+
+
+@mark_dualiter(
+    "data",
+    lambda: [
+        {"category": "books", "title": "Book1"},
+        {"category": "books", "title": "Book2"},
+        {"category": "movies", "title": "Movie1"},
+        {"category": "games", "title": "Game1"},
+        {"category": "games", "title": "Game2"},
+        {"category": "games", "title": "Game3"},
+    ],
+)
+def test_groupby_with_counts_multiple_groups(env_async, data):
+    tmpl = env_async.from_string(
+        "{% for key, items, count in data()|groupby('category', with_counts=true) %}"
+        "{{ key }}: {{ count }}\n"
+        "{% endfor %}"
+    )
+    assert tmpl.render(data=data) == "books: 2\ngames: 3\nmovies: 1\n"
+
+
+@mark_dualiter(
+    "data",
+    lambda: [
+        {"category": "books", "title": "Book1"},
+        {"title": "Unknown1"},
+        {"title": "Unknown2"},
+    ],
+)
+def test_groupby_with_counts_and_default(env_async, data):
+    tmpl = env_async.from_string(
+        "{% for key, items, count in data()|groupby('category', default='misc', with_counts=true) %}"
+        "{{ key }}: {{ count }}\n"
+        "{% endfor %}"
+    )
+    assert tmpl.render(data=data) == "books: 1\nmisc: 2\n"
+
+
+def make_multilevel_users():
+    return [
+        {"name": "alice", "department": "eng", "role": "dev"},
+        {"name": "bob", "department": "eng", "role": "dev"},
+        {"name": "charlie", "department": "eng", "role": "manager"},
+        {"name": "diana", "department": "sales", "role": "rep"},
+        {"name": "eve", "department": "sales", "role": "manager"},
+    ]
+
+
+@mark_dualiter("users", make_multilevel_users)
+def test_groupby_multilevel_basic(env_async, users):
+    """Test basic multi-level grouping with 2 levels in async mode."""
+    tmpl = env_async.from_string(
+        "{% for dept_group in users()|groupby(['department', 'role'], levels=2) %}"
+        "{{ dept_group.grouper }}:\n"
+        "{% for role_group in dept_group.list %}"
+        "  {{ role_group.grouper }}: {{ role_group.list|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users)
+    expected = (
+        "eng:\n"
+        "  dev: alice, bob\n"
+        "  manager: charlie\n"
+        "sales:\n"
+        "  manager: eve\n"
+        "  rep: diana\n"
+    )
+    assert out == expected
+
+
+def make_three_level_data():
+    return [
+        {"a": "x", "b": "1", "c": "i", "value": "A"},
+        {"a": "x", "b": "1", "c": "ii", "value": "B"},
+        {"a": "x", "b": "2", "c": "i", "value": "C"},
+        {"a": "y", "b": "1", "c": "i", "value": "D"},
+    ]
+
+
+@mark_dualiter("data", make_three_level_data)
+def test_groupby_multilevel_three_levels(env_async, data):
+    """Test multi-level grouping with 3 levels in async mode."""
+    tmpl = env_async.from_string(
+        "{% for l1 in data()|groupby(['a', 'b', 'c'], levels=3) %}"
+        "{{ l1.grouper }}:\n"
+        "{% for l2 in l1.list %}"
+        "  {{ l2.grouper }}:\n"
+        "{% for l3 in l2.list %}"
+        "    {{ l3.grouper }}: {{ l3.list|map(attribute='value')|join(',') }}\n"
+        "{% endfor %}"
+        "{% endfor %}"
+        "{% endfor %}"
+    )
+    out = tmpl.render(data=data)
+    expected = (
+        "x:\n"
+        "  1:\n"
+        "    i: A\n"
+        "    ii: B\n"
+        "  2:\n"
+        "    i: C\n"
+        "y:\n"
+        "  1:\n"
+        "    i: D\n"
+    )
+    assert out == expected
+
+
+def test_groupby_multilevel_empty_data(env_async):
+    """Test multi-level grouping with empty data in async mode."""
+    tmpl = env_async.from_string(
+        "{% for group in []|groupby(['a', 'b'], levels=2) %}"
+        "{{ group.grouper }}\n"
+        "{% else %}"
+        "No data\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render()
+    assert out == "No data\n"
+
+
+def test_groupby_multilevel_backward_compatibility(env_async):
+    """Test that single-level groupby still works in async mode."""
+    tmpl = env_async.from_string(
+        "{% for group in data|groupby('category') %}"
+        "{{ group.grouper }}: {{ group.list|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    data = [
+        {"name": "apple", "category": "fruit"},
+        {"name": "banana", "category": "fruit"},
+        {"name": "carrot", "category": "vegetable"},
+    ]
+    out = tmpl.render(data=data)
+    expected = "fruit: apple, banana\nvegetable: carrot\n"
+    assert out == expected
+
+
 @mark_dualiter("int_items", lambda: [1, 2, 3])
 def test_join_env_int(env_async, int_items):
     tmpl = env_async.from_string('{{ items()|join("|") }}')
@@ -251,3 +860,214 @@ def test_custom_async_iteratable_filter(env_async, items):
     )
     out = tmpl.render(items=items)
     assert out == "0,1,2 .. 3,4,5"
+
+
+def make_users_for_filter():
+    return [
+        {"name": "alice", "city": "NY"},
+        {"name": "bob", "city": "NY"},
+        {"name": "charlie", "city": "LA"},
+        {"name": "david", "city": "SF"},
+        {"name": "eve", "city": "SF"},
+    ]
+
+
+@mark_dualiter("users", make_users_for_filter)
+def test_groupby_filter_groups_duplicates(env_async, users):
+    """Test filter_groups to find duplicates (groups with more than 1 item)."""
+
+    def filter_duplicates(group):
+        return len(group) > 1
+
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', filter_groups=filter_func) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users, filter_func=filter_duplicates)
+    assert out == "NY: alice, bob\nSF: david, eve\n"
+
+
+@mark_dualiter("users", make_users_for_filter)
+def test_groupby_filter_groups_unique(env_async, users):
+    """Test filter_groups to find unique items (groups with exactly 1 item)."""
+
+    def filter_unique(group):
+        return len(group) == 1
+
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', filter_groups=filter_func) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users, filter_func=filter_unique)
+    assert out == "LA: charlie\n"
+
+
+def make_users_for_empty_filter():
+    return [
+        {"name": "alice", "city": "NY"},
+        {"name": "bob", "city": "LA"},
+    ]
+
+
+@mark_dualiter("users", make_users_for_empty_filter)
+def test_groupby_filter_groups_empty_result(env_async, users):
+    """Test filter_groups that filters out all groups."""
+
+    def filter_large_groups(group):
+        return len(group) > 10
+
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', filter_groups=filter_func) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users, filter_func=filter_large_groups)
+    assert out == ""
+
+
+@mark_dualiter("users", make_users_for_empty_filter)
+def test_groupby_filter_groups_all_pass(env_async, users):
+    """Test filter_groups that allows all groups to pass."""
+
+    def filter_all_pass(group):
+        return True
+
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', filter_groups=filter_func) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users, filter_func=filter_all_pass)
+    assert out == "LA: bob\nNY: alice\n"
+
+
+def make_users_with_missing_city():
+    return [
+        {"name": "alice", "city": "NY"},
+        {"name": "bob", "city": "NY"},
+        {"name": "charlie"},
+        {"name": "david"},
+    ]
+
+
+@mark_dualiter("users", make_users_with_missing_city)
+def test_groupby_filter_groups_with_default(env_async, users):
+    """Test filter_groups combined with default parameter."""
+
+    def filter_duplicates(group):
+        return len(group) > 1
+
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', default='Unknown', filter_groups=filter_func) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users, filter_func=filter_duplicates)
+    assert out == "NY: alice, bob\nUnknown: charlie, david\n"
+
+
+@mark_dualiter("users", make_users_for_empty_filter)
+def test_groupby_filter_groups_none(env_async, users):
+    """Test that filter_groups=None behaves like normal groupby."""
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', filter_groups=none) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users)
+    assert out == "LA: bob\nNY: alice\n"
+
+
+@mark_dualiter("users", make_users_for_filter)
+def test_groupby_filter_groups_lambda_duplicates(env_async, users):
+    """Test filter_groups with lambda function for duplicates in async environment."""
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', filter_groups=lambda_func) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users, lambda_func=lambda group: len(group) > 1)
+    assert out == "NY: alice, bob\nSF: david, eve\n"
+
+
+@mark_dualiter("users", make_users_for_filter)
+def test_groupby_filter_groups_lambda_unique(env_async, users):
+    """Test filter_groups with lambda function for unique items in async environment."""
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', filter_groups=lambda_func) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users, lambda_func=lambda group: len(group) == 1)
+    assert out == "LA: charlie\n"
+
+
+def make_students_for_complex_filter():
+    return [
+        {"name": "alice", "score": 95},
+        {"name": "bob", "score": 95},
+        {"name": "charlie", "score": 75},
+        {"name": "david", "score": 75},
+        {"name": "eve", "score": 85},
+        {"name": "frank", "score": 85},
+        {"name": "grace", "score": 85},
+    ]
+
+
+@mark_dualiter("students", make_students_for_complex_filter)
+def test_groupby_filter_groups_lambda_complex(env_async, students):
+    """Test filter_groups with complex lambda condition in async environment."""
+    tmpl = env_async.from_string(
+        "{% for score, items in students()|groupby('score', filter_groups=lambda_func) %}"
+        "Score {{ score }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(
+        students=students,
+        lambda_func=lambda group: len(group) >= 2 and group[0]["score"] >= 80,
+    )
+    assert out == "Score 85: eve, frank, grace\nScore 95: alice, bob\n"
+
+
+@mark_dualiter("users", make_users_for_filter)
+def test_groupby_filter_groups_lambda_from_globals(env_async, users):
+    """Test filter_groups with lambda function from environment globals in async environment."""
+    env_async.globals['only_dupes'] = lambda g: len(g) > 1
+    env_async.globals['only_singles'] = lambda g: len(g) == 1
+ 
+    # Test duplicates from globals
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', filter_groups=only_dupes) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users)
+    assert out == "NY: alice, bob\nSF: david, eve\n"
+ 
+    # Test singles from globals
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', filter_groups=only_singles) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users)
+    assert out == "LA: charlie\n"
+
+
+@mark_dualiter("users", make_users_for_empty_filter)
+def test_groupby_filter_groups_lambda_edge_cases(env_async, users):
+    """Test filter_groups lambda edge cases in async environment (filter all, allow all)."""
+    # Lambda that filters everything
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', filter_groups=lambda_func) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users, lambda_func=lambda group: False)
+    assert out == ""
+ 
+    # Lambda that allows everything
+    out = tmpl.render(users=users, lambda_func=lambda group: True)
+    assert out == "LA: bob\nNY: alice\n"
diff --git a/tests/test_filters.py b/tests/test_filters.py
index 43ddf59c..bb28590d 100644
--- a/tests/test_filters.py
+++ b/tests/test_filters.py
@@ -619,6 +619,1046 @@ class TestFilter:
         )
         assert out == "NY: emma, john\nWA: smith\n"
 
+    @pytest.mark.parametrize(
+        ("case_sensitive", "expect"),
+        [
+            (False, "a: 1, 3\nb: 2\n"),
+            (True, "A: 3\na: 1\nb: 2\n"),
+        ],
+    )
+    def test_groupby_case(self, env, case_sensitive, expect):
+        tmpl = env.from_string(
+            "{% for k, vs in data|groupby('k', case_sensitive=cs) %}"
+            "{{ k }}: {{ vs|join(', ', attribute='v') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            data=[{"k": "a", "v": 1}, {"k": "b", "v": 2}, {"k": "A", "v": 3}],
+            cs=case_sensitive,
+        )
+        assert out == expect
+
+    def test_groupby_reverse(self, env):
+        tmpl = env.from_string(
+            """
+        {%- for grouper, list in [{'foo': 1, 'bar': 2},
+                                  {'foo': 2, 'bar': 3},
+                                  {'foo': 1, 'bar': 1},
+                                  {'foo': 3, 'bar': 4}]|groupby('foo', reverse=True) -%}
+            {{ grouper }}{% for x in list %}: {{ x.foo }}, {{ x.bar }}{% endfor %}|
+        {%- endfor %}"""
+        )
+        assert tmpl.render().split("|") == ["3: 3, 4", "2: 2, 3", "1: 1, 2: 1, 1", ""]
+
+    def test_groupby_reverse_with_default(self, env):
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', default='NY', reverse=True) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "emma", "city": "NY"},
+                {"name": "smith", "city": "WA"},
+                {"name": "john"},
+            ]
+        )
+        assert out == "WA: smith\nNY: emma, john\n"
+
+    def test_groupby_reverse_numeric(self, env):
+        tmpl = env.from_string(
+            "{% for score, items in data|groupby('score', reverse=True) %}"
+            "{{ score }}: {{ items|map(attribute='name')|join(', ') }}|"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            data=[
+                {"name": "alice", "score": 95},
+                {"name": "bob", "score": 87},
+                {"name": "charlie", "score": 95},
+                {"name": "david", "score": 72},
+            ]
+        )
+        assert out == "95: alice, charlie|87: bob|72: david|"
+
+    def test_groupby_reverse_false(self, env):
+        # Test that reverse=False works the same as default behavior
+        tmpl = env.from_string(
+            """
+        {%- for grouper, list in [{'foo': 1, 'bar': 2},
+                                  {'foo': 2, 'bar': 3},
+                                  {'foo': 1, 'bar': 1},
+                                  {'foo': 3, 'bar': 4}]|groupby('foo', reverse=False) -%}
+            {{ grouper }}{% for x in list %}: {{ x.foo }}, {{ x.bar }}{% endfor %}|
+        {%- endfor %}"""
+        )
+        assert tmpl.render().split("|") == ["1: 1, 2: 1, 1", "2: 2, 3", "3: 3, 4", ""]
+
+    def test_groupby_separator(self, env):
+        # Test with double underscore separator (Django-style)
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('profile__city', separator='__') %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "profile": {"city": "NYC"}},
+                {"name": "bob", "profile": {"city": "LA"}},
+                {"name": "charlie", "profile": {"city": "NYC"}},
+            ]
+        )
+        assert out == "LA: bob\nNYC: alice, charlie\n"
+
+    def test_groupby_separator_with_default(self, env):
+        # Test separator with default value
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('profile__city', default='Unknown', separator='__') %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "profile": {"city": "NYC"}},
+                {"name": "bob"},  # Missing profile
+                {"name": "charlie", "profile": {}},  # Missing city
+            ]
+        )
+        assert out == "NYC: alice\nUnknown: bob, charlie\n"
+
+    def test_groupby_custom_separator(self, env):
+        # Test with custom separator
+        tmpl = env.from_string(
+            "{% for value, items in data|groupby('a->b->c', separator='->') %}"
+            "{{ value }}: {{ items|length }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            data=[
+                {"a": {"b": {"c": "x"}}},
+                {"a": {"b": {"c": "y"}}},
+                {"a": {"b": {"c": "x"}}},
+            ]
+        )
+        assert out == "x: 2\ny: 1\n"
+
+    def test_groupby_max_groups(self, env):
+        """Test max_groups parameter limits the number of groups returned."""
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', max_groups=2) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "LA"},
+                {"name": "charlie", "city": "SF"},
+                {"name": "david", "city": "NY"},
+                {"name": "eve", "city": "LA"},
+            ]
+        )
+        # Should only return first 2 groups (LA and NY, alphabetically sorted)
+        assert out == "LA: bob, eve\nNY: alice, david\n"
+
+    def test_groupby_max_groups_zero(self, env):
+        """Test max_groups=0 returns empty result."""
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', max_groups=0) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "LA"},
+            ]
+        )
+        assert out == ""
+
+    def test_groupby_max_groups_larger_than_available(self, env):
+        """Test max_groups larger than available groups returns all groups."""
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', max_groups=10) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "LA"},
+            ]
+        )
+        assert out == "LA: bob\nNY: alice\n"
+
+    def test_groupby_max_groups_with_default(self, env):
+        """Test max_groups works with default parameter."""
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', default='Unknown', max_groups=2) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "LA"},
+                {"name": "charlie"},  # No city, will use default
+                {"name": "david", "city": "SF"},
+            ]
+        )
+        # Should return first 2 groups alphabetically: LA, NY
+        assert out == "LA: bob\nNY: alice\n"
+
+    def test_groupby_max_groups_empty_input(self, env):
+        """Test max_groups with empty input."""
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', max_groups=2) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(users=[])
+        assert out == ""
+
+    def test_groupby_max_groups_none(self, env):
+        """Test max_groups=None returns all groups (default behavior)."""
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', max_groups=none) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "LA"},
+                {"name": "charlie", "city": "SF"},
+            ]
+        )
+        assert out == "LA: bob\nNY: alice\nSF: charlie\n"
+
+    def test_groupby_max_groups_single_group(self, env):
+        """Test max_groups=1 returns only first group."""
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', max_groups=1) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "LA"},
+                {"name": "charlie", "city": "SF"},
+                {"name": "david", "city": "NY"},
+            ]
+        )
+        # Should return only LA (first alphabetically) with bob in that group
+        assert out == "LA: bob\n"
+
+    def test_groupby_max_groups_with_tuple_index(self, env):
+        """Test max_groups works with tuple indexing."""
+        tmpl = env.from_string(
+            "{% for grouper, items in data|groupby(0, max_groups=2) %}"
+            "{{ grouper }}: {{ items|map(attribute='1')|join(',') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            data=[
+                ("a", 1),
+                ("b", 2),
+                ("a", 3),
+                ("c", 4),
+                ("b", 5),
+            ]
+        )
+        # Should return first 2 groups: a, b
+        assert out == "a: 1,3\nb: 2,5\n"
+
+    def test_groupby_include_empty_true(self, env):
+        """Test groupby with include_empty=True (default behavior)"""
+        tmpl = env.from_string(
+            "{% for status, items in users|groupby('status', include_empty=true) %}"
+            "{{ status }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "status": "active"},
+                {"name": "bob", "status": ""},
+                {"name": "charlie", "status": "active"},
+                {"name": "dave", "status": None},
+                {"name": "eve"},
+            ]
+        )
+        # Should include empty string, None, and missing attribute groups
+        assert "active: alice, charlie\n" in out
+        assert ": bob\n" in out  # empty string group
+        assert "None: dave\n" in out  # None group
+        assert "None: eve\n" in out or ": eve\n" in out  # missing attribute
+
+    def test_groupby_include_empty_false(self, env):
+        """Test groupby with include_empty=False excludes falsy values"""
+        tmpl = env.from_string(
+            "{% for status, items in users|groupby('status', include_empty=false) %}"
+            "{{ status }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "status": "active"},
+                {"name": "bob", "status": ""},
+                {"name": "charlie", "status": "active"},
+                {"name": "dave", "status": None},
+                {"name": "eve", "status": 0},
+                {"name": "frank"},
+            ]
+        )
+        # Should only include non-falsy values
+        assert out == "active: alice, charlie\n"
+
+    def test_groupby_include_empty_with_default(self, env):
+        """Test groupby with include_empty=False and default value"""
+        tmpl = env.from_string(
+            "{% for status, items in users|groupby('status', default='unknown', include_empty=false) %}"
+            "{{ status }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "status": "active"},
+                {"name": "bob", "status": ""},
+                {"name": "charlie", "status": "active"},
+                {"name": "dave", "status": None},
+                {"name": "eve"},
+            ]
+        )
+        # Should include default value but exclude empty/None
+        assert "active: alice, charlie\n" in out
+        assert "unknown: eve\n" in out
+        # Should not include empty string or None groups
+        assert ": bob" not in out
+        assert "None: dave" not in out
+
+    def test_groupby_include_empty_edge_cases(self, env):
+        """Test groupby include_empty with various falsy values"""
+        tmpl = env.from_string(
+            "{% for val, items in data|groupby('value', include_empty=false) %}"
+            "{{ val }}: {{ items|length }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            data=[
+                {"value": "truthy"},
+                {"value": ""},
+                {"value": None},
+                {"value": 0},
+                {"value": []},
+                {"value": {}},
+                {"value": False},
+                {"value": "another"},
+            ]
+        )
+        # Should only include truthy values
+        assert "truthy: 1\n" in out
+        assert "another: 1\n" in out
+        # Should not include any falsy values
+        assert ": 1" not in out.replace("truthy: 1", "").replace("another: 1", "")
+        assert "None:" not in out
+        assert "0:" not in out
+        assert "[]:" not in out
+        assert "{}:" not in out
+        assert "False:" not in out
+
+    def test_groupby_include_empty_backward_compatibility(self, env):
+        """Test that default behavior (include_empty=True) maintains backward compatibility"""
+        # Test without include_empty parameter (should default to True)
+        tmpl1 = env.from_string(
+            "{% for status, items in users|groupby('status') %}"
+            "{{ status }}: {{ items|length }}\n"
+            "{% endfor %}"
+        )
+        # Test with explicit include_empty=True
+        tmpl2 = env.from_string(
+            "{% for status, items in users|groupby('status', include_empty=true) %}"
+            "{{ status }}: {{ items|length }}\n"
+            "{% endfor %}"
+        )
+
+        users = [
+            {"name": "alice", "status": "active"},
+            {"name": "bob", "status": ""},
+            {"name": "charlie", "status": None},
+        ]
+
+        out1 = tmpl1.render(users=users)
+        out2 = tmpl2.render(users=users)
+
+        # Both should produce identical output
+        assert out1 == out2
+        assert "active: 1\n" in out1
+        assert ": 1\n" in out1  # empty string
+        assert "None: 1\n" in out1  # None value
+
+    def test_groupby_key_transform(self, env):
+        # Test basic key transformation
+        tmpl = env.from_string(
+            """
+        {%- for grouper, list in [{'foo': 1, 'bar': 2},
+                                  {'foo': 2, 'bar': 3},
+                                  {'foo': 1, 'bar': 1}]|groupby('foo', key_transform=upper_func) -%}
+            {{ grouper }}{% for x in list %}: {{ x.foo }}, {{ x.bar }}{% endfor %}|
+        {%- endfor %}"""
+        )
+
+        def upper_func(x):
+            return str(x).upper()
+
+        result = tmpl.render(upper_func=upper_func)
+        assert result.split("|") == ["1: 1, 2: 1, 1", "2: 2, 3", ""]
+
+    def test_groupby_key_transform_date(self, env):
+        # Test date formatting transformation
+        from datetime import date
+
+        events = [
+            {"name": "event1", "date": date(2024, 1, 1)},
+            {"name": "event2", "date": date(2024, 1, 1)},
+            {"name": "event3", "date": date(2024, 2, 1)},
+        ]
+
+        tmpl = env.from_string(
+            """
+        {%- for month, list in events|groupby('date', key_transform=format_month) -%}
+            {{ month }}: {{ list|length }} events|
+        {%- endfor %}"""
+        )
+
+        def format_month(dt):
+            return dt.strftime("%Y-%m")
+
+        result = tmpl.render(events=events, format_month=format_month)
+        assert result.split("|") == ["2024-01: 2 events", "2024-02: 1 events", ""]
+
+    def test_groupby_key_transform_none(self, env):
+        # Test that None key_transform works like normal groupby
+        tmpl = env.from_string(
+            """
+        {%- for grouper, list in [{'foo': 1}, {'foo': 2}, {'foo': 1}]|groupby('foo', key_transform=none) -%}
+            {{ grouper }}:{{ list|length }}|
+        {%- endfor %}"""
+        )
+        result = tmpl.render()
+        assert result.split("|") == ["1:2", "2:1", ""]
+
+    def test_groupby_stable_basic(self, env):
+        """Test basic stable groupby functionality preserves order within groups."""
+        tmpl = env.from_string(
+            "{% for key, items in data|groupby('type', stable=True) %}"
+            "{{ key }}: {{ items|map(attribute='value')|join(',') }}|"
+            "{% endfor %}"
+        )
+        data = [
+            {"type": "A", "value": 3},
+            {"type": "B", "value": 1},
+            {"type": "A", "value": 1},
+            {"type": "B", "value": 2},
+            {"type": "A", "value": 2},
+        ]
+        out = tmpl.render(data=data)
+        assert out == "A: 3,1,2|B: 1,2|"
+
+    def test_groupby_stable_vs_default(self, env):
+        """Test that stable=True preserves order while default behavior sorts by key."""
+        data = [
+            {"type": "B", "value": 3},
+            {"type": "A", "value": 2},
+            {"type": "B", "value": 1},
+            {"type": "A", "value": 3},
+            {"type": "A", "value": 1},
+        ]
+
+        # Default behavior (sorts by grouping key first)
+        tmpl_default = env.from_string(
+            "{% for key, items in data|groupby('type') %}"
+            "{{ key }}: {{ items|map(attribute='value')|join(',') }}|"
+            "{% endfor %}"
+        )
+
+        # Stable behavior (preserves original order)
+        tmpl_stable = env.from_string(
+            "{% for key, items in data|groupby('type', stable=True) %}"
+            "{{ key }}: {{ items|map(attribute='value')|join(',') }}|"
+            "{% endfor %}"
+        )
+
+        default_out = tmpl_default.render(data=data)
+        stable_out = tmpl_stable.render(data=data)
+
+        assert default_out == "A: 2,3,1|B: 3,1|"  # sorted by key, groups A then B
+        assert stable_out == "B: 3,1|A: 2,3,1|"  # original order, groups B then A
+
+    def test_groupby_stable_empty(self, env):
+        """Test stable groupby with empty input."""
+        tmpl = env.from_string(
+            "{% for key, items in data|groupby('type', stable=True) %}"
+            "{{ key }}: {{ items|length }}|"
+            "{% endfor %}"
+        )
+        out = tmpl.render(data=[])
+        assert out == ""
+
+    def test_groupby_stable_single_group(self, env):
+        """Test stable groupby with single group."""
+        tmpl = env.from_string(
+            "{% for key, items in data|groupby('type', stable=True) %}"
+            "{{ key }}: {{ items|map(attribute='value')|join(',') }}|"
+            "{% endfor %}"
+        )
+        data = [
+            {"type": "A", "value": 3},
+            {"type": "A", "value": 1},
+            {"type": "A", "value": 2},
+        ]
+        out = tmpl.render(data=data)
+        assert out == "A: 3,1,2|"
+
+    def test_groupby_stable_with_default(self, env):
+        """Test stable groupby with default parameter."""
+        tmpl = env.from_string(
+            "{% for key, items in data|groupby('type', default='X', stable=True) %}"
+            "{{ key }}: {{ items|map(attribute='value')|join(',') }}|"
+            "{% endfor %}"
+        )
+        data = [
+            {"type": "A", "value": 1},
+            {"value": 2},  # missing 'type' key
+            {"type": "A", "value": 3},
+        ]
+        out = tmpl.render(data=data)
+        assert out == "A: 1,3|X: 2|"
+
+    def test_groupby_stable_large_dataset(self, env):
+        """Test stable groupby with larger dataset to ensure performance."""
+        data = []
+        for i in range(100):
+            data.append({"type": chr(65 + (i % 3)), "value": i})  # A, B, C cycling
+
+        tmpl = env.from_string(
+            "{% for key, items in data|groupby('type', stable=True) %}"
+            "{{ key }}: {{ items|length }}|"
+            "{% endfor %}"
+        )
+        out = tmpl.render(data=data)
+        # Should have groups A, B, C with roughly equal sizes
+        assert "A: 34|B: 33|C: 33|" == out
+
+    def test_groupby_stable_nested_attribute(self, env):
+        """Test stable groupby with nested attribute access."""
+        tmpl = env.from_string(
+            "{% for key, items in data|groupby('meta.category', stable=True) %}"
+            "{{ key }}: {{ items|map(attribute='value')|join(',') }}|"
+            "{% endfor %}"
+        )
+        data = [
+            {"meta": {"category": "X"}, "value": 3},
+            {"meta": {"category": "Y"}, "value": 1},
+            {"meta": {"category": "X"}, "value": 2},
+        ]
+        out = tmpl.render(data=data)
+        assert out == "X: 3,2|Y: 1|"
+
+    def test_groupby_stable_boolean_false(self, env):
+        """Test that stable=False behaves like default (sorted)."""
+        data = [
+            {"type": "A", "value": 3},
+            {"type": "A", "value": 1},
+            {"type": "A", "value": 2},
+        ]
+
+        tmpl_false = env.from_string(
+            "{% for key, items in data|groupby('type', stable=False) %}"
+            "{{ items|map(attribute='value')|join(',') }}"
+            "{% endfor %}"
+        )
+
+        tmpl_default = env.from_string(
+            "{% for key, items in data|groupby('type') %}"
+            "{{ items|map(attribute='value')|join(',') }}"
+            "{% endfor %}"
+        )
+
+        false_out = tmpl_false.render(data=data)
+        default_out = tmpl_default.render(data=data)
+
+        assert (
+            false_out == default_out == "3,1,2"
+        )  # Both preserve original order within groups
+
+    def test_groupby_with_counts(self, env):
+        tmpl = env.from_string(
+            "{% for city, items, count in users|groupby('city', with_counts=true) %}"
+            "{{ city }}: {{ count }} users - {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "emma", "city": "NY"},
+                {"name": "john", "city": "NY"},
+                {"name": "smith", "city": "WA"},
+            ]
+        )
+        assert out == "NY: 2 users - emma, john\nWA: 1 users - smith\n"
+
+    def test_groupby_with_counts_empty_groups(self, env):
+        tmpl = env.from_string(
+            "{% for key, items, count in data|groupby('type', with_counts=true) %}"
+            "{{ key }}: {{ count }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(data=[])
+        assert out == ""
+
+    def test_groupby_with_counts_single_group(self, env):
+        tmpl = env.from_string(
+            "{% for key, items, count in data|groupby('type', with_counts=true) %}"
+            "{{ key }}: {{ count }} items\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            data=[
+                {"type": "A", "value": 1},
+                {"type": "A", "value": 2},
+                {"type": "A", "value": 3},
+            ]
+        )
+        assert out == "A: 3 items\n"
+
+    def test_groupby_with_counts_multiple_groups(self, env):
+        tmpl = env.from_string(
+            "{% for key, items, count in data|groupby('category', with_counts=true) %}"
+            "{{ key }}: {{ count }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            data=[
+                {"category": "books", "title": "Book1"},
+                {"category": "books", "title": "Book2"},
+                {"category": "movies", "title": "Movie1"},
+                {"category": "games", "title": "Game1"},
+                {"category": "games", "title": "Game2"},
+                {"category": "games", "title": "Game3"},
+            ]
+        )
+        assert out == "books: 2\ngames: 3\nmovies: 1\n"
+
+    def test_groupby_with_counts_and_default(self, env):
+        tmpl = env.from_string(
+            "{% for key, items, count in data|groupby('category', default='misc', with_counts=true) %}"
+            "{{ key }}: {{ count }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            data=[
+                {"category": "books", "title": "Book1"},
+                {"title": "Unknown1"},
+                {"title": "Unknown2"},
+            ]
+        )
+        assert out == "books: 1\nmisc: 2\n"
+
+    def test_groupby_multilevel_basic(self, env):
+        """Test basic multi-level grouping with 2 levels."""
+        tmpl = env.from_string(
+            "{% for dept_group in users|groupby(['department', 'role'], levels=2) %}"
+            "{{ dept_group.grouper }}:\n"
+            "{% for role_group in dept_group.list %}"
+            "  {{ role_group.grouper }}: {{ role_group.list|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+            "{% endfor %}"
+        )
+        users = [
+            {"name": "alice", "department": "eng", "role": "dev"},
+            {"name": "bob", "department": "eng", "role": "dev"},
+            {"name": "charlie", "department": "eng", "role": "manager"},
+            {"name": "diana", "department": "sales", "role": "rep"},
+            {"name": "eve", "department": "sales", "role": "manager"},
+        ]
+        out = tmpl.render(users=users)
+        expected = "eng:\n  dev: alice, bob\n  manager: charlie\nsales:\n  manager: eve\n  rep: diana\n"
+        assert out == expected
+
+    def test_groupby_multilevel_three_levels(self, env):
+        """Test multi-level grouping with 3 levels."""
+        tmpl = env.from_string(
+            "{% for l1 in data|groupby(['a', 'b', 'c'], levels=3) %}"
+            "{{ l1.grouper }}:\n"
+            "{% for l2 in l1.list %}"
+            "  {{ l2.grouper }}:\n"
+            "{% for l3 in l2.list %}"
+            "    {{ l3.grouper }}: {{ l3.list|map(attribute='value')|join(',') }}\n"
+            "{% endfor %}"
+            "{% endfor %}"
+            "{% endfor %}"
+        )
+        data = [
+            {"a": "x", "b": "1", "c": "i", "value": "A"},
+            {"a": "x", "b": "1", "c": "ii", "value": "B"},
+            {"a": "x", "b": "2", "c": "i", "value": "C"},
+            {"a": "y", "b": "1", "c": "i", "value": "D"},
+        ]
+        out = tmpl.render(data=data)
+        expected = "x:\n  1:\n    i: A\n    ii: B\n  2:\n    i: C\ny:\n  1:\n    i: D\n"
+        assert out == expected
+
+    def test_groupby_multilevel_with_default(self, env):
+        """Test multi-level grouping with default values."""
+        tmpl = env.from_string(
+            "{% for dept_group in users|groupby(['department', 'role'], levels=2, default='unknown') %}"
+            "{{ dept_group.grouper }}:\n"
+            "{% for role_group in dept_group.list %}"
+            "  {{ role_group.grouper }}: {{ role_group.list|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+            "{% endfor %}"
+        )
+        users = [
+            {"name": "alice", "department": "eng", "role": "dev"},
+            {"name": "bob", "department": "eng"},  # missing role
+            {"name": "charlie", "role": "manager"},  # missing department
+            {"name": "diana"},  # missing both
+        ]
+        out = tmpl.render(users=users)
+        expected = "eng:\n  dev: alice\n  unknown: bob\nunknown:\n  manager: charlie\n  unknown: diana\n"
+        assert out == expected
+
+    def test_groupby_multilevel_empty_data(self, env):
+        """Test multi-level grouping with empty data."""
+        tmpl = env.from_string(
+            "{% for group in data|groupby(['a', 'b'], levels=2) %}{{ group.grouper }}\n{% else %}No data\n{% endfor %}"
+        )
+        out = tmpl.render(data=[])
+        assert out == "No data\n"
+
+    def test_groupby_multilevel_single_item(self, env):
+        """Test multi-level grouping with single item."""
+        tmpl = env.from_string(
+            "{% for l1 in data|groupby(['a', 'b'], levels=2) %}"
+            "{{ l1.grouper }}:\n"
+            "{% for l2 in l1.list %}"
+            "  {{ l2.grouper }}: {{ l2.list|map(attribute='value')|join(',') }}\n"
+            "{% endfor %}"
+            "{% endfor %}"
+        )
+        data = [{"a": "x", "b": "y", "value": "test"}]
+        out = tmpl.render(data=data)
+        expected = "x:\n  y: test\n"
+        assert out == expected
+
+    def test_groupby_multilevel_dot_notation(self, env):
+        """Test multi-level grouping with dot notation attributes."""
+        tmpl = env.from_string(
+            "{% for l1 in data|groupby(['obj.a', 'obj.b'], levels=2) %}"
+            "{{ l1.grouper }}:\n"
+            "{% for l2 in l1.list %}"
+            "  {{ l2.grouper }}: {{ l2.list|map(attribute='value')|join(',') }}\n"
+            "{% endfor %}"
+            "{% endfor %}"
+        )
+        data = [
+            {"obj": {"a": "x", "b": "1"}, "value": "A"},
+            {"obj": {"a": "x", "b": "2"}, "value": "B"},
+            {"obj": {"a": "y", "b": "1"}, "value": "C"},
+        ]
+        out = tmpl.render(data=data)
+        expected = "x:\n  1: A\n  2: B\ny:\n  1: C\n"
+        assert out == expected
+
+    def test_groupby_backward_compatibility(self, env):
+        """Test that single-level groupby still works as before."""
+        tmpl = env.from_string(
+            "{% for group in data|groupby('category') %}"
+            "{{ group.grouper }}: {{ group.list|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        data = [
+            {"name": "apple", "category": "fruit"},
+            {"name": "banana", "category": "fruit"},
+            {"name": "carrot", "category": "vegetable"},
+        ]
+        out = tmpl.render(data=data)
+        expected = "fruit: apple, banana\nvegetable: carrot\n"
+        assert out == expected
+
+    def test_groupby_single_attribute_list(self, env):
+        """Test that single attribute in list works without levels."""
+        tmpl = env.from_string(
+            "{% for group in data|groupby(['category']) %}"
+            "{{ group.grouper }}: {{ group.list|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        data = [
+            {"name": "apple", "category": "fruit"},
+            {"name": "banana", "category": "fruit"},
+        ]
+        out = tmpl.render(data=data)
+        expected = "fruit: apple, banana\n"
+        assert out == expected
+
+    def test_groupby_filter_groups_duplicates(self, env):
+        """Test filter_groups to find duplicates (groups with more than 1 item)."""
+
+        def filter_duplicates(group):
+            return len(group) > 1
+
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', filter_groups=filter_func) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "NY"},
+                {"name": "charlie", "city": "LA"},
+                {"name": "david", "city": "SF"},
+                {"name": "eve", "city": "SF"},
+            ],
+            filter_func=filter_duplicates,
+        )
+        assert out == "NY: alice, bob\nSF: david, eve\n"
+
+    def test_groupby_filter_groups_unique(self, env):
+        """Test filter_groups to find unique items (groups with exactly 1 item)."""
+
+        def filter_unique(group):
+            return len(group) == 1
+
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', filter_groups=filter_func) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "NY"},
+                {"name": "charlie", "city": "LA"},
+                {"name": "david", "city": "SF"},
+                {"name": "eve", "city": "SF"},
+            ],
+            filter_func=filter_unique,
+        )
+        assert out == "LA: charlie\n"
+
+    def test_groupby_filter_groups_empty_result(self, env):
+        """Test filter_groups that filters out all groups."""
+
+        def filter_large_groups(group):
+            return len(group) > 10
+
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', filter_groups=filter_func) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "LA"},
+            ],
+            filter_func=filter_large_groups,
+        )
+        assert out == ""
+
+    def test_groupby_filter_groups_all_pass(self, env):
+        """Test filter_groups that allows all groups to pass."""
+
+        def filter_all_pass(group):
+            return True
+
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', filter_groups=filter_func) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "LA"},
+            ],
+            filter_func=filter_all_pass,
+        )
+        assert out == "LA: bob\nNY: alice\n"
+
+    def test_groupby_filter_groups_with_default(self, env):
+        """Test filter_groups combined with default parameter."""
+
+        def filter_duplicates(group):
+            return len(group) > 1
+
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', default='Unknown', filter_groups=filter_func) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "NY"},
+                {"name": "charlie"},
+                {"name": "david"},
+            ],
+            filter_func=filter_duplicates,
+        )
+        assert out == "NY: alice, bob\nUnknown: charlie, david\n"
+
+    def test_groupby_filter_groups_complex_condition(self, env):
+        """Test filter_groups with complex filtering condition."""
+
+        def filter_high_scoring_groups(group):
+            return len(group) >= 2 and group[0]["score"] >= 80
+
+        tmpl = env.from_string(
+            "{% for score, items in students|groupby('score', filter_groups=filter_func) %}"
+            "Score {{ score }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            students=[
+                {"name": "alice", "score": 95},
+                {"name": "bob", "score": 95},
+                {"name": "charlie", "score": 75},
+                {"name": "david", "score": 75},
+                {"name": "eve", "score": 85},
+                {"name": "frank", "score": 85},
+                {"name": "grace", "score": 85},
+            ],
+            filter_func=filter_high_scoring_groups,
+        )
+        assert out == "Score 85: eve, frank, grace\nScore 95: alice, bob\n"
+
+    def test_groupby_filter_groups_none(self, env):
+        """Test that filter_groups=None behaves like normal groupby."""
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', filter_groups=none) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "LA"},
+            ]
+        )
+        assert out == "LA: bob\nNY: alice\n"
+
+    def test_groupby_filter_groups_lambda_duplicates(self, env):
+        """Test filter_groups with lambda function for duplicates."""
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', filter_groups=lambda_func) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "NY"},
+                {"name": "charlie", "city": "LA"},
+                {"name": "david", "city": "SF"},
+                {"name": "eve", "city": "SF"},
+            ],
+            lambda_func=lambda group: len(group) > 1,
+        )
+        assert out == "NY: alice, bob\nSF: david, eve\n"
+
+    def test_groupby_filter_groups_lambda_unique(self, env):
+        """Test filter_groups with lambda function for unique items."""
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', filter_groups=lambda_func) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "NY"},
+                {"name": "charlie", "city": "LA"},
+                {"name": "david", "city": "SF"},
+                {"name": "eve", "city": "SF"},
+            ],
+            lambda_func=lambda group: len(group) == 1,
+        )
+        assert out == "LA: charlie\n"
+
+    def test_groupby_filter_groups_lambda_complex(self, env):
+        """Test filter_groups with complex lambda condition."""
+        tmpl = env.from_string(
+            "{% for score, items in students|groupby('score', filter_groups=lambda_func) %}"
+            "Score {{ score }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            students=[
+                {"name": "alice", "score": 95},
+                {"name": "bob", "score": 95},
+                {"name": "charlie", "score": 75},
+                {"name": "david", "score": 75},
+                {"name": "eve", "score": 85},
+                {"name": "frank", "score": 85},
+                {"name": "grace", "score": 85},
+            ],
+            lambda_func=lambda group: len(group) >= 2 and group[0]["score"] >= 80,
+        )
+        assert out == "Score 85: eve, frank, grace\nScore 95: alice, bob\n"
+
+    def test_groupby_filter_groups_lambda_from_globals(self, env):
+        """Test filter_groups with lambda function from environment globals."""
+        env.globals['only_dupes'] = lambda g: len(g) > 1
+        env.globals['only_singles'] = lambda g: len(g) == 1
+ 
+        users = [
+            {"name": "alice", "city": "NY"},
+            {"name": "bob", "city": "NY"},
+            {"name": "charlie", "city": "LA"},
+            {"name": "david", "city": "SF"},
+            {"name": "eve", "city": "SF"},
+        ]
+ 
+        # Test duplicates from globals
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', filter_groups=only_dupes) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(users=users)
+        assert out == "NY: alice, bob\nSF: david, eve\n"
+ 
+        # Test singles from globals
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', filter_groups=only_singles) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(users=users)
+        assert out == "LA: charlie\n"
+
+    def test_groupby_filter_groups_lambda_edge_cases(self, env):
+        """Test filter_groups lambda edge cases (filter all, allow all)."""
+        users = [
+            {"name": "alice", "city": "NY"},
+            {"name": "bob", "city": "LA"},
+        ]
+ 
+        # Lambda that filters everything
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', filter_groups=lambda_func) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(users=users, lambda_func=lambda group: False)
+        assert out == ""
+ 
+        # Lambda that allows everything
+        out = tmpl.render(users=users, lambda_func=lambda group: True)
+        assert out == "LA: bob\nNY: alice\n"
+
     def test_filtertag(self, env):
         tmpl = env.from_string(
             "{% filter upper|replace('FOO', 'foo') %}foobar{% endfilter %}"
