diff --git a/tests/test_async_filters.py b/tests/test_async_filters.py
index 5d4f332e..36f5d559 100644
--- a/tests/test_async_filters.py
+++ b/tests/test_async_filters.py
@@ -251,3 +251,109 @@ def test_custom_async_iteratable_filter(env_async, items):
     )
     out = tmpl.render(items=items)
     assert out == "0,1,2 .. 3,4,5"
+
+
+def make_users_for_max_groups():
+    return [
+        {"name": "alice", "city": "NY"},
+        {"name": "bob", "city": "LA"},
+        {"name": "charlie", "city": "SF"},
+        {"name": "david", "city": "NY"},
+        {"name": "eve", "city": "LA"},
+    ]
+
+
+@mark_dualiter("users", make_users_for_max_groups)
+def test_groupby_max_groups(env_async, users):
+    """Test max_groups parameter limits the number of groups returned."""
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', max_groups=2) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users)
+    # Should only return first 2 groups (LA and NY, alphabetically sorted)
+    assert out == "LA: bob, eve\nNY: alice, david\n"
+
+
+@mark_dualiter(
+    "users", lambda: [{"name": "alice", "city": "NY"}, {"name": "bob", "city": "LA"}]
+)
+def test_groupby_max_groups_zero(env_async, users):
+    """Test max_groups=0 returns empty result."""
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', max_groups=0) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users)
+    assert out == ""
+
+
+@mark_dualiter(
+    "users", lambda: [{"name": "alice", "city": "NY"}, {"name": "bob", "city": "LA"}]
+)
+def test_groupby_max_groups_larger_than_available(env_async, users):
+    """Test max_groups larger than available groups returns all groups."""
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', max_groups=10) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users)
+    assert out == "LA: bob\nNY: alice\n"
+
+
+@mark_dualiter("users", lambda: [])
+def test_groupby_max_groups_empty_input(env_async, users):
+    """Test max_groups with empty input."""
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', max_groups=2) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users)
+    assert out == ""
+
+
+def test_groupby_max_groups_none(env_async):
+    """Test max_groups=None returns all groups (default behavior)."""
+    tmpl = env_async.from_string(
+        "{% for city, items in users|groupby('city', max_groups=none) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(
+        users=[
+            {"name": "alice", "city": "NY"},
+            {"name": "bob", "city": "LA"},
+            {"name": "charlie", "city": "SF"},
+        ]
+    )
+    assert out == "LA: bob\nNY: alice\nSF: charlie\n"
+
+
+@mark_dualiter("users", make_users_for_max_groups)
+def test_groupby_max_groups_single_group(env_async, users):
+    """Test max_groups=1 returns only first group."""
+    tmpl = env_async.from_string(
+        "{% for city, items in users()|groupby('city', max_groups=1) %}"
+        "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(users=users)
+    # Should return only LA (first alphabetically) with both users in that group
+    assert out == "LA: bob, eve\n"
+
+
+@mark_dualiter("data", lambda: [("a", 1), ("b", 2), ("a", 3), ("c", 4), ("b", 5)])
+def test_groupby_max_groups_with_tuple_index(env_async, data):
+    """Test max_groups works with tuple indexing."""
+    tmpl = env_async.from_string(
+        "{% for grouper, items in data()|groupby(0, max_groups=2) %}"
+        "{{ grouper }}: {{ items|map(attribute='1')|join(',') }}\n"
+        "{% endfor %}"
+    )
+    out = tmpl.render(data=data)
+    # Should return first 2 groups: a, b
+    assert out == "a: 1,3\nb: 2,5\n"
diff --git a/tests/test_filters.py b/tests/test_filters.py
index 43ddf59c..084e3907 100644
--- a/tests/test_filters.py
+++ b/tests/test_filters.py
@@ -619,6 +619,136 @@ class TestFilter:
         )
         assert out == "NY: emma, john\nWA: smith\n"
 
+    def test_groupby_max_groups(self, env):
+        """Test max_groups parameter limits the number of groups returned."""
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', max_groups=2) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "LA"},
+                {"name": "charlie", "city": "SF"},
+                {"name": "david", "city": "NY"},
+                {"name": "eve", "city": "LA"},
+            ]
+        )
+        # Should only return first 2 groups (LA and NY, alphabetically sorted)
+        assert out == "LA: bob, eve\nNY: alice, david\n"
+
+    def test_groupby_max_groups_zero(self, env):
+        """Test max_groups=0 returns empty result."""
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', max_groups=0) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "LA"},
+            ]
+        )
+        assert out == ""
+
+    def test_groupby_max_groups_larger_than_available(self, env):
+        """Test max_groups larger than available groups returns all groups."""
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', max_groups=10) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "LA"},
+            ]
+        )
+        assert out == "LA: bob\nNY: alice\n"
+
+    def test_groupby_max_groups_with_default(self, env):
+        """Test max_groups works with default parameter."""
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', default='Unknown', max_groups=2) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "LA"},
+                {"name": "charlie"},  # No city, will use default
+                {"name": "david", "city": "SF"},
+            ]
+        )
+        # Should return first 2 groups alphabetically: LA, NY
+        assert out == "LA: bob\nNY: alice\n"
+
+    def test_groupby_max_groups_empty_input(self, env):
+        """Test max_groups with empty input."""
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', max_groups=2) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(users=[])
+        assert out == ""
+
+    def test_groupby_max_groups_none(self, env):
+        """Test max_groups=None returns all groups (default behavior)."""
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', max_groups=none) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "LA"},
+                {"name": "charlie", "city": "SF"},
+            ]
+        )
+        assert out == "LA: bob\nNY: alice\nSF: charlie\n"
+
+    def test_groupby_max_groups_single_group(self, env):
+        """Test max_groups=1 returns only first group."""
+        tmpl = env.from_string(
+            "{% for city, items in users|groupby('city', max_groups=1) %}"
+            "{{ city }}: {{ items|map(attribute='name')|join(', ') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            users=[
+                {"name": "alice", "city": "NY"},
+                {"name": "bob", "city": "LA"},
+                {"name": "charlie", "city": "SF"},
+                {"name": "david", "city": "NY"},
+            ]
+        )
+        # Should return only LA (first alphabetically) with bob in that group
+        assert out == "LA: bob\n"
+
+    def test_groupby_max_groups_with_tuple_index(self, env):
+        """Test max_groups works with tuple indexing."""
+        tmpl = env.from_string(
+            "{% for grouper, items in data|groupby(0, max_groups=2) %}"
+            "{{ grouper }}: {{ items|map(attribute='1')|join(',') }}\n"
+            "{% endfor %}"
+        )
+        out = tmpl.render(
+            data=[
+                ("a", 1),
+                ("b", 2),
+                ("a", 3),
+                ("c", 4),
+                ("b", 5),
+            ]
+        )
+        # Should return first 2 groups: a, b
+        assert out == "a: 1,3\nb: 2,5\n"
+
     def test_filtertag(self, env):
         tmpl = env.from_string(
             "{% filter upper|replace('FOO', 'foo') %}foobar{% endfilter %}"

