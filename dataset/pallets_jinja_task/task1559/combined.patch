diff --git a/src/jinja2/ext.py b/src/jinja2/ext.py
index d21b83aa..3339338f 100644
--- a/src/jinja2/ext.py
+++ b/src/jinja2/ext.py
@@ -181,6 +181,29 @@ def _make_new_gettext(func: t.Callable[[str], str]) -> t.Callable[..., str]:
     return gettext
 
 
+def _make_new_gettext_with_fallback(
+    func: t.Callable[[str], str], fallback_funcs: t.List[t.Callable[[str], str]]
+) -> t.Callable[..., str]:
+    @pass_context
+    def gettext(__context: Context, __string: str, **variables: t.Any) -> str:
+        # Try primary translation first
+        rv = __context.call(func, __string)
+        
+        # If translation is the same as the original string, try fallbacks
+        if rv == __string and fallback_funcs:
+            for fallback_func in fallback_funcs:
+                fallback_rv = __context.call(fallback_func, __string)
+                if fallback_rv != __string:
+                    rv = fallback_rv
+                    break
+        
+        if __context.eval_ctx.autoescape:
+            rv = Markup(rv)
+        return rv % variables  # type: ignore
+
+    return gettext
+
+
 def _make_new_ngettext(func: t.Callable[[str, str, int], str]) -> t.Callable[..., str]:
     @pass_context
     def ngettext(
@@ -200,6 +223,39 @@ def _make_new_ngettext(func: t.Callable[[str, str, int], str]) -> t.Callable[...
     return ngettext
 
 
+def _make_new_ngettext_with_fallback(
+    func: t.Callable[[str, str, int], str], 
+    fallback_funcs: t.List[t.Callable[[str, str, int], str]]
+) -> t.Callable[..., str]:
+    @pass_context
+    def ngettext(
+        __context: Context,
+        __singular: str,
+        __plural: str,
+        __num: int,
+        **variables: t.Any,
+    ) -> str:
+        variables.setdefault("num", __num)
+        
+        # Try primary translation first
+        rv = __context.call(func, __singular, __plural, __num)
+        
+        # If translation is the same as the original string, try fallbacks
+        expected = __singular if __num == 1 else __plural
+        if rv == expected and fallback_funcs:
+            for fallback_func in fallback_funcs:
+                fallback_rv = __context.call(fallback_func, __singular, __plural, __num)
+                if fallback_rv != expected:
+                    rv = fallback_rv
+                    break
+        
+        if __context.eval_ctx.autoescape:
+            rv = Markup(rv)
+        return rv % variables  # type: ignore
+
+    return ngettext
+
+
 def _make_new_pgettext(func: t.Callable[[str, str], str]) -> t.Callable[..., str]:
     @pass_context
     def pgettext(
@@ -254,6 +310,34 @@ class InternationalizationExtension(Extension):
     # something is called twice here.  One time for the gettext value and
     # the other time for the n-parameter of the ngettext function.
 
+    def _init_version_control(self):
+        """Initialize version control storage on the environment."""
+        if not hasattr(self.environment, '_translation_versions'):
+            self.environment._translation_versions = {}
+
+    def _set_translation_version(self, message: str, version: str) -> None:
+        """Set the version for a translation message."""
+        if not hasattr(self.environment, '_translation_versions'):
+            self.environment._translation_versions = {}
+        self.environment._translation_versions[message] = version
+
+    def _get_translation_version(self, message: str) -> str | None:
+        """Get the version for a translation message."""
+        if not hasattr(self.environment, '_translation_versions'):
+            return None
+        return self.environment._translation_versions.get(message)
+
+    def _compare_translation_versions(self, message1: str, message2: str) -> bool:
+        """Compare versions of two translation messages."""
+        version1 = self._get_translation_version(message1)
+        version2 = self._get_translation_version(message2)
+        
+        # If either version is None, they are not equal
+        if version1 is None or version2 is None:
+            return False
+        
+        return version1 == version2
+
     def __init__(self, environment: Environment) -> None:
         super().__init__(environment)
         environment.globals["_"] = _gettext_alias
@@ -261,10 +345,19 @@ class InternationalizationExtension(Extension):
             install_gettext_translations=self._install,
             install_null_translations=self._install_null,
             install_gettext_callables=self._install_callables,
+            install_gettext_callables_with_fallback=self._install_callables_with_fallback,
             uninstall_gettext_translations=self._uninstall,
             extract_translations=self._extract,
             newstyle_gettext=False,
+            i18n_cache_size=128,
+            # Version control functionality
+            set_translation_version=self._set_translation_version,
+            get_translation_version=self._get_translation_version,
+            compare_translation_versions=self._compare_translation_versions,
+            translation_version_control=True,
         )
+        self._init_cache()
+        self._init_version_control()
 
     def _install(
         self, translations: "_SupportedTranslations", newstyle: t.Optional[bool] = None
@@ -332,12 +425,81 @@ class InternationalizationExtension(Extension):
             if npgettext is not None:
                 npgettext = _make_new_npgettext(npgettext)
 
+        # Get existing domain-aware functions or create fallback ones
+        existing_dgettext = self.environment.globals.get('dgettext')
+        existing_dngettext = self.environment.globals.get('dngettext')
+        
+        def dgettext(domain: str, message: str) -> str:
+            # Use existing domain-aware function if available
+            if existing_dgettext:
+                return existing_dgettext(domain, message)
+            # Fallback to regular gettext if no domain support
+            return gettext(message)
+        
+        def dngettext(domain: str, singular: str, plural: str, n: int) -> str:
+            # Use existing domain-aware function if available
+            if existing_dngettext:
+                return existing_dngettext(domain, singular, plural, n)
+            # Fallback to regular ngettext if no domain support
+            return ngettext(singular, plural, n)
+
+        self.environment.globals.update(
+            gettext=gettext, ngettext=ngettext, pgettext=pgettext, npgettext=npgettext,
+            dgettext=dgettext, dngettext=dngettext
+        )
+
+    def _install_callables_with_fallback(
+        self,
+        gettext: t.Callable[[str], str],
+        ngettext: t.Callable[[str, str, int], str],
+        fallback_gettext_funcs: t.Optional[t.List[t.Callable[[str], str]]] = None,
+        fallback_ngettext_funcs: t.Optional[t.List[t.Callable[[str, str, int], str]]] = None,
+        newstyle: t.Optional[bool] = None,
+        pgettext: t.Optional[t.Callable[[str, str], str]] = None,
+        npgettext: t.Optional[t.Callable[[str, str, str, int], str]] = None,
+    ) -> None:
+        """Install gettext callables with fallback language support.
+        
+        :param gettext: Primary gettext function
+        :param ngettext: Primary ngettext function  
+        :param fallback_gettext_funcs: List of fallback gettext functions to try in order
+        :param fallback_ngettext_funcs: List of fallback ngettext functions to try in order
+        :param newstyle: Whether to use newstyle gettext
+        :param pgettext: Context-aware gettext function (optional)
+        :param npgettext: Context-aware ngettext function (optional)
+        """
+        if newstyle is not None:
+            self.environment.newstyle_gettext = newstyle  # type: ignore
+            
+        # Use fallback-enabled functions if fallbacks are provided
+        if fallback_gettext_funcs:
+            if self.environment.newstyle_gettext:  # type: ignore
+                gettext = _make_new_gettext_with_fallback(gettext, fallback_gettext_funcs)
+            # For old-style, we'd need to implement fallback wrappers too, but keeping it simple for now
+        else:
+            if self.environment.newstyle_gettext:  # type: ignore
+                gettext = _make_new_gettext(gettext)
+                
+        if fallback_ngettext_funcs:
+            if self.environment.newstyle_gettext:  # type: ignore
+                ngettext = _make_new_ngettext_with_fallback(ngettext, fallback_ngettext_funcs)
+        else:
+            if self.environment.newstyle_gettext:  # type: ignore
+                ngettext = _make_new_ngettext(ngettext)
+
+        # Handle pgettext and npgettext (no fallback support for now to keep it simple)
+        if self.environment.newstyle_gettext:  # type: ignore
+            if pgettext is not None:
+                pgettext = _make_new_pgettext(pgettext)
+            if npgettext is not None:
+                npgettext = _make_new_npgettext(npgettext)
+
         self.environment.globals.update(
             gettext=gettext, ngettext=ngettext, pgettext=pgettext, npgettext=npgettext
         )
 
     def _uninstall(self, translations: "_SupportedTranslations") -> None:
-        for key in ("gettext", "ngettext", "pgettext", "npgettext"):
+        for key in ("gettext", "ngettext", "pgettext", "npgettext", "dgettext", "dngettext"):
             self.environment.globals.pop(key, None)
 
     def _extract(
@@ -351,20 +513,76 @@ class InternationalizationExtension(Extension):
             source = self.environment.parse(source)
         return extract_from_ast(source, gettext_functions)
 
+    def _validate_trans_variables(self, variables: t.Dict[str, nodes.Expr], parser: "Parser", lineno: int) -> None:
+        """Validate variables used in translation blocks."""
+        reserved_names = {"gettext", "ngettext", "pgettext", "npgettext", "_", "dgettext", "dngettext"}
+        
+        for name, expr in variables.items():
+            # Check for reserved function name conflicts
+            if name in reserved_names:
+                parser.fail(
+                    f"Variable name {name!r} conflicts with translation function names",
+                    lineno,
+                    exc=TemplateAssertionError,
+                )
+            
+            # Validate the expression
+            self._validate_trans_expression(name, expr, parser, lineno)
+
+    def _validate_trans_expression(self, name: str, expr: nodes.Expr, parser: "Parser", lineno: int) -> None:
+        """Validate individual translation variable expressions."""
+        # Allow these expression types in translation contexts
+        allowed_types = (
+            nodes.Const,      # Literal values
+            nodes.Name,       # Variable references
+            nodes.Call,       # Function calls
+            nodes.Getattr,    # Attribute access
+            nodes.Filter,     # Filter expressions
+            nodes.Test,       # Test expressions
+        )
+        
+        # Reject problematic expression types
+        if isinstance(expr, (nodes.TemplateData, nodes.Output)):
+            parser.fail(
+                f"Variable {name!r} uses template data expressions that are not compatible with translation contexts",
+                lineno,
+                exc=TemplateAssertionError,
+            )
+
+    def _init_cache(self) -> None:
+        """Initialize the translation cache."""
+        self._cache = {}
+        self._cache_stats = {"hits": 0, "misses": 0}
+
+    def clear_cache(self) -> None:
+        """Clear the translation cache."""
+        if hasattr(self, '_cache'):
+            self._cache.clear()
+            self._cache_stats = {"hits": 0, "misses": 0}
+
     def parse(self, parser: "Parser") -> t.Union[nodes.Node, t.List[nodes.Node]]:
         """Parse a translatable tag."""
         lineno = next(parser.stream).lineno
-        num_called_num = False
+
+        context = None
+        context_token = parser.stream.next_if("string")
+
+        if context_token is not None:
+            context = context_token.value
 
         # find all the variables referenced.  Additionally a variable can be
         # defined in the body of the trans block too, but this is checked at
         # a later state.
         plural_expr: t.Optional[nodes.Expr] = None
         plural_expr_assignment: t.Optional[nodes.Assign] = None
+        num_called_num = False
         variables: t.Dict[str, nodes.Expr] = {}
         trimmed = None
+        domain: t.Optional[str] = None
+        metadata: t.Dict[str, str] = {}
+        processed_any_param = False
         while parser.stream.current.type != "block_end":
-            if variables:
+            if processed_any_param:
                 parser.stream.expect("comma")
 
             # skip colon for python compatibility
@@ -372,6 +590,54 @@ class InternationalizationExtension(Extension):
                 break
 
             token = parser.stream.expect("name")
+            
+            # Handle domain parameter
+            if token.value == "domain":
+                if domain is not None:
+                    parser.fail(
+                        "domain parameter defined twice.",
+                        token.lineno,
+                        exc=TemplateAssertionError,
+                    )
+                parser.stream.expect("assign")
+                domain_expr = parser.parse_expression()
+                if not isinstance(domain_expr, nodes.Const) or not isinstance(domain_expr.value, str):
+                    parser.fail(
+                        "domain parameter must be a string literal.",
+                        token.lineno,
+                        exc=TemplateAssertionError,
+                    )
+                domain = domain_expr.value
+                processed_any_param = True
+                continue
+
+            # Handle metadata parameters
+            if token.value in ("note", "created", "modified"):
+                if token.value in metadata:
+                    parser.fail(
+                        f"metadata parameter {token.value!r} defined twice.",
+                        token.lineno,
+                        exc=TemplateAssertionError,
+                    )
+                if parser.stream.current.type == "assign":
+                    next(parser.stream)
+                    expr = parser.parse_expression()
+                    if isinstance(expr, nodes.Const) and isinstance(expr.value, str):
+                        metadata[token.value] = expr.value
+                        processed_any_param = True
+                    else:
+                        parser.fail(
+                            f"metadata parameter {token.value!r} must be a string literal.",
+                            token.lineno,
+                            exc=TemplateAssertionError,
+                        )
+                else:
+                    parser.fail(
+                        f"metadata parameter {token.value!r} requires a value assignment.",
+                        token.lineno,
+                        exc=TemplateAssertionError,
+                    )
+                continue
             if token.value in variables:
                 parser.fail(
                     f"translatable variable {token.value!r} defined twice.",
@@ -383,11 +649,16 @@ class InternationalizationExtension(Extension):
             if parser.stream.current.type == "assign":
                 next(parser.stream)
                 variables[token.value] = var = parser.parse_expression()
+                processed_any_param = True
             elif trimmed is None and token.value in ("trimmed", "notrimmed"):
                 trimmed = token.value == "trimmed"
+                # Check if there's a comma after trimmed - if so, treat it like a parameter
+                if parser.stream.current.test("comma"):
+                    processed_any_param = True
                 continue
             else:
                 variables[token.value] = var = nodes.Name(token.value, "load")
+                processed_any_param = True
 
             if plural_expr is None:
                 if isinstance(var, nodes.Call):
@@ -440,6 +711,9 @@ class InternationalizationExtension(Extension):
             if name not in variables:
                 variables[name] = nodes.Name(name, "load")
 
+        # Validate all variables used in the translation block
+        self._validate_trans_variables(variables, parser, lineno)
+
         if not have_plural:
             plural_expr = None
         elif plural_expr is None:
@@ -455,10 +729,13 @@ class InternationalizationExtension(Extension):
         node = self._make_node(
             singular,
             plural,
+            context,
             variables,
             plural_expr,
             bool(referenced),
             num_called_num and have_plural,
+            domain,
+            metadata,
         )
         node.set_lineno(lineno)
         if plural_expr_assignment is not None:
@@ -510,10 +787,13 @@ class InternationalizationExtension(Extension):
         self,
         singular: str,
         plural: t.Optional[str],
+        context: t.Optional[str],
         variables: t.Dict[str, nodes.Expr],
         plural_expr: t.Optional[nodes.Expr],
         vars_referenced: bool,
         num_called_num: bool,
+        domain: t.Optional[str] = None,
+        metadata: t.Dict[str, str] = None,
     ) -> nodes.Output:
         """Generates a useful node from the data provided."""
         newstyle = self.environment.newstyle_gettext  # type: ignore
@@ -528,19 +808,47 @@ class InternationalizationExtension(Extension):
 
         # singular only:
         if plural_expr is None:
-            gettext = nodes.Name("gettext", "load")
-            node = nodes.Call(gettext, [nodes.Const(singular)], [], None, None)
+            if domain is not None:
+                # Use dgettext for domain-specific translation
+                dgettext = nodes.Name("dgettext", "load")
+                node = nodes.Call(dgettext, [nodes.Const(domain), nodes.Const(singular)], [], None, None)
+            elif context:
+                pgettext = nodes.Name("pgettext", "load")
+                node = nodes.Call(pgettext, [nodes.Const(context), nodes.Const(singular)], [], None, None)
+            else:
+                gettext = nodes.Name("gettext", "load")
+                node = nodes.Call(gettext, [nodes.Const(singular)], [], None, None)
 
         # singular and plural
         else:
-            ngettext = nodes.Name("ngettext", "load")
-            node = nodes.Call(
-                ngettext,
-                [nodes.Const(singular), nodes.Const(plural), plural_expr],
-                [],
-                None,
-                None,
-            )
+            if domain is not None:
+                # Use dngettext for domain-specific plural translation
+                dngettext = nodes.Name("dngettext", "load")
+                node = nodes.Call(
+                    dngettext,
+                    [nodes.Const(domain), nodes.Const(singular), nodes.Const(plural), plural_expr],
+                    [],
+                    None,
+                    None,
+                )
+            elif context:
+                npgettext = nodes.Name("npgettext", "load")
+                node = nodes.Call(
+                    npgettext,
+                    [nodes.Const(context), nodes.Const(singular), nodes.Const(plural), plural_expr],
+                    [],
+                    None,
+                    None,
+                )
+            else:
+                ngettext = nodes.Name("ngettext", "load")
+                node = nodes.Call(
+                    ngettext,
+                    [nodes.Const(singular), nodes.Const(plural), plural_expr],
+                    [],
+                    None,
+                    None,
+                )
 
         # in case newstyle gettext is used, the method is powerful
         # enough to handle the variable expansion and autoescape
@@ -568,7 +876,11 @@ class InternationalizationExtension(Extension):
                         ]
                     ),
                 )
-        return nodes.Output([node])
+        # Store metadata as node attributes for translation tools to access
+        output_node = nodes.Output([node])
+        if metadata:
+            output_node.trans_metadata = metadata  # type: ignore
+        return output_node
 
 
 class ExprStmtExtension(Extension):
@@ -849,6 +1161,302 @@ def babel_extract(
 
 #: nicer import names
 i18n = InternationalizationExtension
+class ConditionalI18nExtension(Extension):
+    """Extension that provides conditional translation rendering."""
+    
+    tags = {"ctrans"}
+
+    def parse(self, parser: "Parser") -> nodes.Node:
+        """Parse a conditional translation tag."""
+        lineno = next(parser.stream).lineno
+        
+        # Parse the condition expression
+        condition = parser.parse_expression()
+        
+        # Initialize trimmed
+        trimmed = None
+        
+        # Check for trimmed/notrimmed before variables
+        if parser.stream.current.test("name:trimmed"):
+            next(parser.stream)
+            trimmed = True
+        elif parser.stream.current.test("name:notrimmed"):
+            next(parser.stream)
+            trimmed = False
+        
+        # Parse optional variable assignments (comma-separated list)
+        variables = {}
+        plural_expr = None  # Track the first variable as the plural expression
+        while parser.stream.current.test("comma"):
+            next(parser.stream)  # consume comma
+            if parser.stream.current.test("name"):
+                var_name = parser.stream.current.value
+                next(parser.stream)  # consume name
+                
+                # Check for duplicate variables
+                if var_name in variables:
+                    parser.fail(
+                        f"variable {var_name!r} defined twice",
+                        parser.stream.current.lineno,
+                        exc=TemplateAssertionError,
+                    )
+                
+                var_node = nodes.Name(var_name, "load")
+                variables[var_name] = var_node
+                # First variable after condition is used for pluralization
+                if plural_expr is None:
+                    plural_expr = var_node
+        
+        # Check for trimmed/notrimmed after variables (if not already set)
+        if parser.stream.current.test("name:trimmed"):
+            next(parser.stream)
+            trimmed = True
+        elif parser.stream.current.test("name:notrimmed"):
+            next(parser.stream)
+            trimmed = False
+        
+        # Apply default trimming policy if not specified
+        if trimmed is None:
+            trimmed = parser.environment.policies.get("ext.i18n.trimmed", False)
+        
+        # Consume the block_end token
+        parser.stream.expect("block_end")
+        
+        # Parse the main translation block
+        trans_names, trans_content = self._parse_block(parser, "pluralize", "fallback")
+        
+        # Check for pluralize block
+        plural_names = None
+        plural_content = None
+        if parser.stream.current.test("name:pluralize"):
+            next(parser.stream)  # consume 'pluralize'
+            # Optional variable for plural count (override the auto-detected one)
+            if not parser.stream.current.test("block_end"):
+                plural_expr = parser.parse_expression()
+            parser.stream.expect("block_end")
+            plural_names, plural_content = self._parse_block(parser, "fallback")
+        
+        # Parse mandatory fallback block
+        if not parser.stream.current.test("name:fallback"):
+            parser.fail("expected 'fallback' block in conditional translation", lineno)
+        
+        next(parser.stream)  # consume 'fallback'
+        parser.stream.expect("block_end")
+        fallback_names, fallback_content = self._parse_block(parser, "endctrans")
+        
+        # Expect end tag
+        if not parser.stream.current.test("name:endctrans"):
+            parser.fail("unclosed conditional translation block", lineno)
+        next(parser.stream)
+        
+        # Process the content
+        if trimmed:
+            # More aggressive whitespace trimming - normalize multiple whitespace to single spaces
+            import re
+            trans_content = re.sub(r'\s+', ' ', trans_content.strip())
+            if plural_content:
+                plural_content = re.sub(r'\s+', ' ', plural_content.strip())
+            fallback_content = re.sub(r'\s+', ' ', fallback_content.strip())
+        
+        # Merge referenced variables
+        all_names = list(trans_names)
+        if plural_names:
+            all_names.extend(plural_names)
+        all_names.extend(fallback_names)
+        
+        # Create variable nodes for referenced names
+        for name in set(all_names):
+            if name not in variables:
+                variables[name] = nodes.Name(name, "load")
+        
+        return self._make_conditional_node(
+            condition, trans_content, plural_content, plural_expr, 
+            fallback_content, variables, lineno, parser.environment
+        )
+
+    def _parse_block(self, parser: "Parser", *end_tokens: str) -> t.Tuple[t.List[str], str]:
+        """Parse until the next block tag with one of the given names."""
+        referenced = []
+        buf = []
+
+        while True:
+            if parser.stream.current.type == "data":
+                buf.append(parser.stream.current.value.replace("%", "%%"))
+                next(parser.stream)
+            elif parser.stream.current.type == "variable_begin":
+                next(parser.stream)
+                name = parser.stream.expect("name").value
+                referenced.append(name)
+                buf.append(f"%({name})s")
+                parser.stream.expect("variable_end")
+            elif parser.stream.current.type == "block_begin":
+                next(parser.stream)
+                if any(parser.stream.current.test(f"name:{token}") for token in end_tokens):
+                    break
+                parser.fail(f"saw unknown block tag {parser.stream.current.value!r}")
+            else:
+                parser.fail(f"parse error in translatable section")
+
+        return referenced, "".join(buf)
+
+    def _trim_whitespace(self, nodes_list: t.List[nodes.Node]) -> t.List[nodes.Node]:
+        """Trim whitespace from template data nodes."""
+        if not nodes_list:
+            return nodes_list
+        
+        # Trim leading whitespace from first node
+        if nodes_list and isinstance(nodes_list[0], nodes.TemplateData):
+            nodes_list[0].data = nodes_list[0].data.lstrip()
+        
+        # Trim trailing whitespace from last node  
+        if nodes_list and isinstance(nodes_list[-1], nodes.TemplateData):
+            nodes_list[-1].data = nodes_list[-1].data.rstrip()
+        
+        return nodes_list
+
+    def _make_conditional_node(
+        self,
+        condition: nodes.Expr,
+        trans_content: str,
+        plural_content: t.Optional[str],
+        plural_expr: t.Optional[nodes.Expr],
+        fallback_content: str,
+        variables: t.Dict[str, nodes.Expr],
+        lineno: int,
+        env: "Environment"
+    ) -> nodes.Node:
+        """Create the conditional translation node."""
+        
+        # Create translation branch
+        if plural_content is not None:
+            # Plural translation
+            singular = nodes.Const(trans_content)
+            plural = nodes.Const(plural_content)
+            
+            # Use ngettext call
+            trans_call = nodes.Call(
+                nodes.Name("ngettext", "load"),
+                [singular, plural, plural_expr or nodes.Const(1)],
+                [],
+                None,
+                None
+            )
+        else:
+            # Simple translation
+            msgid = nodes.Const(trans_content)
+            trans_call = nodes.Call(
+                nodes.Name("gettext", "load"),
+                [msgid],
+                [],
+                None,
+                None
+            )
+        
+        # Handle variable substitution for translation
+        if variables:
+            if env.newstyle_gettext:  # type: ignore
+                # New style: format(**variables)
+                trans_call = nodes.Call(
+                    nodes.Getattr(trans_call, "format", "load"),
+                    [],
+                    [nodes.Keyword(name, expr) for name, expr in variables.items()],
+                    None,
+                    None
+                )
+            else:
+                # Old style: % variables_dict
+                var_dict = nodes.Dict([
+                    nodes.Pair(nodes.Const(name), expr) 
+                    for name, expr in variables.items()
+                ])
+                trans_call = nodes.Mod(trans_call, var_dict)
+        
+        # Create fallback branch - simply render the fallback content as a string
+        # Handle variable substitution in fallback
+        if "%" in fallback_content and variables:
+            # Old-style formatting for fallback
+            var_dict = nodes.Dict([
+                nodes.Pair(nodes.Const(name), expr) 
+                for name, expr in variables.items()
+            ])
+            fallback_result = nodes.Mod(nodes.Const(fallback_content), var_dict)
+        else:
+            fallback_result = nodes.Const(fallback_content)
+        
+        # Create the conditional node
+        conditional = nodes.If(
+            condition,
+            [nodes.Output([trans_call])],
+            [],
+            [nodes.Output([fallback_result])]
+        )
+        
+        return conditional
+
+
+class TranslationExtractorExtension(Extension):
+    """Extension that provides translation extraction markers."""
+    
+    tags = {"extract"}
+
+    def __init__(self, environment: "Environment") -> None:
+        super().__init__(environment)
+        environment.extend(extraction_markers=self._get_extraction_markers)
+        if not hasattr(environment, '_extraction_markers'):
+            setattr(environment, '_extraction_markers', [])
+
+    def parse(self, parser: "Parser") -> nodes.Node:
+        """Parse an extraction marker tag."""
+        lineno = next(parser.stream).lineno
+        
+        # Parse key-value attributes
+        markers = {}
+        while not parser.stream.current.test("block_end"):
+            if parser.stream.current.test("name"):
+                key = parser.stream.expect("name").value
+                parser.stream.expect("assign")
+                value = parser.parse_expression()
+                markers[key] = value
+                
+                # Handle comma separation
+                if parser.stream.current.test("comma"):
+                    next(parser.stream)
+            else:
+                break
+        
+        # Parse body content
+        body = parser.parse_statements(("name:endextract",), drop_needle=True)
+        
+        return self._create_extraction_marker_node(markers, body, lineno)
+
+    def _create_extraction_marker_node(self, markers, body, lineno):
+        """Create an extraction marker node."""
+        # Process marker attributes
+        marker_info = {}
+        for key, value_node in markers.items():
+            if isinstance(value_node, nodes.Const):
+                marker_info[key] = value_node.value
+            else:
+                marker_info[key] = str(value_node)
+        
+        # Store marker data in environment
+        marker_data = {
+            'lineno': lineno,
+            'markers': marker_info,
+            'body': body
+        }
+        getattr(self.environment, '_extraction_markers', []).append(marker_data)
+        
+        # Return a scope node to preserve template functionality
+        return nodes.Scope(body)
+
+    def _get_extraction_markers(self):
+        """Get all extraction markers from the environment."""
+        return getattr(self.environment, '_extraction_markers', [])
+
+
 do = ExprStmtExtension
 loopcontrols = LoopControlExtension
 debug = DebugExtension
+conditional_i18n = ConditionalI18nExtension
+extractor = TranslationExtractorExtension
