diff --git a/src/jinja2/ext.py b/src/jinja2/ext.py
index d21b83aa..5e228834 100644
--- a/src/jinja2/ext.py
+++ b/src/jinja2/ext.py
@@ -362,9 +362,12 @@ class InternationalizationExtension(Extension):
         plural_expr: t.Optional[nodes.Expr] = None
         plural_expr_assignment: t.Optional[nodes.Assign] = None
         variables: t.Dict[str, nodes.Expr] = {}
+        priority_expr: t.Optional[nodes.Expr] = None
         trimmed = None
+        have_params = False  # Track if we've parsed any parameters for comma handling
+
         while parser.stream.current.type != "block_end":
-            if variables:
+            if have_params:
                 parser.stream.expect("comma")
 
             # skip colon for python compatibility
@@ -382,13 +385,21 @@ class InternationalizationExtension(Extension):
             # expressions
             if parser.stream.current.type == "assign":
                 next(parser.stream)
-                variables[token.value] = var = parser.parse_expression()
+                var = parser.parse_expression()
+                # Handle priority parameter specially - don't add to variables
+                if token.value == "priority":
+                    priority_expr = var
+                    have_params = True
+                    continue
+                variables[token.value] = var
             elif trimmed is None and token.value in ("trimmed", "notrimmed"):
                 trimmed = token.value == "trimmed"
                 continue
             else:
                 variables[token.value] = var = nodes.Name(token.value, "load")
 
+            have_params = True
+
             if plural_expr is None:
                 if isinstance(var, nodes.Call):
                     plural_expr = nodes.Name("_trans", "load")
@@ -459,6 +470,7 @@ class InternationalizationExtension(Extension):
             plural_expr,
             bool(referenced),
             num_called_num and have_plural,
+            priority_expr,
         )
         node.set_lineno(lineno)
         if plural_expr_assignment is not None:
@@ -514,6 +526,7 @@ class InternationalizationExtension(Extension):
         plural_expr: t.Optional[nodes.Expr],
         vars_referenced: bool,
         num_called_num: bool,
+        priority_expr: t.Optional[nodes.Expr] = None,
     ) -> nodes.Output:
         """Generates a useful node from the data provided."""
         newstyle = self.environment.newstyle_gettext  # type: ignore
@@ -526,50 +539,166 @@ class InternationalizationExtension(Extension):
             if plural:
                 plural = plural.replace("%%", "%")
 
-        # singular only:
-        if plural_expr is None:
-            gettext = nodes.Name("gettext", "load")
-            node = nodes.Call(gettext, [nodes.Const(singular)], [], None, None)
+        # If priority is specified, use priority-aware translation
+        if priority_expr is not None:
+            # Use extension method to handle priority-based translation
+            if plural_expr is None:
+                # singular only with priority
+                node = self.call_method(
+                    "_priority_gettext",
+                    [nodes.Const(singular), priority_expr],
+                )
+            else:
+                # plural with priority
+                node = self.call_method(
+                    "_priority_ngettext",
+                    [nodes.Const(singular), nodes.Const(plural), plural_expr, priority_expr],
+                )
 
-        # singular and plural
+            # For priority-based translations, handle variables
+            if variables:
+                for key, value in variables.items():
+                    if num_called_num and key == "num":
+                        continue
+                    node.kwargs.append(nodes.Keyword(key, value))
         else:
-            ngettext = nodes.Name("ngettext", "load")
-            node = nodes.Call(
-                ngettext,
-                [nodes.Const(singular), nodes.Const(plural), plural_expr],
-                [],
-                None,
-                None,
-            )
-
-        # in case newstyle gettext is used, the method is powerful
-        # enough to handle the variable expansion and autoescape
-        # handling itself
-        if newstyle:
-            for key, value in variables.items():
-                # the function adds that later anyways in case num was
-                # called num, so just skip it.
-                if num_called_num and key == "num":
-                    continue
-                node.kwargs.append(nodes.Keyword(key, value))
+            # Original behavior without priority
+            # singular only:
+            if plural_expr is None:
+                gettext = nodes.Name("gettext", "load")
+                node = nodes.Call(gettext, [nodes.Const(singular)], [], None, None)
 
-        # otherwise do that here
-        else:
-            # mark the return value as safe if we are in an
-            # environment with autoescaping turned on
-            node = nodes.MarkSafeIfAutoescape(node)
-            if variables:
-                node = nodes.Mod(
-                    node,
-                    nodes.Dict(
-                        [
-                            nodes.Pair(nodes.Const(key), value)
-                            for key, value in variables.items()
-                        ]
-                    ),
+            # singular and plural
+            else:
+                ngettext = nodes.Name("ngettext", "load")
+                node = nodes.Call(
+                    ngettext,
+                    [nodes.Const(singular), nodes.Const(plural), plural_expr],
+                    [],
+                    None,
+                    None,
                 )
+
+            # in case newstyle gettext is used, the method is powerful
+            # enough to handle the variable expansion and autoescape
+            # handling itself
+            if newstyle:
+                for key, value in variables.items():
+                    # the function adds that later anyways in case num was
+                    # called num, so just skip it.
+                    if num_called_num and key == "num":
+                        continue
+                    node.kwargs.append(nodes.Keyword(key, value))
+
+            # otherwise do that here
+            else:
+                # mark the return value as safe if we are in an
+                # environment with autoescaping turned on
+                node = nodes.MarkSafeIfAutoescape(node)
+                if variables:
+                    node = nodes.Mod(
+                        node,
+                        nodes.Dict(
+                            [
+                                nodes.Pair(nodes.Const(key), value)
+                                for key, value in variables.items()
+                            ]
+                        ),
+                    )
         return nodes.Output([node])
 
+    @pass_context
+    def _priority_gettext(
+        self, context: Context, message: str, priority: int, **variables: t.Any
+    ) -> str:
+        """Handle priority-aware gettext translation with fallback."""
+        # Ensure priority is a valid integer
+        try:
+            priority = int(priority)
+            if priority < 0:
+                priority = 0
+        except (ValueError, TypeError):
+            priority = 0
+
+        gettext_func = context.resolve("gettext")
+        if not gettext_func:
+            # No gettext function available, return original message
+            result = message
+            if context.eval_ctx.autoescape:
+                result = Markup(result)
+            if variables:
+                return result % variables  # type: ignore
+            return result
+
+        # Limit priority to reasonable maximum to prevent excessive calls
+        max_priority = min(priority, 10)
+
+        # Try translation starting from priority 0 up to the specified priority
+        current_priority = 0
+
+        while current_priority <= max_priority:
+            # Try to get translation at current priority level
+            result = context.call(gettext_func, message)
+
+            # Check if we got a translation (result != original message)
+            if result != message:
+                # Translation found! Apply formatting and return
+                if context.eval_ctx.autoescape:
+                    result = Markup(result)
+                if variables:
+                    return result % variables  # type: ignore
+                return result
+
+            # No translation found at this priority level
+            if current_priority >= max_priority:
+                break
+
+            current_priority += 1
+
+        # Fallback to original message if no translation found
+        result = message
+        if context.eval_ctx.autoescape:
+            result = Markup(result)
+        if variables:
+            return result % variables  # type: ignore
+        return result
+
+    @pass_context
+    def _priority_ngettext(
+        self,
+        context: Context,
+        singular: str,
+        plural: str,
+        num: int,
+        priority: int,
+        **variables: t.Any,
+    ) -> str:
+        """Handle priority-aware ngettext translation with fallback."""
+        # Ensure priority is a valid integer
+        try:
+            priority = int(priority)
+            if priority < 0:
+                priority = 0
+        except (ValueError, TypeError):
+            priority = 0
+
+        variables.setdefault("num", num)
+
+        ngettext_func = context.resolve("ngettext")
+        if not ngettext_func:
+            # No ngettext function available, return original message
+            result = singular if num == 1 else plural
+            if context.eval_ctx.autoescape:
+                result = Markup(result)
+            return result % variables  # type: ignore
+
+        # Call ngettext directly
+        result = context.call(ngettext_func, singular, plural, num)
+
+        if context.eval_ctx.autoescape:
+            result = Markup(result)
+        return result % variables  # type: ignore
+
 
 class ExprStmtExtension(Extension):
     """Adds a `do` tag to Jinja that works like the print statement just

