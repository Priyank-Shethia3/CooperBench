diff --git a/src/jinja2/ext.py b/src/jinja2/ext.py
index d21b83aa..4bc4aad8 100644
--- a/src/jinja2/ext.py
+++ b/src/jinja2/ext.py
@@ -27,7 +27,7 @@ if t.TYPE_CHECKING:
             ...
 
         def ngettext(self, singular: str, plural: str, n: int) -> str:
-            pass
+            ...
 
     class _TranslationsContext(_TranslationsBasic):
         def pgettext(self, context: str, message: str) -> str:
@@ -636,6 +636,102 @@ class DebugExtension(Extension):
         return pprint.pformat(result, depth=3, compact=True)
 
 
+class TranslationExtractorExtension(Extension):
+    """Extension that adds support for translation extraction markers.
+ 
+    This extension provides the ``{% extract %}`` tag that allows developers
+    to add metadata and context information to translatable strings for
+    better translation tool support.
+ 
+    Example usage:
+ 
+    .. code-block:: html+jinja
+ 
+        {% extract comment="Button text for user login" context="authentication" %}
+        {{ _("Login") }}
+        {% endextract %}
+ 
+        {% extract comment="Error message", priority="high" %}
+        {{ _("Invalid credentials") }}
+        {% endextract %}
+ 
+    The markers are processed during template compilation and can include
+    metadata such as translator comments, context descriptions, and
+    extraction flags.
+    """
+
+    tags = {"extract"}
+
+    def __init__(self, environment: Environment) -> None:
+        super().__init__(environment)
+        environment.extend(
+            extraction_markers=self._get_extraction_markers,
+        )
+        # Store extraction markers for later retrieval
+        if not hasattr(environment, '_extraction_markers'):
+            setattr(environment, '_extraction_markers', [])
+
+    def parse(self, parser: "Parser") -> t.Union[nodes.Node, t.List[nodes.Node]]:
+        """Parse an extraction marker block."""
+        lineno = next(parser.stream).lineno
+ 
+        # Parse marker attributes (comment, context, priority, etc.)
+        markers = {}
+        while parser.stream.current.type != "block_end":
+            if markers:
+                parser.stream.expect("comma")
+ 
+            # Parse key=value pairs
+            key = parser.stream.expect("name").value
+            parser.stream.expect("assign")
+            value = parser.parse_expression()
+            # Store the marker metadata
+            markers[key] = value
+ 
+        # Parse the body content until endextract
+        body = list(parser.parse_statements(("name:endextract",), drop_needle=True))
+ 
+        # Create a marker node that wraps the body
+        marker_node = self._create_extraction_marker_node(markers, body, lineno)
+ 
+        return marker_node
+
+    def _create_extraction_marker_node(
+        self, 
+        markers: t.Dict[str, nodes.Expr], 
+        body: t.List[nodes.Node], 
+        lineno: int
+    ) -> nodes.Node:
+        """Create a node that represents an extraction marker."""
+        # Store marker information in the environment for extraction tools
+        marker_info = {}
+        for key, value_node in markers.items():
+            try:
+                # Try to evaluate constant expressions
+                if isinstance(value_node, nodes.Const):
+                    marker_info[key] = value_node.value
+                else:
+                    # For non-constant expressions, store the node representation
+                    marker_info[key] = str(value_node)
+            except Exception:
+                marker_info[key] = str(value_node)
+ 
+        # Store the marker info with line number for extraction tools
+        markers_list = getattr(self.environment, '_extraction_markers', [])
+        markers_list.append({
+            'lineno': lineno,
+            'markers': marker_info,
+            'body': body
+        })
+ 
+        # Return the body nodes wrapped in a scope to maintain template functionality
+        return nodes.Scope(body, lineno=lineno)
+
+    def _get_extraction_markers(self) -> t.List[t.Dict[str, t.Any]]:
+        """Get all extraction markers found in the template."""
+        return getattr(self.environment, '_extraction_markers', [])
+
+
 def extract_from_ast(
     ast: nodes.Template,
     gettext_functions: t.Sequence[str] = GETTEXT_FUNCTIONS,
@@ -852,3 +948,4 @@ i18n = InternationalizationExtension
 do = ExprStmtExtension
 loopcontrols = LoopControlExtension
 debug = DebugExtension
+extractor = TranslationExtractorExtension

