diff --git a/src/jinja2/ext.py b/src/jinja2/ext.py
index d21b83aa..d8240d27 100644
--- a/src/jinja2/ext.py
+++ b/src/jinja2/ext.py
@@ -847,8 +847,240 @@ def babel_extract(
         yield lineno, func, message, finder.find_comments(lineno)
 
 
+class ConditionalI18nExtension(Extension):
+    """This extension adds conditional translation support to Jinja."""
+
+    tags = {"ctrans"}
+
+    def __init__(self, environment: Environment) -> None:
+        super().__init__(environment)
+
+    def parse(self, parser: "Parser") -> t.Union[nodes.Node, t.List[nodes.Node]]:
+        """Parse a conditional translatable tag."""
+        lineno = next(parser.stream).lineno
+ 
+        # Parse the condition expression
+        condition = parser.parse_expression()
+ 
+        # Parse optional variables like in regular trans blocks
+        variables: t.Dict[str, nodes.Expr] = {}
+        plural_expr: t.Optional[nodes.Expr] = None
+        trimmed = None
+ 
+        while parser.stream.current.type != "block_end":
+            if parser.stream.current.test("comma"):
+                next(parser.stream)
+
+            # skip colon for python compatibility
+            if parser.stream.skip_if("colon"):
+                break
+
+            if parser.stream.current.type != "name":
+                break
+ 
+            token = parser.stream.current
+            if token.value in variables:
+                parser.fail(
+                    f"translatable variable {token.value!r} defined twice.",
+                    token.lineno,
+                    exc=TemplateAssertionError,
+                )
+
+            # Handle trimmed/notrimmed
+            if trimmed is None and token.value in ("trimmed", "notrimmed"):
+                trimmed = token.value == "trimmed"
+                next(parser.stream)
+                continue
+ 
+            next(parser.stream)  # consume the name token
+ 
+            # expressions
+            if parser.stream.current.type == "assign":
+                next(parser.stream)
+                variables[token.value] = var = parser.parse_expression()
+            else:
+                variables[token.value] = var = nodes.Name(token.value, "load")
+
+            if plural_expr is None:
+                plural_expr = var
+
+        parser.stream.expect("block_end")
+
+        # Parse the translatable content
+        singular_names, singular = self._parse_block(parser, True)
+        if singular_names:
+            for name in singular_names:
+                if name not in variables:
+                    variables[name] = nodes.Name(name, "load")
+
+        # Check for pluralize block
+        plural = None
+        have_plural = False
+        if parser.stream.current.test("name:pluralize"):
+            have_plural = True
+            next(parser.stream)
+            if parser.stream.current.type != "block_end":
+                token = parser.stream.expect("name")
+                if token.value not in variables:
+                    parser.fail(
+                        f"unknown variable {token.value!r} for pluralization",
+                        token.lineno,
+                        exc=TemplateAssertionError,
+                    )
+                plural_expr = variables[token.value]
+            parser.stream.expect("block_end")
+            plural_names, plural = self._parse_block(parser, False)
+            # Don't consume the next token here, let _parse_block handle it
+ 
+        # Ensure we're at the fallback block
+        if not parser.stream.current.test("name:fallback"):
+            parser.fail("expected 'fallback' block in conditional translation")
+ 
+        # Parse the fallback content
+        next(parser.stream)  # consume 'fallback'
+        parser.stream.expect("block_end")
+        fallback_names, fallback = self._parse_block(parser, False)
+        # The _parse_block method should have consumed the endctrans token
+ 
+        for name in fallback_names:
+            if name not in variables:
+                variables[name] = nodes.Name(name, "load")
+
+        if not have_plural:
+            plural_expr = None
+
+        if trimmed is None:
+            trimmed = self.environment.policies.get("ext.i18n.trimmed", False)
+        if trimmed:
+            singular = self._trim_whitespace(singular)
+            if plural:
+                plural = self._trim_whitespace(plural)
+            fallback = self._trim_whitespace(fallback)
+
+        # Create the conditional node
+        node = self._make_conditional_node(
+            condition, singular, plural, fallback, variables, plural_expr, have_plural
+        )
+        node.set_lineno(lineno)
+        return node
+
+    def _trim_whitespace(self, string: str, _ws_re: t.Pattern[str] = _ws_re) -> str:
+        return _ws_re.sub(" ", string.strip())
+
+    def _parse_block(
+        self, parser: "Parser", allow_pluralize: bool
+    ) -> t.Tuple[t.List[str], str]:
+        """Parse until the next block tag with a given name."""
+        referenced = []
+        buf = []
+
+        while True:
+            if parser.stream.current.type == "data":
+                buf.append(parser.stream.current.value.replace("%", "%%"))
+                next(parser.stream)
+            elif parser.stream.current.type == "variable_begin":
+                next(parser.stream)
+                name = parser.stream.expect("name").value
+                referenced.append(name)
+                buf.append(f"%({name})s")
+                parser.stream.expect("variable_end")
+            elif parser.stream.current.type == "block_begin":
+                next(parser.stream)
+                if parser.stream.current.test("name:endctrans"):
+                    next(parser.stream)  # consume 'endctrans'
+                    break
+                elif parser.stream.current.test("name:pluralize"):
+                    if allow_pluralize:
+                        break
+                    parser.fail(
+                        "a translatable section can have only one pluralize section"
+                    )
+                elif parser.stream.current.test("name:fallback"):
+                    break
+                parser.fail(
+                    "control structures in translatable sections are not allowed"
+                )
+            elif parser.stream.eos:
+                parser.fail("unclosed conditional translation block")
+            else:
+                raise RuntimeError("internal parser error")
+
+        return referenced, concat(buf)
+
+    def _make_conditional_node(
+        self,
+        condition: nodes.Expr,
+        singular: str,
+        plural: t.Optional[str],
+        fallback: str,
+        variables: t.Dict[str, nodes.Expr],
+        plural_expr: t.Optional[nodes.Expr],
+        have_plural: bool,
+    ) -> nodes.If:
+        """Generate a conditional node that renders translation or fallback."""
+        # Create translation node (similar to I18nExtension)
+        newstyle = getattr(self.environment, "newstyle_gettext", False)
+ 
+        # Create singular translation
+        if plural_expr is None:
+            gettext = nodes.Name("gettext", "load")
+            trans_node = nodes.Call(gettext, [nodes.Const(singular)], [], None, None)
+        else:
+            ngettext = nodes.Name("ngettext", "load")
+            trans_node = nodes.Call(
+                ngettext,
+                [nodes.Const(singular), nodes.Const(plural), plural_expr],
+                [],
+                None,
+                None,
+            )
+
+        # Handle newstyle gettext
+        if newstyle:
+            for key, value in variables.items():
+                if have_plural and key == "num":
+                    continue
+                trans_node.kwargs.append(nodes.Keyword(key, value))
+        else:
+            trans_node = nodes.MarkSafeIfAutoescape(trans_node)
+            if variables:
+                trans_node = nodes.Mod(
+                    trans_node,
+                    nodes.Dict(
+                        [
+                            nodes.Pair(nodes.Const(key), value)
+                            for key, value in variables.items()
+                        ]
+                    ),
+                )
+
+        # Create fallback node (simple template rendering)
+        fallback_node = nodes.TemplateData(fallback)
+        if variables:
+            # Apply variable substitution to fallback as well
+            fallback_dict = nodes.Dict(
+                [
+                    nodes.Pair(nodes.Const(key), value)
+                    for key, value in variables.items()
+                ]
+            )
+            fallback_formatted = nodes.Mod(nodes.Const(fallback), fallback_dict)
+            fallback_node = fallback_formatted
+
+        # Create conditional structure
+        if_node = nodes.If(
+            condition,
+            [nodes.Output([trans_node])],
+            [],  # elif_ - empty list for no elif blocks
+            [nodes.Output([fallback_node])],
+        )
+ 
+        return if_node
+
+
 #: nicer import names
 i18n = InternationalizationExtension
 do = ExprStmtExtension
 loopcontrols = LoopControlExtension
 debug = DebugExtension
+conditional_i18n = ConditionalI18nExtension
