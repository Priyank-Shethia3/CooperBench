diff --git a/src/jinja2/ext.py b/src/jinja2/ext.py
index d21b83aa..4ce9c54e 100644
--- a/src/jinja2/ext.py
+++ b/src/jinja2/ext.py
@@ -181,6 +181,29 @@ def _make_new_gettext(func: t.Callable[[str], str]) -> t.Callable[..., str]:
     return gettext
 
 
+def _make_new_gettext_with_fallback(
+    func: t.Callable[[str], str], fallback_funcs: t.List[t.Callable[[str], str]]
+) -> t.Callable[..., str]:
+    @pass_context
+    def gettext(__context: Context, __string: str, **variables: t.Any) -> str:
+        # Try primary translation first
+        rv = __context.call(func, __string)
+ 
+        # If translation is the same as the original string, try fallbacks
+        if rv == __string and fallback_funcs:
+            for fallback_func in fallback_funcs:
+                fallback_rv = __context.call(fallback_func, __string)
+                if fallback_rv != __string:
+                    rv = fallback_rv
+                    break
+ 
+        if __context.eval_ctx.autoescape:
+            rv = Markup(rv)
+        return rv % variables  # type: ignore
+
+    return gettext
+
+
 def _make_new_ngettext(func: t.Callable[[str, str, int], str]) -> t.Callable[..., str]:
     @pass_context
     def ngettext(
@@ -200,6 +223,39 @@ def _make_new_ngettext(func: t.Callable[[str, str, int], str]) -> t.Callable[...
     return ngettext
 
 
+def _make_new_ngettext_with_fallback(
+    func: t.Callable[[str, str, int], str], 
+    fallback_funcs: t.List[t.Callable[[str, str, int], str]]
+) -> t.Callable[..., str]:
+    @pass_context
+    def ngettext(
+        __context: Context,
+        __singular: str,
+        __plural: str,
+        __num: int,
+        **variables: t.Any,
+    ) -> str:
+        variables.setdefault("num", __num)
+ 
+        # Try primary translation first
+        rv = __context.call(func, __singular, __plural, __num)
+ 
+        # If translation is the same as the original string, try fallbacks
+        expected = __singular if __num == 1 else __plural
+        if rv == expected and fallback_funcs:
+            for fallback_func in fallback_funcs:
+                fallback_rv = __context.call(fallback_func, __singular, __plural, __num)
+                if fallback_rv != expected:
+                    rv = fallback_rv
+                    break
+ 
+        if __context.eval_ctx.autoescape:
+            rv = Markup(rv)
+        return rv % variables  # type: ignore
+
+    return ngettext
+
+
 def _make_new_pgettext(func: t.Callable[[str, str], str]) -> t.Callable[..., str]:
     @pass_context
     def pgettext(
@@ -261,6 +317,7 @@ class InternationalizationExtension(Extension):
             install_gettext_translations=self._install,
             install_null_translations=self._install_null,
             install_gettext_callables=self._install_callables,
+            install_gettext_callables_with_fallback=self._install_callables_with_fallback,
             uninstall_gettext_translations=self._uninstall,
             extract_translations=self._extract,
             newstyle_gettext=False,
@@ -336,6 +393,56 @@ class InternationalizationExtension(Extension):
             gettext=gettext, ngettext=ngettext, pgettext=pgettext, npgettext=npgettext
         )
 
+    def _install_callables_with_fallback(
+        self,
+        gettext: t.Callable[[str], str],
+        ngettext: t.Callable[[str, str, int], str],
+        fallback_gettext_funcs: t.Optional[t.List[t.Callable[[str], str]]] = None,
+        fallback_ngettext_funcs: t.Optional[t.List[t.Callable[[str, str, int], str]]] = None,
+        newstyle: t.Optional[bool] = None,
+        pgettext: t.Optional[t.Callable[[str, str], str]] = None,
+        npgettext: t.Optional[t.Callable[[str, str, str, int], str]] = None,
+    ) -> None:
+        """Install gettext callables with fallback language support.
+ 
+        :param gettext: Primary gettext function
+        :param ngettext: Primary ngettext function  
+        :param fallback_gettext_funcs: List of fallback gettext functions to try in order
+        :param fallback_ngettext_funcs: List of fallback ngettext functions to try in order
+        :param newstyle: Whether to use newstyle gettext
+        :param pgettext: Context-aware gettext function (optional)
+        :param npgettext: Context-aware ngettext function (optional)
+        """
+        if newstyle is not None:
+            self.environment.newstyle_gettext = newstyle  # type: ignore
+ 
+        # Use fallback-enabled functions if fallbacks are provided
+        if fallback_gettext_funcs:
+            if self.environment.newstyle_gettext:  # type: ignore
+                gettext = _make_new_gettext_with_fallback(gettext, fallback_gettext_funcs)
+            # For old-style, we'd need to implement fallback wrappers too, but keeping it simple for now
+        else:
+            if self.environment.newstyle_gettext:  # type: ignore
+                gettext = _make_new_gettext(gettext)
+ 
+        if fallback_ngettext_funcs:
+            if self.environment.newstyle_gettext:  # type: ignore
+                ngettext = _make_new_ngettext_with_fallback(ngettext, fallback_ngettext_funcs)
+        else:
+            if self.environment.newstyle_gettext:  # type: ignore
+                ngettext = _make_new_ngettext(ngettext)
+
+        # Handle pgettext and npgettext (no fallback support for now to keep it simple)
+        if self.environment.newstyle_gettext:  # type: ignore
+            if pgettext is not None:
+                pgettext = _make_new_pgettext(pgettext)
+            if npgettext is not None:
+                npgettext = _make_new_npgettext(npgettext)
+
+        self.environment.globals.update(
+            gettext=gettext, ngettext=ngettext, pgettext=pgettext, npgettext=npgettext
+        )
+
     def _uninstall(self, translations: "_SupportedTranslations") -> None:
         for key in ("gettext", "ngettext", "pgettext", "npgettext"):
             self.environment.globals.pop(key, None)
