diff --git a/src/jinja2/ext.py b/src/jinja2/ext.py
index d21b83aa..ce924a73 100644
--- a/src/jinja2/ext.py
+++ b/src/jinja2/ext.py
@@ -332,8 +332,27 @@ class InternationalizationExtension(Extension):
             if npgettext is not None:
                 npgettext = _make_new_npgettext(npgettext)
 
+        # Get existing domain-aware functions or create fallback ones
+        existing_dgettext = self.environment.globals.get('dgettext')
+        existing_dngettext = self.environment.globals.get('dngettext')
+ 
+        def dgettext(domain: str, message: str) -> str:
+            # Use existing domain-aware function if available
+            if existing_dgettext:
+                return existing_dgettext(domain, message)
+            # Fallback to regular gettext if no domain support
+            return gettext(message)
+ 
+        def dngettext(domain: str, singular: str, plural: str, n: int) -> str:
+            # Use existing domain-aware function if available
+            if existing_dngettext:
+                return existing_dngettext(domain, singular, plural, n)
+            # Fallback to regular ngettext if no domain support
+            return ngettext(singular, plural, n)
+
         self.environment.globals.update(
-            gettext=gettext, ngettext=ngettext, pgettext=pgettext, npgettext=npgettext
+            gettext=gettext, ngettext=ngettext, pgettext=pgettext, npgettext=npgettext,
+            dgettext=dgettext, dngettext=dngettext
         )
 
     def _uninstall(self, translations: "_SupportedTranslations") -> None:
@@ -363,8 +382,9 @@ class InternationalizationExtension(Extension):
         plural_expr_assignment: t.Optional[nodes.Assign] = None
         variables: t.Dict[str, nodes.Expr] = {}
         trimmed = None
+        domain: t.Optional[str] = None
         while parser.stream.current.type != "block_end":
-            if variables:
+            if variables or domain is not None:
                 parser.stream.expect("comma")
 
             # skip colon for python compatibility
@@ -372,6 +392,26 @@ class InternationalizationExtension(Extension):
                 break
 
             token = parser.stream.expect("name")
+ 
+            # Handle domain parameter
+            if token.value == "domain":
+                if domain is not None:
+                    parser.fail(
+                        "domain parameter defined twice.",
+                        token.lineno,
+                        exc=TemplateAssertionError,
+                    )
+                parser.stream.expect("assign")
+                domain_expr = parser.parse_expression()
+                if not isinstance(domain_expr, nodes.Const) or not isinstance(domain_expr.value, str):
+                    parser.fail(
+                        "domain parameter must be a string literal.",
+                        token.lineno,
+                        exc=TemplateAssertionError,
+                    )
+                domain = domain_expr.value
+                continue
+ 
             if token.value in variables:
                 parser.fail(
                     f"translatable variable {token.value!r} defined twice.",
@@ -459,6 +499,7 @@ class InternationalizationExtension(Extension):
             plural_expr,
             bool(referenced),
             num_called_num and have_plural,
+            domain,
         )
         node.set_lineno(lineno)
         if plural_expr_assignment is not None:
@@ -514,6 +555,7 @@ class InternationalizationExtension(Extension):
         plural_expr: t.Optional[nodes.Expr],
         vars_referenced: bool,
         num_called_num: bool,
+        domain: t.Optional[str] = None,
     ) -> nodes.Output:
         """Generates a useful node from the data provided."""
         newstyle = self.environment.newstyle_gettext  # type: ignore
@@ -528,19 +570,35 @@ class InternationalizationExtension(Extension):
 
         # singular only:
         if plural_expr is None:
-            gettext = nodes.Name("gettext", "load")
-            node = nodes.Call(gettext, [nodes.Const(singular)], [], None, None)
+            if domain is not None:
+                # Use dgettext for domain-specific translation
+                dgettext = nodes.Name("dgettext", "load")
+                node = nodes.Call(dgettext, [nodes.Const(domain), nodes.Const(singular)], [], None, None)
+            else:
+                gettext = nodes.Name("gettext", "load")
+                node = nodes.Call(gettext, [nodes.Const(singular)], [], None, None)
 
         # singular and plural
         else:
-            ngettext = nodes.Name("ngettext", "load")
-            node = nodes.Call(
-                ngettext,
-                [nodes.Const(singular), nodes.Const(plural), plural_expr],
-                [],
-                None,
-                None,
-            )
+            if domain is not None:
+                # Use dngettext for domain-specific plural translation
+                dngettext = nodes.Name("dngettext", "load")
+                node = nodes.Call(
+                    dngettext,
+                    [nodes.Const(domain), nodes.Const(singular), nodes.Const(plural), plural_expr],
+                    [],
+                    None,
+                    None,
+                )
+            else:
+                ngettext = nodes.Name("ngettext", "load")
+                node = nodes.Call(
+                    ngettext,
+                    [nodes.Const(singular), nodes.Const(plural), plural_expr],
+                    [],
+                    None,
+                    None,
+                )
 
         # in case newstyle gettext is used, the method is powerful
         # enough to handle the variable expansion and autoescape

