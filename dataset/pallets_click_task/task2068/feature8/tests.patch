diff --git a/tests/test_termui.py b/tests/test_termui.py
index 8fdfe8d..246894f 100644
--- a/tests/test_termui.py
+++ b/tests/test_termui.py
@@ -380,6 +380,214 @@ def test_fast_edit(runner):
     assert result == "aTest\nbTest\n"
 
 
+@pytest.mark.skipif(
+    platform.system() == "Windows", reason="Process groups work differently on Windows."
+)
+def test_edit_process_group_subprocess_call(runner, monkeypatch):
+    """Test that process_group affects subprocess.Popen call on Unix."""
+    import subprocess
+    from click._termui_impl import Editor
+
+    popen_calls = []
+
+    def mock_popen(*args, **kwargs):
+        popen_calls.append(kwargs)
+        # Mock a successful process
+        mock_process = type(
+            "MockProcess", (), {"wait": lambda self: 0, "returncode": 0}
+        )()
+        return mock_process
+
+    monkeypatch.setattr(subprocess, "Popen", mock_popen)
+
+    # Test with process_group=True on Unix
+    editor = Editor(editor="echo", process_group=True)
+    editor.edit_file("test.txt")
+
+    assert len(popen_calls) == 1
+    assert "preexec_fn" in popen_calls[0]
+    # On Unix systems, preexec_fn should be os.setpgrp when process_group=True
+    import os
+
+    if hasattr(os, "setpgrp"):
+        assert popen_calls[0]["preexec_fn"] == os.setpgrp
+
+    # Test with process_group=False
+    popen_calls.clear()
+    editor = Editor(editor="echo", process_group=False)
+    editor.edit_file("test.txt")
+
+    assert len(popen_calls) == 1
+    assert popen_calls[0].get("preexec_fn") is None
+
+
+@pytest.mark.skipif(
+    platform.system() == "Windows", reason="Process groups work differently on Windows."
+)
+def test_edit_process_group_actual_separation(runner, monkeypatch):
+    """Test that editor process actually runs in a different process group."""
+    import subprocess
+    import tempfile
+    import os
+    import signal
+    from click._termui_impl import Editor
+
+    # Create a test script that reports its process group and exits
+    test_script = """#!/usr/bin/env python3
+import os
+import sys
+print(f"EDITOR_PGID:{os.getpgrp()}")
+sys.exit(0)
+"""
+
+    with tempfile.NamedTemporaryFile(mode="w", suffix=".py", delete=False) as f:
+        f.write(test_script)
+        script_path = f.name
+
+    try:
+        os.chmod(script_path, 0o755)
+
+        # Get current process group
+        current_pgid = os.getpgrp()
+
+        # Test with process_group=True - should create new process group
+        editor = Editor(editor=f"python3 {script_path}", process_group=True)
+
+        # Capture the output to check the process group
+        original_popen = subprocess.Popen
+        captured_output = []
+
+        def capture_popen(*args, **kwargs):
+            # Run the actual command and capture output
+            kwargs["stdout"] = subprocess.PIPE
+            kwargs["stderr"] = subprocess.STDOUT
+            kwargs["text"] = True
+            proc = original_popen(*args, **kwargs)
+            output, _ = proc.communicate()
+            captured_output.append(output)
+            # Return a mock that simulates successful completion
+            mock_proc = type(
+                "MockProcess", (), {"wait": lambda self: 0, "returncode": 0}
+            )()
+            return mock_proc
+
+        monkeypatch.setattr(subprocess, "Popen", capture_popen)
+
+        # Create a temporary file for editing
+        with tempfile.NamedTemporaryFile(mode="w", delete=False) as temp_file:
+            temp_file.write("test content")
+            temp_filename = temp_file.name
+
+        try:
+            editor.edit_file(temp_filename)
+
+            # Check that we captured output and it shows a different process group
+            assert len(captured_output) == 1
+            output = captured_output[0]
+            assert "EDITOR_PGID:" in output
+
+            # Extract the process group ID from output
+            for line in output.split("\n"):
+                if line.startswith("EDITOR_PGID:"):
+                    editor_pgid = int(line.split(":")[1])
+                    # When process_group=True, editor should be in different process group
+                    assert editor_pgid != current_pgid, (
+                        f"Editor PGID {editor_pgid} should differ from current PGID {current_pgid}"
+                    )
+                    break
+            else:
+                pytest.fail("Could not find EDITOR_PGID in output")
+
+        finally:
+            os.unlink(temp_filename)
+
+    finally:
+        os.unlink(script_path)
+
+
+@pytest.mark.skipif(
+    platform.system() == "Windows", reason="Process groups work differently on Windows."
+)
+def test_edit_process_group_same_group_when_disabled(runner, monkeypatch):
+    """Test that editor process runs in same process group when process_group=False."""
+    import subprocess
+    import tempfile
+    import os
+    from click._termui_impl import Editor
+
+    # Create a test script that reports its process group and exits
+    test_script = """#!/usr/bin/env python3
+import os
+import sys
+print(f"EDITOR_PGID:{os.getpgrp()}")
+sys.exit(0)
+"""
+
+    with tempfile.NamedTemporaryFile(mode="w", suffix=".py", delete=False) as f:
+        f.write(test_script)
+        script_path = f.name
+
+    try:
+        os.chmod(script_path, 0o755)
+
+        # Get current process group
+        current_pgid = os.getpgrp()
+
+        # Test with process_group=False - should use same process group
+        editor = Editor(editor=f"python3 {script_path}", process_group=False)
+
+        # Capture the output to check the process group
+        original_popen = subprocess.Popen
+        captured_output = []
+
+        def capture_popen(*args, **kwargs):
+            # Run the actual command and capture output
+            kwargs["stdout"] = subprocess.PIPE
+            kwargs["stderr"] = subprocess.STDOUT
+            kwargs["text"] = True
+            proc = original_popen(*args, **kwargs)
+            output, _ = proc.communicate()
+            captured_output.append(output)
+            # Return a mock that simulates successful completion
+            mock_proc = type(
+                "MockProcess", (), {"wait": lambda self: 0, "returncode": 0}
+            )()
+            return mock_proc
+
+        monkeypatch.setattr(subprocess, "Popen", capture_popen)
+
+        # Create a temporary file for editing
+        with tempfile.NamedTemporaryFile(mode="w", delete=False) as temp_file:
+            temp_file.write("test content")
+            temp_filename = temp_file.name
+
+        try:
+            editor.edit_file(temp_filename)
+
+            # Check that we captured output and it shows the same process group
+            assert len(captured_output) == 1
+            output = captured_output[0]
+            assert "EDITOR_PGID:" in output
+
+            # Extract the process group ID from output
+            for line in output.split("\n"):
+                if line.startswith("EDITOR_PGID:"):
+                    editor_pgid = int(line.split(":")[1])
+                    # When process_group=False, editor should be in same process group
+                    assert editor_pgid == current_pgid, (
+                        f"Editor PGID {editor_pgid} should match current PGID {current_pgid}"
+                    )
+                    break
+            else:
+                pytest.fail("Could not find EDITOR_PGID in output")
+
+        finally:
+            os.unlink(temp_filename)
+
+    finally:
+        os.unlink(script_path)
+
+
 @pytest.mark.parametrize(
     ("prompt_required", "required", "args", "expect"),
     [
