diff --git a/tests/test_termui.py b/tests/test_termui.py
index 8fdfe8d..a1b2c3d 100644
--- a/tests/test_termui.py
+++ b/tests/test_termui.py
@@ -1,3 +1,4 @@
+import os
 import platform
 import time
 
@@ -470,3 +471,124 @@ def test_false_show_default_cause_no_default_display_in_prompt(runner):
     # is False
     result = runner.invoke(cmd, input="my-input", standalone_mode=False)
     assert "my-default-value" not in result.output
+
+
+# Auto-backup tests
+def test_edit_auto_backup_disabled_by_default(runner, tmp_path):
+    """Test that auto_backup is disabled by default and no backup is created."""
+    test_file = tmp_path / "test.txt"
+    test_file.write_text("original content")
+
+    # Edit with a no-op editor (cat does nothing destructive)
+    click.edit(filename=str(test_file), editor="cat")
+
+    # No backup should be created
+    backup_files = list(tmp_path.glob("test.txt.backup.*"))
+    assert len(backup_files) == 0
+
+
+def test_edit_auto_backup_creates_backup(runner, tmp_path):
+    """Test that auto_backup=True creates a timestamped backup file."""
+    test_file = tmp_path / "test.txt"
+    original_content = "original content\nline 2"
+    test_file.write_text(original_content)
+
+    # Edit with auto_backup enabled
+    click.edit(filename=str(test_file), editor="cat", auto_backup=True)
+
+    # Backup should be created
+    backup_files = list(tmp_path.glob("test.txt.backup.*"))
+    assert len(backup_files) == 1
+
+    backup_file = backup_files[0]
+    # Check backup filename format (should be test.txt.backup.YYYYMMDD_HHMMSS)
+    import re
+
+    assert re.match(r"test\.txt\.backup\.\d{8}_\d{6}", backup_file.name)
+
+    # Check backup content matches original
+    assert backup_file.read_text() == original_content
+
+
+def test_edit_auto_backup_preserves_permissions(runner, tmp_path):
+    """Test that backup files preserve original file permissions."""
+    import stat
+
+    test_file = tmp_path / "test.txt"
+    test_file.write_text("content")
+
+    # Set specific permissions
+    original_mode = 0o644
+    test_file.chmod(original_mode)
+
+    click.edit(filename=str(test_file), editor="cat", auto_backup=True)
+
+    backup_files = list(tmp_path.glob("test.txt.backup.*"))
+    backup_file = backup_files[0]
+
+    # Check permissions are preserved (shutil.copy2 should preserve metadata)
+    backup_mode = stat.S_IMODE(backup_file.stat().st_mode)
+    assert backup_mode == original_mode
+
+
+def test_edit_auto_backup_nonexistent_file(runner, tmp_path):
+    """Test that no backup is created for non-existent files."""
+    nonexistent_file = tmp_path / "does_not_exist.txt"
+
+    try:
+        os.remove(nonexistent_file)
+    except OSError:
+        pass
+
+    try:
+        click.edit(filename=str(nonexistent_file), editor="cat", auto_backup=True)
+    except click.ClickException:
+        pass
+
+    # No backup should be created
+    backup_files = list(tmp_path.glob("does_not_exist.txt.backup.*"))
+    assert len(backup_files) == 0
+
+
+def test_edit_auto_backup_backup_failure(runner, tmp_path, monkeypatch):
+    """Test that backup failure raises appropriate exception."""
+    test_file = tmp_path / "test.txt"
+    test_file.write_text("content")
+
+    # Mock multiple shutil functions to raise an exception (implementation agnostic)
+    def mock_copy_operation(*args, **kwargs):
+        raise OSError("Permission denied")
+
+    monkeypatch.setattr("shutil.copy2", mock_copy_operation)
+    monkeypatch.setattr("shutil.copyfile", mock_copy_operation)
+    monkeypatch.setattr("shutil.copy", mock_copy_operation)
+
+    # Should raise ClickException about backup failure
+    with pytest.raises(click.ClickException, match="Failed to create backup file"):
+        click.edit(filename=str(test_file), editor="cat", auto_backup=True)
+
+
+def test_edit_auto_backup_multiple_backups(runner, tmp_path):
+    """Test that multiple edits create multiple backup files."""
+    test_file = tmp_path / "test.txt"
+    test_file.write_text("content v1")
+
+    # First edit
+    click.edit(filename=str(test_file), editor="cat", auto_backup=True)
+
+    # Modify file
+    test_file.write_text("content v2")
+
+    # Second edit (after a small delay to ensure different timestamp)
+    import time
+
+    time.sleep(1)
+    click.edit(filename=str(test_file), editor="cat", auto_backup=True)
+
+    # Should have two backup files
+    backup_files = list(tmp_path.glob("test.txt.backup.*"))
+    assert len(backup_files) == 2
+
+    # Timestamps should be different
+    backup_names = [f.name for f in backup_files]
+    assert len(set(backup_names)) == 2
