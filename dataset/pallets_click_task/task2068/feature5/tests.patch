diff --git a/tests/test_termui.py b/tests/test_termui.py
index 8fdfe8d..1da3a45 100644
--- a/tests/test_termui.py
+++ b/tests/test_termui.py
@@ -1,8 +1,13 @@
+import os
 import platform
+import tempfile
 import time
+import re
+import threading
 
 import pytest
 
+import click
 import click._termui_impl
 from click._compat import WIN
 
@@ -35,10 +40,7 @@ def test_progressbar_strip_regression(runner, monkeypatch):
                 pass
 
     monkeypatch.setattr(click._termui_impl, "isatty", lambda _: True)
-    assert (
-        label
-        in runner.invoke(cli, [], standalone_mode=False, catch_exceptions=False).output
-    )
+    assert label in runner.invoke(cli, [], standalone_mode=False, catch_exceptions=False).output
 
 
 def test_progressbar_length_hint(runner, monkeypatch):
@@ -137,9 +139,7 @@ def test_progressbar_format_pos(runner, pos, length):
     ],
 )
 def test_progressbar_format_bar(runner, length, finished, pos, avg, expected):
-    with _create_progress(
-        length, width=8, pos=pos, finished=finished, avg=[avg]
-    ) as progress:
+    with _create_progress(length, width=8, pos=pos, finished=finished, avg=[avg]) as progress:
         assert progress.format_bar() == expected
 
 
@@ -153,9 +153,7 @@ def test_progressbar_format_bar(runner, length, finished, pos, avg, expected):
         (8, True, True, 8, "  [########]  8/8  100%"),
     ],
 )
-def test_progressbar_format_progress_line(
-    runner, length, show_percent, show_pos, pos, expected
-):
+def test_progressbar_format_progress_line(runner, length, show_percent, show_pos, pos, expected):
     with _create_progress(
         length,
         width=8,
@@ -171,9 +169,7 @@ def test_progressbar_format_progress_line_with_show_func(runner, test_item):
     def item_show_func(item):
         return item
 
-    with _create_progress(
-        item_show_func=item_show_func, current_item=test_item
-    ) as progress:
+    with _create_progress(item_show_func=item_show_func, current_item=test_item) as progress:
         if test_item:
             assert progress.format_progress_line().endswith(test_item)
         else:
@@ -209,9 +205,7 @@ def test_progressbar_is_iterator(runner, monkeypatch):
 
 def test_choices_list_in_prompt(runner, monkeypatch):
     @click.command()
-    @click.option(
-        "-g", type=click.Choice(["none", "day", "week", "month"]), prompt=True
-    )
+    @click.option("-g", type=click.Choice(["none", "day", "week", "month"]), prompt=True)
     def cli_with_choices(g):
         pass
 
@@ -232,9 +226,7 @@ def test_choices_list_in_prompt(runner, monkeypatch):
     assert "(none, day, week, month)" not in result.output
 
 
-@pytest.mark.parametrize(
-    "file_kwargs", [{"mode": "rt"}, {"mode": "rb"}, {"lazy": True}]
-)
+@pytest.mark.parametrize("file_kwargs", [{"mode": "rt"}, {"mode": "rb"}, {"lazy": True}])
 def test_file_prompt_default_format(runner, file_kwargs):
     @click.command()
     @click.option("-f", default=__file__, prompt="file", type=click.File(**file_kwargs))
@@ -253,9 +245,7 @@ def test_secho(runner):
 
 
 @pytest.mark.skipif(platform.system() == "Windows", reason="No style on Windows.")
-@pytest.mark.parametrize(
-    ("value", "expect"), [(123, b"\x1b[45m123\x1b[0m"), (b"test", b"test")]
-)
+@pytest.mark.parametrize(("value", "expect"), [(123, b"\x1b[45m123\x1b[0m"), (b"test", b"test")])
 def test_secho_non_text(runner, value, expect):
     with runner.isolation() as (out, _, _):
         click.secho(value, nl=False, color=True, bg="magenta")
@@ -310,9 +300,7 @@ def test_progressbar_item_show_func(runner, monkeypatch):
 def test_progressbar_update_with_item_show_func(runner, monkeypatch):
     @click.command()
     def cli():
-        with click.progressbar(
-            length=6, item_show_func=lambda x: f"Custom {x}"
-        ) as progress:
+        with click.progressbar(length=6, item_show_func=lambda x: f"Custom {x}") as progress:
             while not progress.finished:
                 progress.update(2, progress.pos)
                 click.echo()
@@ -347,24 +335,16 @@ def test_getchar_windows(runner, monkeypatch, key_char, echo):
     assert click.getchar(echo) == key_char
 
 
-@pytest.mark.parametrize(
-    "special_key_char, key_char", [("\x00", "a"), ("\x00", "b"), ("\xe0", "c")]
-)
-@pytest.mark.skipif(
-    not WIN, reason="Tests special character inputs using the msvcrt module."
-)
+@pytest.mark.parametrize("special_key_char, key_char", [("\x00", "a"), ("\x00", "b"), ("\xe0", "c")])
+@pytest.mark.skipif(not WIN, reason="Tests special character inputs using the msvcrt module.")
 def test_getchar_special_key_windows(runner, monkeypatch, special_key_char, key_char):
     ordered_inputs = [key_char, special_key_char]
-    monkeypatch.setattr(
-        click._termui_impl.msvcrt, "getwch", lambda: ordered_inputs.pop()
-    )
+    monkeypatch.setattr(click._termui_impl.msvcrt, "getwch", lambda: ordered_inputs.pop())
     monkeypatch.setattr(click.termui, "_getchar", None)
     assert click.getchar() == f"{special_key_char}{key_char}"
 
 
-@pytest.mark.parametrize(
-    ("key_char", "exc"), [("\x03", KeyboardInterrupt), ("\x1a", EOFError)]
-)
+@pytest.mark.parametrize(("key_char", "exc"), [("\x03", KeyboardInterrupt), ("\x1a", EOFError)])
 @pytest.mark.skipif(not WIN, reason="Tests user-input using the msvcrt module.")
 def test_getchar_windows_exceptions(runner, monkeypatch, key_char, exc):
     monkeypatch.setattr(click._termui_impl.msvcrt, "getwch", lambda: key_char)
@@ -470,3 +450,202 @@ def test_false_show_default_cause_no_default_display_in_prompt(runner):
     # is False
     result = runner.invoke(cmd, input="my-input", standalone_mode=False)
     assert "my-default-value" not in result.output
+
+
+# Lock file tests
+def _get_temp_file():
+    """Helper function to create a temporary file."""
+    with tempfile.NamedTemporaryFile(mode="w", delete=False, suffix=".txt") as f:
+        f.write("test content")
+        return f.name
+
+
+def _check_lock_file_exists(temp_file):
+    """Check if the lock file exists for the given temp file."""
+    lock_file = f".{os.path.basename(temp_file)}.lock"
+    lock_path = os.path.join(os.path.dirname(temp_file), lock_file)
+    return os.path.exists(lock_path)
+
+
+def test_edit_lock_files_disabled_by_default():
+    """Test that lock files are disabled by default."""
+    temp_file = _get_temp_file()
+    try:
+        click.edit(filename=temp_file, editor="true")
+        assert not _check_lock_file_exists(temp_file)
+    finally:
+        os.unlink(temp_file)
+
+
+def test_edit_lock_files_cleanup():
+    """Test that lock files are cleaned up no matter if editor succeeds."""
+    temp_file = _get_temp_file()
+
+    try:
+        click.edit(filename=temp_file, editor="true", lock_files=True)
+        assert not _check_lock_file_exists(temp_file)
+
+        with pytest.raises(click.ClickException, match="Editing failed"):
+            click.edit(filename=temp_file, editor="false", lock_files=True)
+        assert not _check_lock_file_exists(temp_file)
+    finally:
+        if os.path.exists(temp_file):
+            os.unlink(temp_file)
+
+
+def _find_lock_file(temp_file):
+    """Helper to find lock file for a given file."""
+    directory = os.path.dirname(temp_file)
+    basename = os.path.basename(temp_file)
+    lock_name = f".{basename}.lock"
+    lock_path = os.path.join(directory, lock_name)
+    return lock_path if os.path.exists(lock_path) else None
+
+
+def test_edit_lock_files_content_format():
+    """Test that lock files contain proper process information during actual editing."""
+    temp_file = _get_temp_file()
+
+    try:
+        # Use a custom editor that sleeps briefly so we can inspect the lock file
+        custom_editor = 'python -c "import time; time.sleep(0.1)" && true'
+
+        # Start editing in a separate thread so we can check lock file while editor runs
+        result = []
+
+        def edit_file():
+            try:
+                click.edit(filename=temp_file, editor=custom_editor, lock_files=True)
+                result.append("success")
+            except Exception as e:
+                result.append(f"error: {e}")
+
+        thread = threading.Thread(target=edit_file)
+        thread.start()
+
+        # Give editor time to start and create lock file
+        time.sleep(0.05)
+
+        # Find and verify lock file content
+        lock_file_path = _find_lock_file(temp_file)
+        assert lock_file_path is not None, "Lock file should exist during editing"
+
+        with open(lock_file_path) as f:
+            content = f.read()
+
+        # Verify content format
+        assert f"PID: {os.getpid()}" in content
+        assert "Time: " in content
+        assert re.search(r"Time: \d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}", content)
+
+        thread.join()
+
+        # Verify lock file is cleaned up
+        assert not os.path.exists(lock_file_path), "Lock file should be cleaned up"
+
+    finally:
+        if os.path.exists(temp_file):
+            os.unlink(temp_file)
+
+
+def test_edit_lock_files_concurrent_access_prevention():
+    """Test that lock files prevent concurrent editing using public API."""
+    temp_file = _get_temp_file()
+    results = []
+
+    def attempt_edit(delay, editor_cmd):
+        try:
+            time.sleep(delay)
+            click.edit(filename=temp_file, editor=editor_cmd, lock_files=True)
+            results.append("success")
+        except click.ClickException as e:
+            if "lock" in str(e).lower() or "editing" in str(e).lower():
+                results.append("blocked")
+            else:
+                results.append(f"other_error: {e}")
+
+    try:
+        # First editor sleeps for 0.2 seconds
+        thread1 = threading.Thread(target=attempt_edit, args=(0, "sleep 0.2 && true"))
+        # Second editor tries to start after 0.1 seconds
+        thread2 = threading.Thread(target=attempt_edit, args=(0.1, "true"))
+
+        thread1.start()
+        thread2.start()
+
+        thread1.join()
+        thread2.join()
+
+        # One should succeed, one should be blocked
+        assert len(results) == 2
+        assert "success" in results
+        assert "blocked" in results
+
+    finally:
+        if os.path.exists(temp_file):
+            os.unlink(temp_file)
+
+
+def test_edit_lock_files_naming_convention():
+    """Test that lock files follow the correct naming pattern."""
+    temp_file = _get_temp_file()
+    expected_lock = os.path.join(os.path.dirname(temp_file), f".{os.path.basename(temp_file)}.lock")
+
+    try:
+        # Use editor that sleeps so we can check lock file exists
+        custom_editor = "sleep 0.1 && true"
+
+        # Start editing in background
+        thread = threading.Thread(target=lambda: click.edit(filename=temp_file, editor=custom_editor, lock_files=True))
+        thread.start()
+
+        # Check lock file exists with correct name
+        time.sleep(0.05)
+        assert os.path.exists(expected_lock), f"Expected lock file at {expected_lock}"
+
+        thread.join()
+
+        # Verify cleanup
+        assert not os.path.exists(expected_lock), "Lock file should be cleaned up"
+
+    finally:
+        if os.path.exists(temp_file):
+            os.unlink(temp_file)
+
+
+def test_edit_lock_files_cleanup_on_editor_failure():
+    """Test that lock files are cleaned up even when editor fails."""
+    temp_file = _get_temp_file()
+
+    try:
+        # Use editor that will fail
+        with pytest.raises(click.ClickException, match="Editing failed"):
+            click.edit(filename=temp_file, editor="false", lock_files=True)
+
+        # Verify no lock file remains
+        lock_file = _find_lock_file(temp_file)
+        assert lock_file is None or not os.path.exists(lock_file), "Lock file should be cleaned up after editor failure"
+
+    finally:
+        if os.path.exists(temp_file):
+            os.unlink(temp_file)
+
+
+def test_edit_lock_files_different_directories():
+    """Test lock files work correctly in different directory structures."""
+    import tempfile
+
+    # Test in subdirectory
+    with tempfile.TemporaryDirectory() as temp_dir:
+        subdir = os.path.join(temp_dir, "subdir")
+        os.makedirs(subdir)
+        temp_file = os.path.join(subdir, "test.txt")
+
+        with open(temp_file, "w") as f:
+            f.write("test")
+
+        click.edit(filename=temp_file, editor="true", lock_files=True)
+
+        # Verify no lock file remains
+        expected_lock = os.path.join(subdir, ".test.txt.lock")
+        assert not os.path.exists(expected_lock)
