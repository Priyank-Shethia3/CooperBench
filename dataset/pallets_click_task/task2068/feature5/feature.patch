diff --git a/src/click/_termui_impl.py b/src/click/_termui_impl.py
index 7b97bfb..7635eed 100644
--- a/src/click/_termui_impl.py
+++ b/src/click/_termui_impl.py
@@ -485,11 +485,13 @@ class Editor:
         env: cabc.Mapping[str, str] | None = None,
         require_save: bool = True,
         extension: str = ".txt",
+        lock_files: bool = False,
     ) -> None:
         self.editor = editor
         self.env = env
         self.require_save = require_save
         self.extension = extension
+        self.lock_files = lock_files
 
     def get_editor(self) -> str:
         if self.editor is not None:
@@ -505,28 +507,119 @@ class Editor:
                 return editor
         return "vi"
 
-    def edit_file(self, filename: str) -> None:
-        import subprocess
+    def _get_lock_filename(self, filename: str) -> str:
+        """Generate lock filename for the given file."""
+        dir_name, base_name = os.path.split(filename)
+        lock_name = f".{base_name}.lock"
+        return os.path.join(dir_name, lock_name)
 
-        editor = self.get_editor()
-        environ: dict[str, str] | None = None
+    def _create_lock_file(self, filename: str) -> str:
+        """Create a lock file for the given filename."""
+        lock_filename = self._get_lock_filename(filename)
 
-        if self.env:
-            environ = os.environ.copy()
-            environ.update(self.env)
+        # Check if lock file already exists
+        if os.path.exists(lock_filename):
+            try:
+                with open(lock_filename) as f:
+                    lock_info = f.read().strip()
+                raise ClickException(
+                    _(
+                        "File is already being edited. Lock file exists: {lock_file}\n"
+                        "Lock info: {info}"
+                    ).format(lock_file=lock_filename, info=lock_info)
+                )
+            except OSError:
+                # Lock file exists but can't read it - treat as locked
+                raise ClickException(
+                    _(
+                        "File is already being edited. Lock file exists: {lock_file}"
+                    ).format(lock_file=lock_filename)
+                ) from None
 
+        # Create lock file with process info
         try:
-            c = subprocess.Popen(f'{editor} "{filename}"', env=environ, shell=True)
-            exit_code = c.wait()
-            if exit_code != 0:
-                raise ClickException(
-                    _("{editor}: Editing failed").format(editor=editor)
+            with open(lock_filename, "x") as f:
+                import datetime
+
+                lock_info = (
+                    f"PID: {os.getpid()}\nTime: {datetime.datetime.now().isoformat()}\n"
                 )
+                f.write(lock_info)
+        except FileExistsError:
+            # Race condition - another process created the lock file
+            raise ClickException(
+                _(
+                    "File is already being edited. Lock file was created by "
+                    "another process: {lock_file}"
+                ).format(lock_file=lock_filename)
+            ) from None
         except OSError as e:
             raise ClickException(
-                _("{editor}: Editing failed: {e}").format(editor=editor, e=e)
+                _("Failed to create lock file {lock_file}: {e}").format(
+                    lock_file=lock_filename, e=e
+                )
             ) from e
 
+        return lock_filename
+
+    def _remove_lock_file(self, lock_filename: str) -> None:
+        """Remove the lock file."""
+        try:
+            if os.path.exists(lock_filename):
+                os.unlink(lock_filename)
+        except OSError:
+            # Best effort cleanup - don't fail if we can't remove lock file
+            pass
+
+    @contextlib.contextmanager
+    def _lock_context(self, filename: str) -> t.Iterator[None]:
+        """Context manager for lock file handling."""
+        if not self.lock_files:
+            yield
+            return
+
+        lock_filename = self._create_lock_file(filename)
+        try:
+            yield
+        finally:
+            self._remove_lock_file(lock_filename)
+
+    def edit_file(self, filename: str, auto_backup: bool = False) -> None:
+        import shutil
+        import subprocess
+        from datetime import datetime
+
+        with self._lock_context(filename):
+            # Create backup if requested and file exists
+            if auto_backup and os.path.exists(filename):
+                try:
+                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
+                    backup_filename = f"{filename}.backup.{timestamp}"
+                    shutil.copy2(filename, backup_filename)
+                except OSError as e:
+                    raise ClickException(
+                        _("Failed to create backup file: {e}").format(e=e)
+                    ) from e
+
+            editor = self.get_editor()
+            environ: dict[str, str] | None = None
+
+            if self.env:
+                environ = os.environ.copy()
+                environ.update(self.env)
+
+            try:
+                c = subprocess.Popen(f'{editor} "{filename}"', env=environ, shell=True)
+                exit_code = c.wait()
+                if exit_code != 0:
+                    raise ClickException(
+                        _("{editor}: Editing failed").format(editor=editor)
+                    )
+            except OSError as e:
+                raise ClickException(
+                    _("{editor}: Editing failed: {e}").format(editor=editor, e=e)
+                ) from e
+
     def edit(self, text: t.AnyStr | None) -> t.AnyStr | None:
         import tempfile
 
diff --git a/src/click/termui.py b/src/click/termui.py
index e14e670..7f31e22 100644
--- a/src/click/termui.py
+++ b/src/click/termui.py
@@ -650,6 +650,7 @@ def edit(
     require_save: bool = True,
     extension: str = ".txt",
     filename: str | None = None,
+    lock_files: bool = False,
 ) -> t.AnyStr | None:
     r"""Edits the given text in the defined editor.  If an editor is given
     (should be the full path to the executable but the regular operating
@@ -677,10 +678,19 @@ def edit(
     :param filename: if provided it will edit this file instead of the
                      provided text contents.  It will not use a temporary
                      file as an indirection in that case.
+    :param lock_files: if set to `True`, creates a lock file to prevent
+                       concurrent edits when editing a file directly.
+                       Only applies when `filename` is provided.
     """
     from ._termui_impl import Editor
 
-    ed = Editor(editor=editor, env=env, require_save=require_save, extension=extension)
+    ed = Editor(
+        editor=editor,
+        env=env,
+        require_save=require_save,
+        extension=extension,
+        lock_files=lock_files,
+    )
 
     if filename is None:
         return ed.edit(text)
