diff --git a/src/click/_termui_impl.py b/src/click/_termui_impl.py
index 7b97bfb..7e67107 100644
--- a/src/click/_termui_impl.py
+++ b/src/click/_termui_impl.py
@@ -8,11 +8,13 @@ from __future__ import annotations
 
 import collections.abc as cabc
 import contextlib
+import inspect
 import math
 import os
 import sys
 import time
 import typing as t
+import warnings
 from gettext import gettext as _
 from io import StringIO
 from types import TracebackType
@@ -485,11 +487,59 @@ class Editor:
         env: cabc.Mapping[str, str] | None = None,
         require_save: bool = True,
         extension: str = ".txt",
+        monitor_process: t.Callable[[str, int, str, float], None] | None = None,
     ) -> None:
         self.editor = editor
         self.env = env
         self.require_save = require_save
         self.extension = extension
+        self.monitor_process = monitor_process
+ 
+        # Validate monitor_process callback signature if provided
+        if self.monitor_process is not None:
+            self._validate_monitor_callback()
+ 
+    def _validate_monitor_callback(self) -> None:
+        """Validate that the monitor_process callback has the correct signature."""
+        if self.monitor_process is None:
+            return
+ 
+        try:
+            sig = inspect.signature(self.monitor_process)
+            params = list(sig.parameters.keys())
+ 
+            # Expected signature: (event_type, process_id, editor_command, timestamp)
+            if len(params) != 4:
+                warnings.warn(
+                    f"monitor_process callback should accept 4 parameters "
+                    f"(event_type, process_id, editor_command, timestamp), "
+                    f"but got {len(params)} parameters: {params}. "
+                    f"The callback may not work correctly.",
+                    UserWarning,
+                    stacklevel=3
+                )
+        except (ValueError, TypeError) as e:
+            warnings.warn(
+                f"Could not validate monitor_process callback signature: {e}. "
+                f"The callback may not work correctly.",
+                UserWarning,
+                stacklevel=3
+            )
+ 
+    def _safe_monitor_callback(self, event_type: str, process_id: int, editor_command: str, timestamp: float) -> None:
+        """Safely call the monitor callback with proper error handling."""
+        if self.monitor_process is None:
+            return
+ 
+        try:
+            self.monitor_process(event_type, process_id, editor_command, timestamp)
+        except Exception as e:
+            warnings.warn(
+                f"monitor_process callback raised an exception: {e}. "
+                f"Process monitoring will continue but this callback invocation was skipped.",
+                UserWarning,
+                stacklevel=2
+            )
 
     def get_editor(self) -> str:
         if self.editor is not None:
@@ -507,6 +557,7 @@ class Editor:
 
     def edit_file(self, filename: str) -> None:
         import subprocess
+        import threading
 
         editor = self.get_editor()
         environ: dict[str, str] | None = None
@@ -517,7 +568,50 @@ class Editor:
 
         try:
             c = subprocess.Popen(f'{editor} "{filename}"', env=environ, shell=True)
+ 
+            # Start process monitoring if callback is provided
+            monitor_thread = None
+            if self.monitor_process:
+                def monitor_process_thread():
+                    # Notify process start
+                    self._safe_monitor_callback("start", c.pid, editor, time.time())
+ 
+                    # Monitor process state changes
+                    while c.poll() is None:
+                        try:
+                            # Check if process is suspended (Unix-like systems)
+                            if not WIN:
+                                try:
+                                    # Send signal 0 to check if process exists and is responsive
+                                    os.kill(c.pid, 0)
+                                    # Small delay to avoid busy waiting
+                                    time.sleep(0.1)
+                                except ProcessLookupError:
+                                    # Process has terminated
+                                    break
+                                except PermissionError:
+                                    # Process exists but we can't signal it
+                                    time.sleep(0.1)
+                            else:
+                                # On Windows, just wait a bit
+                                time.sleep(0.1)
+                        except Exception:
+                            # If monitoring fails, just continue
+                            time.sleep(0.1)
+ 
+                    # Notify process termination
+                    if c.poll() is not None:
+                        self._safe_monitor_callback("terminate", c.pid, editor, time.time())
+ 
+                monitor_thread = threading.Thread(target=monitor_process_thread, daemon=True)
+                monitor_thread.start()
+ 
             exit_code = c.wait()
+ 
+            # Wait for monitor thread to complete
+            if monitor_thread:
+                monitor_thread.join(timeout=1.0)
+ 
             if exit_code != 0:
                 raise ClickException(
                     _("{editor}: Editing failed").format(editor=editor)
diff --git a/src/click/termui.py b/src/click/termui.py
index e14e670..0551d22 100644
--- a/src/click/termui.py
+++ b/src/click/termui.py
@@ -650,6 +650,7 @@ def edit(
     require_save: bool = True,
     extension: str = ".txt",
     filename: str | None = None,
+    monitor_process: t.Callable[[str, int, str, float], None] | None = None,
 ) -> t.AnyStr | None:
     r"""Edits the given text in the defined editor.  If an editor is given
     (should be the full path to the executable but the regular operating
@@ -677,10 +678,18 @@ def edit(
     :param filename: if provided it will edit this file instead of the
                      provided text contents.  It will not use a temporary
                      file as an indirection in that case.
+    :param monitor_process: if provided, this callback function will be called
+                           with editor process events. The callback receives
+                           (event_type, process_id, editor_command, timestamp)
+                           where event_type is one of 'start', 'suspend', 
+                           'resume', 'terminate'.
+
+    .. versionadded:: 8.2
+        The ``monitor_process`` parameter.
     """
     from ._termui_impl import Editor
 
-    ed = Editor(editor=editor, env=env, require_save=require_save, extension=extension)
+    ed = Editor(editor=editor, env=env, require_save=require_save, extension=extension, monitor_process=monitor_process)
 
     if filename is None:
         return ed.edit(text)

