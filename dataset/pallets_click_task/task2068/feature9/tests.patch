diff --git a/tests/test_termui.py b/tests/test_termui.py
index 8fdfe8d..9cc8ac0 100644
--- a/tests/test_termui.py
+++ b/tests/test_termui.py
@@ -3,6 +3,7 @@ import time
 
 import pytest
 
+import click
 import click._termui_impl
 from click._compat import WIN
 
@@ -470,3 +471,178 @@ def test_false_show_default_cause_no_default_display_in_prompt(runner):
     # is False
     result = runner.invoke(cmd, input="my-input", standalone_mode=False)
     assert "my-default-value" not in result.output
+
+
+def test_edit_isolate_env_default(runner, monkeypatch):
+    """Test that isolate_env defaults to False and uses full environment."""
+    import subprocess
+
+    # Mock subprocess.Popen to capture the environment
+    captured_env = None
+
+    def mock_popen(cmd, env=None, shell=True):
+        nonlocal captured_env
+        captured_env = env
+        mock_process = type("MockProcess", (), {"wait": lambda self: 0})()
+        return mock_process
+
+    monkeypatch.setattr(subprocess, "Popen", mock_popen)
+
+    # Set test environment variables
+    monkeypatch.setenv("TEST_VAR", "test_value")
+    monkeypatch.setenv("GITHUB_TOKEN", "github_token")
+
+    # Test default behavior (isolate_env=False)
+    result = click.edit("test content", editor="echo")
+
+    # When isolate_env=False, either env=None (inherits parent env) or env contains all vars
+    # Both are valid implementations that achieve the same behavior
+    if captured_env is None:
+        # Implementation passes env=None, subprocess inherits full environment
+        # This is the expected behavior and we can't test the actual inherited env,
+        # but we can verify that no filtering was applied (env=None means no filtering)
+        assert True  # Test passes - this is correct behavior
+    else:
+        # Implementation explicitly passes environment dict
+        # Should include all environment variables including sensitive ones
+        assert "TEST_VAR" in captured_env
+        assert captured_env["TEST_VAR"] == "test_value"
+        assert "GITHUB_TOKEN" in captured_env
+        assert captured_env["GITHUB_TOKEN"] == "github_token"
+
+
+def test_edit_isolate_env_true_filters_sensitive_vars(runner, monkeypatch):
+    """Test that isolate_env=True filters out sensitive environment variables."""
+    import os
+    import subprocess
+
+    # Mock subprocess.Popen to capture the environment
+    captured_env = None
+
+    def mock_popen(cmd, env=None, shell=True):
+        nonlocal captured_env
+        captured_env = env
+        mock_process = type("MockProcess", (), {"wait": lambda self: 0})()
+        return mock_process
+
+    monkeypatch.setattr(subprocess, "Popen", mock_popen)
+
+    non_sensitive_env_vars = {
+        "PATH": "/usr/bin",
+        "HOME": "/home/user",
+        "NORMAL_VAR": "normal_value",
+        "USER": "testuser",
+        "TERM": "xterm-256color",
+        "LANG": "en_US.UTF-8",
+        "EDITOR": "vim",
+        "TMPDIR": "/tmp",
+    }
+
+    sensitive_env_vars = {
+        "API_KEY": "key",
+        "AWS_SECRET_ACCESS_KEY": "aws_secret",
+        "GITHUB_TOKEN": "github_token",
+        "api_key": "secret1",
+        "My_Token": "secret2",
+        "database_password": "some_normal_text"
+    }
+
+    # Set various environment variables
+    for key, value in non_sensitive_env_vars.items():
+        monkeypatch.setenv(key, value)
+    for key, value in sensitive_env_vars.items():
+        monkeypatch.setenv(key, value)
+
+    # Test with isolate_env=True
+    result = click.edit("test content", editor="echo", isolate_env=True)
+
+    # When isolate_env=True, environment must be explicitly provided (not None)
+    # and should contain filtered variables
+    assert captured_env is not None, "isolate_env=True should provide explicit environment dict"
+
+    # Check that non-sensitive variables are preserved
+    for key, expected_value in non_sensitive_env_vars.items():
+        assert key in captured_env, f"Essential variable {key} should be preserved"
+        assert captured_env[key] == expected_value
+
+    # Check that sensitive variables are filtered out
+    for key in sensitive_env_vars:
+        assert key not in captured_env, f"Sensitive variable {key} should be filtered out"
+
+
+def test_edit_isolate_env_with_custom_env(runner, monkeypatch):
+    """Test that custom env variables are applied on top of isolated environment."""
+    import os
+    import subprocess
+
+    # Mock subprocess.Popen to capture the environment
+    captured_env = None
+
+    def mock_popen(cmd, env=None, shell=True):
+        nonlocal captured_env
+        captured_env = env
+        mock_process = type("MockProcess", (), {"wait": lambda self: 0})()
+        return mock_process
+
+    monkeypatch.setattr(subprocess, "Popen", mock_popen)
+
+    # Set base environment
+    monkeypatch.setenv("PATH", "/usr/bin")
+    monkeypatch.setenv("API_KEY", "secret")  # Should be filtered when isolate_env=True
+
+    # Test with isolate_env=True and custom env
+    custom_env = {"CUSTOM_VAR": "custom_value", "GITHUB_TOKEN": "github_token"}
+    result = click.edit("test content", editor="echo", env=custom_env, isolate_env=True)
+
+    # Custom env should always result in an explicit environment dict
+    assert captured_env is not None, "Custom env should provide explicit environment dict"
+
+    # Essential variables should be preserved
+    assert "PATH" in captured_env, "PATH should be preserved in filtered environment"
+
+    # Sensitive variables from parent environment should be filtered when isolate_env=True
+    assert "API_KEY" not in captured_env, "Parent sensitive vars should be filtered with isolate_env=True"
+
+    # Custom variables should be added even if they look sensitive
+    # (custom env is not filtered - user explicitly provided it)
+    assert "CUSTOM_VAR" in captured_env
+    assert captured_env["CUSTOM_VAR"] == "custom_value"
+    assert "GITHUB_TOKEN" in captured_env
+    assert captured_env["GITHUB_TOKEN"] == "github_token"
+
+
+def test_edit_isolate_env_with_custom_env_no_isolation(runner, monkeypatch):
+    """Test that custom env works correctly when isolate_env=False."""
+    import os
+    import subprocess
+
+    # Mock subprocess.Popen to capture the environment
+    captured_env = None
+
+    def mock_popen(cmd, env=None, shell=True):
+        nonlocal captured_env
+        captured_env = env
+        mock_process = type("MockProcess", (), {"wait": lambda self: 0})()
+        return mock_process
+
+    monkeypatch.setattr(subprocess, "Popen", mock_popen)
+
+    # Set base environment
+    monkeypatch.setenv("PATH", "/usr/bin")
+    monkeypatch.setenv("API_KEY", "secret")  # Should NOT be filtered when isolate_env=False
+
+    # Test with isolate_env=False (default) and custom env
+    custom_env = {"CUSTOM_VAR": "custom_value"}
+    result = click.edit("test content", editor="echo", env=custom_env, isolate_env=False)
+
+    # Custom env should always result in an explicit environment dict
+    assert captured_env is not None, "Custom env should provide explicit environment dict"
+
+    # All parent environment should be preserved when isolate_env=False
+    assert "PATH" in captured_env
+    assert "API_KEY" in captured_env, "Sensitive vars should be preserved when isolate_env=False"
+    assert captured_env["API_KEY"] == "secret"
+
+    # Custom variables should be added
+    assert "CUSTOM_VAR" in captured_env
+    assert captured_env["CUSTOM_VAR"] == "custom_value"
