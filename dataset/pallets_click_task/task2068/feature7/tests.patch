diff --git a/tests/test_termui.py b/tests/test_termui.py
index 8fdfe8d..af438d2 100644
--- a/tests/test_termui.py
+++ b/tests/test_termui.py
@@ -3,6 +3,7 @@ import time
 
 import pytest
 
+import click
 import click._termui_impl
 from click._compat import WIN
 
@@ -470,3 +446,141 @@ def test_false_show_default_cause_no_default_display_in_prompt(runner):
     # is False
     result = runner.invoke(cmd, input="my-input", standalone_mode=False)
     assert "my-default-value" not in result.output
+
+
+def test_edit_escape_shell_malicious_filenames(runner, monkeypatch):
+    """Test escape_shell with various malicious filename patterns."""
+    import subprocess
+
+    calls = []
+
+    def mock_popen(cmd, *args, **kwargs):
+        calls.append((cmd, kwargs.get("shell", True)))
+        mock_process = type("MockProcess", (), {"wait": lambda self: 0})()
+        return mock_process
+
+    monkeypatch.setattr(subprocess, "Popen", mock_popen)
+
+    malicious_filenames = [
+        "file.txt; rm -rf /",
+        "file.txt | malicious_command",
+        "file.txt && evil_command",
+        "file.txt $(dangerous_command)",
+        "file.txt `backdoor`",
+        "file.txt > /etc/passwd",
+        "file.txt < /dev/null",
+        "file.txt || echo hacked",
+        "file with spaces.txt",
+        "file'with'quotes.txt",
+        'file"with"double"quotes.txt',
+        "tëst_ünïcödé.txt",
+        "!@#$%^&*()_+-=[]{}|;:,.<>?",
+    ]
+
+    for filename in malicious_filenames:
+        calls.clear()
+        click.edit(filename=filename, editor="vim")
+        click.edit(filename=filename, editor="vim", escape_shell=True)
+
+        # Verify that both calls were made
+        assert len(calls) == 2
+        unescaped_call, escaped_call = calls
+
+        # Verify security: escaped version should be different from unescaped
+        # This is the key security requirement - the commands should differ
+        assert unescaped_call != escaped_call
+
+        # For shell metacharacters, verify they don't appear unquoted in escaped version
+        dangerous_chars = [";", "|", "&", "$", "`", ">", "<", "||", "&&"]
+        cmd, shell_used = escaped_call
+
+        if any(char in filename for char in dangerous_chars):
+            if isinstance(cmd, str):
+                # String-based approach: dangerous chars should be quoted
+                # The filename should not appear unquoted in the command
+                assert f'"{filename}"' not in cmd or filename.count('"') > 0
+            elif isinstance(cmd, list):
+                # List-based approach: filename should be a separate argument
+                assert filename in cmd
+                # Verify shell=False is used for better security
+                assert not shell_used
+
+
+def test_edit_escape_shell_malicious_editor(runner, monkeypatch):
+    """Test escape_shell with malicious editor commands."""
+    import subprocess
+
+    calls = []
+
+    def mock_popen(cmd, *args, **kwargs):
+        calls.append((cmd, kwargs.get("shell", True)))
+        mock_process = type("MockProcess", (), {"wait": lambda self: 0})()
+        return mock_process
+
+    monkeypatch.setattr(subprocess, "Popen", mock_popen)
+
+    malicious_editors = [
+        "vim; rm -rf /",
+        "vim | malicious_command",
+        "vim && evil_command",
+        "vim $(dangerous_command)",
+        "vim `backdoor`",
+    ]
+
+    for editor in malicious_editors:
+        calls.clear()
+        click.edit(filename="test.txt", editor=editor, escape_shell=True)
+
+        # Verify that the editor command was properly escaped
+        assert len(calls) == 1
+        cmd, shell_used = calls[0]
+
+        # Should contain filename
+        assert "test.txt" in cmd or (isinstance(cmd, list) and "test.txt" in cmd)
+
+        # Verify security: the command should be properly escaped/sanitized
+        if isinstance(cmd, str):
+            # String-based approach: dangerous parts should be quoted individually
+            # We don't require the whole editor to be quoted as one unit,
+            # but individual dangerous parts should be quoted
+            # Example: "vim; rm -rf /" -> "'vim;' 'rm' '-rf' '/'"
+            dangerous_chars = [";", "|", "&", "$", "`"]
+            if any(char in editor for char in dangerous_chars):
+                # Verify that dangerous characters are quoted/escaped somehow
+                # The important thing is that they're not executing as shell metacharacters
+                assert cmd != f'{editor} "test.txt"'  # Should not be unescaped
+        elif isinstance(cmd, list):
+            # List-based approach: editor should be split into safe arguments
+            # Should use shell=False for better security
+            assert not shell_used
+            # The original editor command should be split appropriately
+            # so that shell metacharacters become separate arguments (safer)
+            assert len(cmd) > 1  # Should be split into multiple parts
+            assert "test.txt" in cmd  # Filename should be in the list
+
+
+def test_edit_escape_shell_empty_filename(runner, monkeypatch):
+    """Test escape_shell with empty filename."""
+    import subprocess
+
+    calls = []
+
+    def mock_popen(cmd, *args, **kwargs):
+        calls.append(cmd)
+        mock_process = type("MockProcess", (), {"wait": lambda self: 0})()
+        return mock_process
+
+    monkeypatch.setattr(subprocess, "Popen", mock_popen)
+
+    click.edit(filename="", editor="vim", escape_shell=True)
+
+    assert len(calls) == 1
+    cmd = calls[0]
+
+    # Handle both string and list approaches
+    if isinstance(cmd, str):
+        # String approach: should have quoted empty string
+        assert cmd == "vim ''" or cmd == 'vim ""'
+    elif isinstance(cmd, list):
+        # List approach: should have empty string as argument
+        assert cmd == ["vim", ""]
