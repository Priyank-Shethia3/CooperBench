diff --git a/src/click/core.py b/src/click/core.py
index f57ada6..b087245 100644
--- a/src/click/core.py
+++ b/src/click/core.py
@@ -3,6 +3,7 @@ from __future__ import annotations
 import collections.abc as cabc
 import enum
 import errno
+import hashlib
 import inspect
 import os
 import sys
@@ -49,6 +50,24 @@ if t.TYPE_CHECKING:
 F = t.TypeVar("F", bound="t.Callable[..., t.Any]")
 V = t.TypeVar("V")
 
+# Global cache for option value validation results
+_option_value_cache: dict[str, t.Any] = {}
+
+
+def _get_cache_key(param_name: str, value: t.Any, type_name: str) -> str:
+    """Generate a cache key for the given parameter and value."""
+    # Use hash of the string representation for simplicity
+    # In a production implementation, you might want a more sophisticated approach
+    value_str = str(value)
+    key_string = f"{param_name}:{type_name}:{value_str}"
+    return hashlib.md5(key_string.encode()).hexdigest()
+
+
+def _clear_cache() -> None:
+    """Clear the option value cache."""
+    global _option_value_cache
+    _option_value_cache.clear()
+
 
 def _complete_visible_commands(
     ctx: Context, incomplete: str
@@ -2504,6 +2523,11 @@ class Option(Parameter):
                                parameter will be pulled from an environment
                                variable in case a prefix is defined on the
                                context.
+    :param cache: if this is set to `True` then the validation result of
+                  expensive operations will be cached and reused for identical
+                  input values. This is particularly useful for options that
+                  involve file system access, network requests, or complex
+                  data parsing.
     :param help: the help string.
     :param hidden: hide this option from help outputs.
     :param attrs: Other command arguments described in :class:`Parameter`.
@@ -2549,6 +2573,7 @@ class Option(Parameter):
         show_choices: bool = True,
         show_envvar: bool = False,
         deprecated: bool | str = False,
+        cache: bool = False,
         **attrs: t.Any,
     ) -> None:
         if help:
@@ -2636,6 +2661,7 @@ class Option(Parameter):
         self.show_default = show_default
         self.show_choices = show_choices
         self.show_envvar = show_envvar
+        self.cache = cache
 
         if __debug__:
             if deprecated and prompt:
@@ -2680,6 +2706,50 @@ class Option(Parameter):
             result += f" (env var: '{self.envvar}')"
         return result
 
+    def type_cast_value(self, ctx: Context, value: t.Any) -> t.Any:
+        """Convert and validate a value against the option's
+        :attr:`type`, :attr:`multiple`, and :attr:`nargs`.
+
+        If caching is enabled, this method will check for cached results
+        and store new results in the cache.
+        """
+        if not self.cache:
+            # If caching is disabled, use the parent implementation
+            return super().type_cast_value(ctx, value)
+
+        if value is None:
+            return () if self.multiple or self.nargs == -1 else None
+
+        # Don't cache stateful types like File objects, but Path is okay
+        if hasattr(self.type, "name") and self.type.name == "file":
+            return super().type_cast_value(ctx, value)
+
+        # Generate cache key
+        param_name = self.name or "unknown"
+        type_name = getattr(self.type, "name", type(self.type).__name__)
+
+        # For multiple values or nargs != 1, we need to handle caching differently
+        if self.multiple or self.nargs != 1:
+            # Don't cache complex cases for now
+            return super().type_cast_value(ctx, value)
+
+        cache_key = _get_cache_key(param_name, value, type_name)
+
+        # Check if we have a cached result
+        if cache_key in _option_value_cache:
+            return _option_value_cache[cache_key]
+
+        # Convert the value using parent implementation
+        try:
+            result = super().type_cast_value(ctx, value)
+            # Only cache if the result is not a file-like object
+            if not hasattr(result, "read") and not hasattr(result, "write"):
+                _option_value_cache[cache_key] = result
+            return result
+        except Exception:
+            # Don't cache exceptions, just re-raise
+            raise
+
     def _parse_decls(
         self, decls: cabc.Sequence[str], expose_value: bool
     ) -> tuple[str | None, list[str], list[str]]:
