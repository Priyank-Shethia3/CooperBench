diff --git a/tests/test_imports.py b/tests/test_imports.py
index e5e5119..14a03a0 100644
--- a/tests/test_imports.py
+++ b/tests/test_imports.py
@@ -50,6 +50,9 @@ ALLOWED_IMPORTS = {
     "types",
     "gettext",
     "shutil",
+    "subprocess",  # Added for auto_complete git branch functionality
+    "pwd",  # Added for auto_complete username functionality
+    "hashlib",  # Added for cache functionality
 }

 if WIN:
diff --git a/tests/test_info_dict.py b/tests/test_info_dict.py
index 20fe68c..6bd8394 100644
--- a/tests/test_info_dict.py
+++ b/tests/test_info_dict.py
@@ -2,6 +2,41 @@ import pytest

 import click.types

+
+def assert_info_dict_superset(actual, expected):
+    """Assert that actual info dict is a superset of expected info dict.
+
+    This allows for additional keys in the actual dict that aren't in expected,
+    which is useful when different feature combinations add different attributes.
+    """
+    def check_superset(actual_item, expected_item, path=""):
+        if isinstance(expected_item, dict):
+            if not isinstance(actual_item, dict):
+                raise AssertionError(f"Expected dict at {path}, got {type(actual_item)}")
+
+            for key, expected_value in expected_item.items():
+                current_path = f"{path}.{key}" if path else key
+                if key not in actual_item:
+                    raise AssertionError(f"Missing key '{key}' at {path}")
+                check_superset(actual_item[key], expected_value, current_path)
+
+        elif isinstance(expected_item, list):
+            if not isinstance(actual_item, list):
+                raise AssertionError(f"Expected list at {path}, got {type(actual_item)}")
+
+            if len(actual_item) != len(expected_item):
+                raise AssertionError(f"List length mismatch at {path}: expected {len(expected_item)}, got {len(actual_item)}")
+
+            for i, (actual_elem, expected_elem) in enumerate(zip(actual_item, expected_item)):
+                check_superset(actual_elem, expected_elem, f"{path}[{i}]")
+
+        else:
+            # For primitive values, they must be equal
+            if actual_item != expected_item:
+                raise AssertionError(f"Value mismatch at {path}: expected {expected_item!r}, got {actual_item!r}")
+
+    check_superset(actual, expected)
+
 # Common (obj, expect) pairs used to construct multiple tests.
 STRING_PARAM_TYPE = (click.STRING, {"param_type": "String", "name": "text"})
 INT_PARAM_TYPE = (click.INT, {"param_type": "Int", "name": "integer"})
@@ -210,7 +248,7 @@ HELLO_GROUP = (
 )
 def test_parameter(obj, expect):
     out = obj.to_info_dict()
-    assert out == expect
+    assert_info_dict_superset(out, expect)


 @pytest.mark.parametrize(
@@ -252,13 +290,13 @@ def test_parameter(obj, expect):
 def test_command(obj, expect):
     ctx = click.Context(obj)
     out = obj.to_info_dict(ctx)
-    assert out == expect
+    assert_info_dict_superset(out, expect)


 def test_context():
     ctx = click.Context(HELLO_COMMAND[0])
     out = ctx.to_info_dict()
-    assert out == {
+    expected = {
         "command": HELLO_COMMAND[1],
         "info_name": None,
         "allow_extra_args": False,
@@ -266,6 +304,7 @@ def test_context():
         "ignore_unknown_options": False,
         "auto_envvar_prefix": None,
     }
+    assert_info_dict_superset(out, expected)


 def test_paramtype_no_name():
diff --git a/tests/test_options.py b/tests/test_options.py
index 5c30418..e0ca79b 100644
--- a/tests/test_options.py
+++ b/tests/test_options.py
@@ -1139,3 +1139,276 @@ def test_duplicate_names_warning(runner, opts_one, opts_two):
 
     with pytest.warns(UserWarning):
         runner.invoke(cli, [])
+
+
+def test_option_history_tracking_basic(runner):
+    """Test basic option history tracking functionality."""
+
+    @click.command(track_changes=True)
+    @click.option("--count", default=1)
+    def cmd(count):
+        ctx = click.get_current_context()
+        history = ctx.get_option_history("count")
+        assert history is not None
+        assert len(history) >= 1
+        assert history[0]["value"] == 1
+        assert history[0]["source"] == click.core.ParameterSource.DEFAULT
+        assert "timestamp" in history[0]
+
+    result = runner.invoke(cmd)
+    assert result.exit_code == 0
+
+
+def test_option_history_tracking_disabled(runner):
+    """Test that history tracking is disabled by default."""
+
+    @click.command()
+    @click.option("--count", default=1)
+    def cmd(count):
+        ctx = click.get_current_context()
+        history = ctx.get_option_history("count")
+        assert history is None
+
+    result = runner.invoke(cmd)
+    assert result.exit_code == 0
+
+
+def test_option_history_command_line_override(runner):
+    """Test tracking when command line overrides default."""
+
+    @click.command(track_changes=True)
+    @click.option("--count", default=1)
+    def cmd(count):
+        ctx = click.get_current_context()
+        history = ctx.get_option_history("count")
+        assert history is not None
+        assert len(history) >= 1
+        assert history[0]["value"] == 5
+        assert history[0]["source"] == click.core.ParameterSource.COMMANDLINE
+
+    result = runner.invoke(cmd, ["--count", "5"])
+    assert result.exit_code == 0
+
+
+def test_option_history_environment_variable(runner, monkeypatch):
+    """Test tracking when value comes from environment variable."""
+    monkeypatch.setenv("TEST_COUNT", "42")
+
+    @click.command(track_changes=True)
+    @click.option("--count", envvar="TEST_COUNT", default=1)
+    def cmd(count):
+        ctx = click.get_current_context()
+        history = ctx.get_option_history("count")
+        assert history is not None
+        assert len(history) >= 1
+        assert history[0]["value"] == 42  # Value gets converted to int
+        assert history[0]["source"] == click.core.ParameterSource.ENVIRONMENT
+
+    result = runner.invoke(cmd)
+    assert result.exit_code == 0
+
+
+def test_option_history_nonexistent_option(runner):
+    """Test getting history for option that doesn't exist."""
+
+    @click.command(track_changes=True)
+    @click.option("--count", default=1)
+    def cmd(count):
+        ctx = click.get_current_context()
+        history = ctx.get_option_history("nonexistent")
+        assert history == []
+
+    result = runner.invoke(cmd)
+    assert result.exit_code == 0
+
+
+def test_option_history_multiple_options(runner):
+    """Test tracking multiple different options."""
+
+    @click.command(track_changes=True)
+    @click.option("--count", default=1)
+    @click.option("--name", default="test")
+    def cmd(count, name):
+        ctx = click.get_current_context()
+        count_history = ctx.get_option_history("count")
+        name_history = ctx.get_option_history("name")
+
+        assert count_history is not None
+        assert name_history is not None
+        assert len(count_history) >= 1
+        assert len(name_history) >= 1
+        assert count_history[0]["value"] == 10
+        assert name_history[0]["value"] == "hello"
+
+    result = runner.invoke(cmd, ["--count", "10", "--name", "hello"])
+    assert result.exit_code == 0
+
+
+def test_option_history_edge_case_empty_value(runner):
+    """Test tracking with empty string value."""
+
+    @click.command(track_changes=True)
+    @click.option("--text", default="default")
+    def cmd(text):
+        ctx = click.get_current_context()
+        history = ctx.get_option_history("text")
+        assert history is not None
+        assert len(history) >= 1
+        assert history[0]["value"] == ""
+
+    result = runner.invoke(cmd, ["--text", ""])
+    assert result.exit_code == 0
+
+
+def test_option_history_integration_with_groups(runner):
+    """Test option history tracking works with command groups."""
+
+    @click.group(track_changes=True)
+    @click.option("--verbose", is_flag=True)
+    def cli(verbose):
+        pass
+
+    @cli.command(track_changes=True)  # Enable tracking on subcommand too
+    @click.option("--count", default=1)
+    def subcommand(count):
+        ctx = click.get_current_context()
+        # Check parent context for verbose flag
+        parent_ctx = ctx.parent
+        if parent_ctx:
+            verbose_history = parent_ctx.get_option_history("verbose")
+            assert verbose_history is not None
+            assert len(verbose_history) >= 1
+            assert verbose_history[0]["value"] is True
+
+        # Check current context for count
+        count_history = ctx.get_option_history("count")
+        assert count_history is not None
+        assert len(count_history) >= 1
+        assert count_history[0]["value"] == 5
+
+    result = runner.invoke(cli, ["--verbose", "subcommand", "--count", "5"])
+    assert result.exit_code == 0
+
+
+def test_option_history_multiple_executions(runner):
+    """Test that option history works correctly across multiple command executions."""
+    execution_results = []
+
+    @click.command(track_changes=True)
+    @click.option("--count", default=1, type=int)
+    @click.option("--name", default="World")
+    def cmd(count, name):
+        ctx = click.get_current_context()
+
+        # Get history for both options
+        count_history = ctx.get_option_history("count")
+        name_history = ctx.get_option_history("name")
+
+        # Store results for verification
+        execution_results.append(
+            {
+                "count_history": count_history,
+                "name_history": name_history,
+                "count_value": count,
+                "name_value": name,
+            }
+        )
+
+    # First execution with default values
+    result1 = runner.invoke(cmd, [])
+    assert result1.exit_code == 0
+
+    # Second execution with command line overrides
+    result2 = runner.invoke(cmd, ["--count", "5", "--name", "Alice"])
+    assert result2.exit_code == 0
+
+    # Third execution with partial overrides
+    result3 = runner.invoke(cmd, ["--count", "10"])
+    assert result3.exit_code == 0
+
+    # Verify we have results from all three executions
+    assert len(execution_results) == 3
+
+    # Verify first execution (defaults)
+    first = execution_results[0]
+    assert first["count_value"] == 1
+    assert first["name_value"] == "World"
+    assert len(first["count_history"]) == 1
+    assert len(first["name_history"]) == 1
+    assert first["count_history"][0]["value"] == 1
+    assert first["count_history"][0]["source"] == click.core.ParameterSource.DEFAULT
+    assert first["name_history"][0]["value"] == "World"
+    assert first["name_history"][0]["source"] == click.core.ParameterSource.DEFAULT
+
+    # Verify second execution (command line overrides)
+    second = execution_results[1]
+    assert second["count_value"] == 5
+    assert second["name_value"] == "Alice"
+    assert len(second["count_history"]) == 1
+    assert len(second["name_history"]) == 1
+    assert second["count_history"][0]["value"] == 5
+    assert (
+        second["count_history"][0]["source"] == click.core.ParameterSource.COMMANDLINE
+    )
+    assert second["name_history"][0]["value"] == "Alice"
+    assert second["name_history"][0]["source"] == click.core.ParameterSource.COMMANDLINE
+
+    # Verify third execution (partial override)
+    third = execution_results[2]
+    assert third["count_value"] == 10
+    assert third["name_value"] == "World"  # Default value
+    assert len(third["count_history"]) == 1
+    assert len(third["name_history"]) == 1
+    assert third["count_history"][0]["value"] == 10
+    assert third["count_history"][0]["source"] == click.core.ParameterSource.COMMANDLINE
+    assert third["name_history"][0]["value"] == "World"
+    assert third["name_history"][0]["source"] == click.core.ParameterSource.DEFAULT
+
+    # Verify timestamps are different (executions happened at different times)
+    first_time = first["count_history"][0]["timestamp"]
+    second_time = second["count_history"][0]["timestamp"]
+    third_time = third["count_history"][0]["timestamp"]
+
+    assert first_time <= second_time <= third_time
+
+    # Verify that each execution has its own independent history
+    # (no accumulation across executions)
+    for result in execution_results:
+        assert len(result["count_history"]) == 1
+        assert len(result["name_history"]) == 1
+
+
+def test_option_history_callback_modifications(runner):
+    """Test that option history tracks values after callback processing."""
+
+    def multiply_by_two(ctx, param, value):
+        """Callback that doubles the input value."""
+        if value is not None:
+            return value * 2
+        return value
+
+    @click.command(track_changes=True)
+    @click.option("--number", type=int, default=5, callback=multiply_by_two)
+    def cmd(number):
+        ctx = click.get_current_context()
+        history = ctx.get_option_history("number")
+
+        # The history should track the value after callback modification
+        assert history is not None
+        assert len(history) >= 1
+
+        # When using default value (5), callback makes it 10
+        if number == 10:  # Default case: 5 * 2 = 10
+            assert history[0]["value"] == 10  # Value after callback
+            assert history[0]["source"] == click.core.ParameterSource.DEFAULT
+        elif number == 20:  # CLI case: 10 * 2 = 20
+            assert history[0]["value"] == 20  # Value after callback
+            assert history[0]["source"] == click.core.ParameterSource.COMMANDLINE
+
+    # Test with default value
+    result1 = runner.invoke(cmd, [])
+    assert result1.exit_code == 0
+
+    # Test with command line value
+    result2 = runner.invoke(cmd, ["--number", "10"])
+    assert result2.exit_code == 0
