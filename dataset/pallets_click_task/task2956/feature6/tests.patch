diff --git a/tests/test_imports.py b/tests/test_imports.py
index e5e5119..14a03a0 100644
--- a/tests/test_imports.py
+++ b/tests/test_imports.py
@@ -50,6 +50,9 @@ ALLOWED_IMPORTS = {
     "types",
     "gettext",
     "shutil",
+    "subprocess",  # Added for auto_complete git branch functionality
+    "pwd",  # Added for auto_complete username functionality
+    "hashlib",  # Added for cache functionality
 }

 if WIN:
diff --git a/tests/test_info_dict.py b/tests/test_info_dict.py
index 20fe68c..6bd8394 100644
--- a/tests/test_info_dict.py
+++ b/tests/test_info_dict.py
@@ -2,6 +2,41 @@ import pytest

 import click.types

+
+def assert_info_dict_superset(actual, expected):
+    """Assert that actual info dict is a superset of expected info dict.
+
+    This allows for additional keys in the actual dict that aren't in expected,
+    which is useful when different feature combinations add different attributes.
+    """
+    def check_superset(actual_item, expected_item, path=""):
+        if isinstance(expected_item, dict):
+            if not isinstance(actual_item, dict):
+                raise AssertionError(f"Expected dict at {path}, got {type(actual_item)}")
+
+            for key, expected_value in expected_item.items():
+                current_path = f"{path}.{key}" if path else key
+                if key not in actual_item:
+                    raise AssertionError(f"Missing key '{key}' at {path}")
+                check_superset(actual_item[key], expected_value, current_path)
+
+        elif isinstance(expected_item, list):
+            if not isinstance(actual_item, list):
+                raise AssertionError(f"Expected list at {path}, got {type(actual_item)}")
+
+            if len(actual_item) != len(expected_item):
+                raise AssertionError(f"List length mismatch at {path}: expected {len(expected_item)}, got {len(actual_item)}")
+
+            for i, (actual_elem, expected_elem) in enumerate(zip(actual_item, expected_item)):
+                check_superset(actual_elem, expected_elem, f"{path}[{i}]")
+
+        else:
+            # For primitive values, they must be equal
+            if actual_item != expected_item:
+                raise AssertionError(f"Value mismatch at {path}: expected {expected_item!r}, got {actual_item!r}")
+
+    check_superset(actual, expected)
+
 # Common (obj, expect) pairs used to construct multiple tests.
 STRING_PARAM_TYPE = (click.STRING, {"param_type": "String", "name": "text"})
 INT_PARAM_TYPE = (click.INT, {"param_type": "Int", "name": "integer"})
@@ -210,7 +248,7 @@ HELLO_GROUP = (
 )
 def test_parameter(obj, expect):
     out = obj.to_info_dict()
-    assert out == expect
+    assert_info_dict_superset(out, expect)


 @pytest.mark.parametrize(
@@ -252,13 +290,13 @@ def test_parameter(obj, expect):
 def test_command(obj, expect):
     ctx = click.Context(obj)
     out = obj.to_info_dict(ctx)
-    assert out == expect
+    assert_info_dict_superset(out, expect)


 def test_context():
     ctx = click.Context(HELLO_COMMAND[0])
     out = ctx.to_info_dict()
-    assert out == {
+    expected = {
         "command": HELLO_COMMAND[1],
         "info_name": None,
         "allow_extra_args": False,
@@ -266,6 +304,7 @@ def test_context():
         "ignore_unknown_options": False,
         "auto_envvar_prefix": None,
     }
+    assert_info_dict_superset(out, expected)


 def test_paramtype_no_name():
diff --git a/tests/test_options.py b/tests/test_options.py
index 5c30418..b758343 100644
--- a/tests/test_options.py
+++ b/tests/test_options.py
@@ -1139,3 +1139,117 @@ def test_duplicate_names_warning(runner, opts_one, opts_two):
 
     with pytest.warns(UserWarning):
         runner.invoke(cli, [])
+
+def test_dynamic_default_integration(runner):
+    """Test dynamic defaults in real command scenarios."""
+
+    @click.command()
+    @click.option("--env", type=click.Choice(["dev", "staging", "prod"]), default="dev")
+    @click.option("--debug", is_flag=True)
+    @click.option(
+        "--log-level",
+        default={
+            "--env": {"dev": "DEBUG", "staging": "INFO", "prod": "ERROR"},
+            "--debug": {"True": "DEBUG"},
+        },
+    )
+    def deploy(env, debug, log_level):
+        click.echo(f"Deploying to {env} with log level {log_level} (debug={debug})")
+
+    # Test dev environment gets DEBUG by default
+    result = runner.invoke(deploy, [])
+    assert result.exit_code == 0
+    assert "Deploying to dev with log level DEBUG" in result.output
+
+    # Test staging environment gets INFO
+    result = runner.invoke(deploy, ["--env", "staging"])
+    assert result.exit_code == 0
+    assert "Deploying to staging with log level INFO" in result.output
+
+    # Test debug flag overrides environment default
+    result = runner.invoke(deploy, ["--env", "prod", "--debug"])
+    assert result.exit_code == 0
+    assert "Deploying to prod with log level DEBUG" in result.output
+
+
+def test_dynamic_default_with_envvars(runner):
+    """Test dynamic defaults work with environment variables."""
+
+    @click.command()
+    @click.option("--protocol", envvar="PROTOCOL", default="http")
+    @click.option("--port", default={"--protocol": {"http": 80, "https": 443}})
+    def server(protocol, port):
+        click.echo(f"{protocol}://localhost:{port}")
+
+    # Test with environment variable
+    result = runner.invoke(server, env={"PROTOCOL": "https"})
+    assert result.exit_code == 0
+    assert "https://localhost:443" in result.output
+
+
+def test_dynamic_default_precedence(runner):
+    """Test that command line args take precedence over dynamic defaults."""
+
+    @click.command()
+    @click.option("--mode", default="safe")
+    @click.option("--speed", default={"--mode": {"safe": 10, "fast": 100}})
+    def drive(mode, speed):
+        click.echo(f"Driving in {mode} mode at speed {speed}")
+
+    # Dynamic default should be used
+    result = runner.invoke(drive, ["--mode", "fast"])
+    assert result.exit_code == 0
+    assert "Driving in fast mode at speed 100" in result.output
+
+    # Explicit value should override dynamic default
+    result = runner.invoke(drive, ["--mode", "fast", "--speed", "50"])
+    assert result.exit_code == 0
+    assert "Driving in fast mode at speed 50" in result.output
+
+
+def test_dynamic_default_no_match(runner):
+    """Test dynamic default when no mapping matches."""
+
+    @click.command()
+    @click.option("--type", default="other")
+    @click.option(
+        "--config", default={"--type": {"web": "web.conf", "api": "api.conf"}}
+    )
+    def cli(type, config):
+        click.echo(f"type={type} config={config}")
+
+    result = runner.invoke(cli, ["--type", "web"])
+    assert result.exit_code == 0
+    assert "type=web config=web.conf" in result.output
+
+    result = runner.invoke(cli, [])
+    assert result.exit_code == 0
+    assert "type=other config=None" in result.output
+
+
+def test_dynamic_default_help_display(runner):
+    """Test that dynamic defaults show as '(dynamic)' in help."""
+
+    @click.command()
+    @click.option("--protocol", default="http")
+    @click.option(
+        "--port",
+        default={"--protocol": {"http": 80, "https": 443}},
+        show_default=True,
+        help="Server port",
+    )
+    def cli(protocol, port):
+        pass
+
+    result = runner.invoke(cli, ["--help"])
+    assert result.exit_code == 0
+    assert "[default: (dynamic)]" in result.output
+
+
+def test_dynamic_default_invalid_structure():
+    """Test that invalid dynamic default structures raise errors."""
+    with pytest.raises(TypeError, match="Dynamic default keys must be strings"):
+        click.Option(["--port"], default={123: {"value": 80}})
+
+    with pytest.raises(TypeError, match="Dynamic default values must be dictionaries"):
+        click.Option(["--port"], default={"--protocol": "not_dict"})
