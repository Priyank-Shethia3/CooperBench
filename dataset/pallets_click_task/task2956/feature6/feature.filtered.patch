diff --git a/src/click/core.py b/src/click/core.py
index f57ada6..1a5bbec 100644
--- a/src/click/core.py
+++ b/src/click/core.py
@@ -1196,6 +1196,20 @@ class Command:
         for param in iter_params_for_processing(param_order, self.get_params(ctx)):
             value, args = param.handle_parse_result(ctx, opts, args)
 
+        # Second pass: resolve dynamic defaults for options that have dict defaults
+        # and use DEFAULT source (no command line, env, or default_map value)
+        for param in self.get_params(ctx):
+            if (
+                isinstance(param, Option)
+                and isinstance(param.default, dict)
+                and param.name is not None
+                and ctx.get_parameter_source(param.name) == ParameterSource.DEFAULT
+            ):
+                # Try to resolve dynamic default
+                resolved_value = param._resolve_dynamic_default(ctx, param.default)
+                if resolved_value is not None:
+                    ctx.params[param.name] = resolved_value
+
         if args and not ctx.allow_extra_args and not ctx.resilient_parsing:
             ctx.fail(
                 ngettext(
@@ -2662,6 +2676,19 @@ class Option(Parameter):
                 if self.is_flag:
                     raise TypeError("'count' is not valid with 'is_flag'.")
 
+            # Validate dynamic defaults
+            if isinstance(self.default, dict):
+                for option_name, value_mapping in self.default.items():
+                    if not isinstance(option_name, str):
+                        raise TypeError(
+                            "Dynamic default keys must be strings (option names)."
+                        )
+                    if not isinstance(value_mapping, dict):
+                        raise TypeError(
+                            "Dynamic default values must be dictionaries mapping "
+                            "option values to defaults."
+                        )
+
     def to_info_dict(self) -> dict[str, t.Any]:
         info_dict = super().to_info_dict()
         info_dict.update(
@@ -2864,6 +2891,9 @@ class Option(Parameter):
         if show_default_is_str or (show_default and (default_value is not None)):
             if show_default_is_str:
                 default_string = f"({self.show_default})"
+            elif isinstance(default_value, dict):
+                # Handle dynamic defaults
+                default_string = _("(dynamic)")
             elif isinstance(default_value, (list, tuple)):
                 default_string = ", ".join(str(d) for d in default_value)
             elif inspect.isfunction(default_value):
@@ -2923,7 +2953,45 @@ class Option(Parameter):
 
             return None
 
-        return super().get_default(ctx, call=call)
+        # Check if default is a dictionary-based dynamic default
+        default_value = super().get_default(ctx, call=call)
+        if isinstance(default_value, dict) and not call:
+            # Return the dict as-is when call=False for help display
+            return default_value
+        elif isinstance(default_value, dict):
+            # Resolve dynamic default based on other option values
+            return self._resolve_dynamic_default(ctx, default_value)
+
+        return default_value
+
+    def _resolve_dynamic_default(
+        self, ctx: Context, dynamic_default: dict[str, t.Any]
+    ) -> t.Any:
+        """Resolve a dynamic default value based on other parameter values.
+
+        :param ctx: Current context
+        :param dynamic_default: Dictionary mapping option names to their value mappings
+        :return: Resolved default value or None if no match found
+        """
+        # Collect all possible values, prioritizing later options in the dict
+        # (since they are more specific/have higher precedence)
+        resolved_value = None
+
+        for option_name, value_mapping in dynamic_default.items():
+            # Clean option name (remove -- prefix if present)
+            clean_option_name = option_name.lstrip("-").replace("-", "_")
+
+            # Get the current value of the referenced option
+            current_value = ctx.params.get(clean_option_name)
+
+            if current_value is not None and isinstance(value_mapping, dict):
+                # Convert current_value to string for key lookup
+                key = str(current_value)
+                if key in value_mapping:
+                    resolved_value = value_mapping[key]
+                    # Don't break - later options can override earlier ones
+
+        return resolved_value
 
     def prompt_for_value(self, ctx: Context) -> t.Any:
         """This is an alternative flow that can be activated in the full

