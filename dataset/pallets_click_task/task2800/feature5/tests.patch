diff --git a/tests/test_shell_completion.py b/tests/test_shell_completion.py
index 3e7a2bd..99d71a1 100644
--- a/tests/test_shell_completion.py
+++ b/tests/test_shell_completion.py
@@ -1,8 +1,11 @@
+import time
+
 import pytest
 
 import click.shell_completion
 from click.core import Argument
 from click.core import Command
+from click.core import Context
 from click.core import Group
 from click.core import Option
 from click.shell_completion import add_completion_class
@@ -414,3 +417,94 @@ def test_add_completion_class_decorator():
     # Using `add_completion_class` as a decorator adds the new shell immediately
     assert "mysh" in click.shell_completion._available_shells
     assert click.shell_completion._available_shells["mysh"] is MyshComplete
+
+
+def test_context_retry_cleanup_basic():
+    """Test basic retry_cleanup functionality with successful cleanup."""
+    cleanup_count = 0
+    def cleanup_func():
+        nonlocal cleanup_count
+        cleanup_count += 1
+
+    ctx = Context(Command("test"), retry_cleanup=3)
+    ctx.call_on_close(cleanup_func)
+    ctx.close()
+
+    assert cleanup_count == 1
+
+
+def test_context_retry_cleanup_with_failure():
+    """Test retry_cleanup with failing cleanup operations."""
+    cleanup_attempts = 0
+    def failing_cleanup():
+        nonlocal cleanup_attempts
+        cleanup_attempts += 1
+        if cleanup_attempts < 3:
+            raise OSError("Simulated cleanup failure")
+
+    ctx = Context(Command("test"), retry_cleanup=3)
+    ctx.call_on_close(failing_cleanup)
+
+    start_time = time.time()
+    ctx.close()
+    end_time = time.time()
+
+    assert cleanup_attempts == 3
+    # Should have exponential backoff delays: 0.1 + 0.2 = 0.3 seconds minimum
+    assert end_time - start_time >= 0.25
+
+
+def test_context_retry_cleanup_exhausted():
+    """Test retry_cleanup when all retries are exhausted."""
+    cleanup_attempts = 0
+    def always_failing_cleanup():
+        nonlocal cleanup_attempts
+        cleanup_attempts += 1
+        raise ValueError("Always fails")
+
+    ctx = Context(Command("test"), retry_cleanup=2)
+    ctx.call_on_close(always_failing_cleanup)
+
+    with pytest.raises(ValueError, match="Always fails"):
+        ctx.close()
+
+    assert cleanup_attempts == 3  # Initial attempt + 2 retries
+
+
+def test_context_retry_cleanup_inheritance():
+    """Test that retry_cleanup is inherited from parent context."""
+    parent_ctx = Context(Command("parent"), retry_cleanup=5)
+    child_ctx = Context(Command("child"), parent=parent_ctx)
+
+    assert child_ctx.retry_cleanup == 5
+
+
+def test_context_retry_cleanup_explicit_override():
+    """Test that explicit retry_cleanup overrides parent value."""
+    parent_ctx = Context(Command("parent"), retry_cleanup=5)
+    child_ctx = Context(Command("child"), parent=parent_ctx, retry_cleanup=2)
+
+    assert child_ctx.retry_cleanup == 2
+
+
+def test_context_retry_cleanup_zero_default():
+    """Test that retry_cleanup defaults to 0 (no retries)."""
+    ctx = Context(Command("test"))
+    assert ctx.retry_cleanup == 0
+
+
+def test_context_retry_cleanup_no_retry_path():
+    """Test cleanup without retry (retry_cleanup=0) for edge case."""
+    cleanup_attempts = 0
+    def failing_cleanup():
+        nonlocal cleanup_attempts
+        cleanup_attempts += 1
+        raise RuntimeError("Should not retry")
+
+    ctx = Context(Command("test"), retry_cleanup=0)
+    ctx.call_on_close(failing_cleanup)
+
+    with pytest.raises(RuntimeError, match="Should not retry"):
+        ctx.close()
+
+    assert cleanup_attempts == 1  # No retries
