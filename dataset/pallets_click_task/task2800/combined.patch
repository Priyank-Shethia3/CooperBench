diff --git a/src/click/core.py b/src/click/core.py
index 666ad68..b2c22e4 100644
--- a/src/click/core.py
+++ b/src/click/core.py
@@ -28,6 +28,7 @@ from .exceptions import NoArgsIsHelpError
 from .exceptions import UsageError
 from .formatting import HelpFormatter
 from .formatting import join_options
+from .utils import echo
 from .globals import pop_context
 from .globals import push_context
 from .parser import _flag_needs_value
@@ -228,6 +229,24 @@ class Context:
         value is not set, it defaults to the value from the parent
         context. ``Command.show_default`` overrides this default for the
         specific command.
+    :param on_exit: an optional callback that is invoked when the context
+                    exits. The callback receives the context object as its
+                    argument. This is useful for logging, metrics collection,
+                    or custom cleanup operations.
+    :param max_resources: Maximum number of resources that can be registered
+        with :meth:`with_resource`. If `None` (default), there is no limit.
+        When set to a positive integer, attempting to register more resources
+        than this limit will raise a `RuntimeError`.
+    :param cleanup_timeout: Maximum time in seconds to wait for cleanup
+        operations during context teardown. If None, no timeout is applied.
+        When the timeout is exceeded, cleanup operations are forcibly
+        terminated to prevent hanging processes.
+    :param retry_cleanup: The number of times to retry cleanup operations
+        if they fail. Defaults to 0 (no retries). When greater than 0,
+        failed cleanup operations will be retried with exponential backoff.
+
+    .. versionchanged:: 8.3
+        Added the ``on_exit`` parameter.
 
     .. versionchanged:: 8.2
         The ``protected_args`` attribute is deprecated and will be removed in
@@ -280,6 +299,11 @@ class Context:
         token_normalize_func: t.Callable[[str], str] | None = None,
         color: bool | None = None,
         show_default: bool | None = None,
+        on_exit: t.Callable[[Context], t.Any] | None = None,
+        max_resources: int | None = None,
+        cleanup_timeout: float | None = None,
+        retry_cleanup: int = 0,
+        validate_nesting: bool = False,
     ) -> None:
         #: the parent context or `None` if none exists.
         self.parent = parent
@@ -427,11 +451,61 @@ class Context:
         #: Show option default values when formatting help text.
         self.show_default: bool | None = show_default
 
+        #: Optional callback to invoke when the context exits.
+        self._on_exit: t.Callable[[Context], t.Any] | None = on_exit
+
+        if max_resources is None and parent is not None:
+            max_resources = parent.max_resources
+
+        #: Maximum number of resources that can be registered.
+        self.max_resources: int | None = max_resources
+        # Share resource count with parent context if one exists
+        if parent is not None:
+            self._resource_count_ref = parent._resource_count_ref
+        else:
+            self._resource_count_ref = [0]
+
+        if cleanup_timeout is None and parent is not None:
+            cleanup_timeout = parent.cleanup_timeout
+
+        # Validate cleanup_timeout
+        if cleanup_timeout is not None and cleanup_timeout <= 0:
+            raise ValueError("cleanup_timeout must be greater than 0")
+
+        #: Maximum timeout for cleanup operations in seconds.
+        self.cleanup_timeout: float | None = cleanup_timeout
+
+        if retry_cleanup == 0 and parent is not None:
+            retry_cleanup = parent.retry_cleanup
+
+        #: The number of times to retry cleanup operations if they fail.
+        self.retry_cleanup: int = retry_cleanup
+
+        # Inherit validate_nesting from parent if parent has it enabled
+        if validate_nesting is False and parent is not None and parent.validate_nesting:
+            validate_nesting = True
+
+        #: Whether to validate proper context nesting to prevent resource leaks.
+        self.validate_nesting: bool = validate_nesting
+
+        #: Track child contexts when validation is enabled.
+        self._child_contexts: set[Context] = set()
+
         self._close_callbacks: list[t.Callable[[], t.Any]] = []
         self._depth = 0
         self._parameter_source: dict[str, ParameterSource] = {}
         self._exit_stack = ExitStack()
 
+    @property
+    def on_exit(self) -> t.Callable[[Context], t.Any] | None:
+        """The on_exit callback function, if set."""
+        return self._on_exit
+
+    @on_exit.setter
+    def on_exit(self, value: t.Callable[[Context], t.Any] | None) -> None:
+        """Set the on_exit callback function."""
+        self._on_exit = value
+
     @property
     def protected_args(self) -> list[str]:
         import warnings
@@ -588,6 +662,16 @@ class Context:
 
         .. versionadded:: 8.0
         """
+        if (
+            self.max_resources is not None
+            and self._resource_count_ref[0] >= self.max_resources
+        ):
+            raise RuntimeError(
+                f"Maximum number of resources ({self.max_resources}) exceeded. "
+                "Cannot register more resources."
+            )
+
+        self._resource_count_ref[0] += 1
         return self._exit_stack.enter_context(context_manager)
 
     def call_on_close(self, f: t.Callable[..., t.Any]) -> t.Callable[..., t.Any]:
@@ -600,17 +684,223 @@ class Context:
 
         :param f: The function to execute on teardown.
         """
-        return self._exit_stack.callback(f)
+        if self.retry_cleanup > 0:
+            # Wrap the function with retry logic
+            def retry_wrapper():
+                import time
+
+                last_exception = None
+                for attempt in range(self.retry_cleanup + 1):
+                    try:
+                        return f()
+                    except Exception as e:
+                        last_exception = e
+                        if attempt < self.retry_cleanup:
+                            # Exponential backoff: wait 0.1, 0.2, 0.4, 0.8, ... seconds
+                            wait_time = 0.1 * (2 ** attempt)
+                            time.sleep(wait_time)
+                        else:
+                            # All retries exhausted, re-raise the original exception
+                            raise last_exception from None
+            return self._exit_stack.callback(retry_wrapper)
+        else:
+            return self._exit_stack.callback(f)
 
     def close(self) -> None:
         """Invoke all close callbacks registered with
         :meth:`call_on_close`, and exit all context managers entered
         with :meth:`with_resource`.
+
+        If cleanup_timeout is specified, cleanup operations are limited
+        to that duration. If the timeout is exceeded, cleanup is
+        forcibly terminated to prevent hanging processes.
         """
-        self._exit_stack.close()
+        # Validate nesting if enabled
+        if self.validate_nesting and self._child_contexts:
+            open_children = [child for child in self._child_contexts if child._exit_stack is not None]
+            if open_children:
+                raise RuntimeError(
+                    f"Cannot close parent context while {len(open_children)} child context(s) remain open. "
+                    f"Child contexts: {[child.info_name or 'unnamed' for child in open_children]}"
+                )
+
+        # Call the on_exit callback if provided
+        if self._on_exit is not None:
+            try:
+                self._on_exit(self)
+            except Exception:
+                # Don't let callback exceptions interfere with context cleanup
+                pass
+
+        if self.cleanup_timeout is not None:
+            self._close_with_timeout()
+        else:
+            self._exit_stack.close()
+            # In case the context is reused, create a new exit stack.
+            self._exit_stack = ExitStack()
+ 
+        # Reset resource count when context is closed (only for root contexts)
+        if self.parent is None:
+            self._resource_count_ref[0] = 0
+
+        # Remove this context from parent's child tracking
+        if self.parent is not None and self.parent.validate_nesting:
+            self.parent._child_contexts.discard(self)
+
+    def _close_with_timeout(self) -> None:
+        """Close with timeout using threading for timeout mechanism."""
+        import threading
+
+        cleanup_completed = threading.Event()
+        cleanup_error = None
+
+        def _do_cleanup():
+            nonlocal cleanup_error
+            try:
+                self._exit_stack.close()
+            except Exception as e:
+                cleanup_error = e
+            finally:
+                cleanup_completed.set()
+
+        # Start cleanup in a separate thread
+        cleanup_thread = threading.Thread(target=_do_cleanup, daemon=True)
+        cleanup_thread.start()
+
+        # Wait for completion or timeout
+        if cleanup_completed.wait(timeout=self.cleanup_timeout):
+            # Cleanup completed within timeout
+            if cleanup_error:
+                raise cleanup_error
+        else:
+            # Timeout exceeded - log warning and continue
+            # Note: The cleanup thread becomes a daemon and will be
+            # terminated when the main process exits
+            echo(
+                f"Warning: Cleanup operations timed out after "
+                f"{self.cleanup_timeout} seconds and were terminated.",
+                err=True,
+            )
+
         # In case the context is reused, create a new exit stack.
         self._exit_stack = ExitStack()
 
+        # Remove this context from parent's child tracking
+        if self.parent is not None and self.parent.validate_nesting:
+            self.parent._child_contexts.discard(self)
+
+    def save_state(self) -> dict[str, t.Any]:
+        """Create a snapshot of the current context state.
+ 
+        Returns a dictionary containing a deep copy of all relevant context
+        attributes including parameters, options, command metadata, and 
+        resource references. This snapshot can be used with restore_state()
+        to revert the context back to this saved state.
+ 
+        :return: Dictionary containing the context state snapshot
+        """
+        import copy
+        import pickle
+ 
+        # Create deep copies of all context attributes
+        snapshot = {}
+ 
+        # Core context data that needs deep copying
+        # Handle params carefully - some objects like file handles can't be deepcopied
+        params_copy = {}
+        for key, value in self.params.items():
+            try:
+                params_copy[key] = copy.deepcopy(value)
+            except (TypeError, pickle.PicklingError):
+                # For objects that can't be deepcopied (like file objects),
+                # just keep a reference - this is safe for shell completion use case
+                params_copy[key] = value
+        snapshot["params"] = params_copy
+        snapshot["args"] = copy.copy(self.args)
+        snapshot["protected_args"] = copy.copy(self._protected_args)
+        snapshot["opt_prefixes"] = copy.copy(self._opt_prefixes)
+        snapshot["obj"] = copy.deepcopy(self.obj)
+        snapshot["meta"] = copy.deepcopy(self._meta)
+        snapshot["parameter_source"] = copy.deepcopy(self._parameter_source)
+ 
+        # Other context attributes (shallow copy is sufficient for these)
+        snapshot["command"] = self.command
+        snapshot["info_name"] = self.info_name
+        snapshot["parent"] = self.parent
+        snapshot["invoked_subcommand"] = self.invoked_subcommand
+        snapshot["allow_extra_args"] = self.allow_extra_args
+        snapshot["allow_interspersed_args"] = self.allow_interspersed_args
+        snapshot["ignore_unknown_options"] = self.ignore_unknown_options
+        snapshot["help_option_names"] = copy.copy(self.help_option_names)
+        snapshot["token_normalize_func"] = self.token_normalize_func
+        snapshot["resilient_parsing"] = self.resilient_parsing
+        snapshot["auto_envvar_prefix"] = self.auto_envvar_prefix
+        snapshot["default_map"] = copy.deepcopy(self.default_map)
+        snapshot["terminal_width"] = self.terminal_width
+        snapshot["max_content_width"] = self.max_content_width
+        snapshot["color"] = self.color
+        snapshot["show_default"] = self.show_default
+ 
+        # New feature parameters
+        snapshot["on_exit"] = copy.copy(self.on_exit) if self.on_exit else None
+        snapshot["max_resources"] = self.max_resources
+        snapshot["cleanup_timeout"] = self.cleanup_timeout
+        snapshot["retry_cleanup"] = self.retry_cleanup
+        snapshot["validate_nesting"] = self.validate_nesting
+        snapshot["child_contexts"] = copy.copy(self._child_contexts)
+ 
+        return snapshot
+
+    def restore_state(self, snapshot: dict[str, t.Any]) -> None:
+        """Restore the context to a previously saved state.
+ 
+        Takes a snapshot dictionary created by save_state() and restores
+        all context attributes from that snapshot. This properly handles
+        nested objects by using the deep copies stored in the snapshot.
+ 
+        :param snapshot: Dictionary containing the context state snapshot
+        """
+        # Restore all attributes from the snapshot
+        self.params = snapshot["params"]
+        self.args = snapshot["args"]
+ 
+        # Handle attribute name variations
+        self._protected_args = snapshot["protected_args"]
+ 
+        self._opt_prefixes = snapshot["opt_prefixes"]
+ 
+        self.obj = snapshot["obj"]
+ 
+        self._meta = snapshot["meta"]
+ 
+        self._parameter_source = snapshot["parameter_source"]
+ 
+        # Restore other attributes
+        self.command = snapshot["command"]
+        self.info_name = snapshot["info_name"]
+        self.parent = snapshot["parent"]
+        self.invoked_subcommand = snapshot["invoked_subcommand"]
+        self.allow_extra_args = snapshot["allow_extra_args"]
+        self.allow_interspersed_args = snapshot["allow_interspersed_args"]
+        self.ignore_unknown_options = snapshot["ignore_unknown_options"]
+        self.help_option_names = snapshot["help_option_names"]
+        self.token_normalize_func = snapshot["token_normalize_func"]
+        self.resilient_parsing = snapshot["resilient_parsing"]
+        self.auto_envvar_prefix = snapshot["auto_envvar_prefix"]
+        self.default_map = snapshot["default_map"]
+        self.terminal_width = snapshot["terminal_width"]
+        self.max_content_width = snapshot["max_content_width"]
+        self.color = snapshot["color"]
+        self.show_default = snapshot["show_default"]
+ 
+        # Restore new feature parameters
+        self.on_exit = snapshot["on_exit"]
+        self.max_resources = snapshot["max_resources"]
+        self.cleanup_timeout = snapshot["cleanup_timeout"]
+        self.retry_cleanup = snapshot["retry_cleanup"]
+        self.validate_nesting = snapshot["validate_nesting"]
+        self._child_contexts = snapshot["child_contexts"]
+
     @property
     def command_path(self) -> str:
         """The computed command path.  This is used for the ``usage``
@@ -704,8 +994,8 @@ class Context:
         """Exits the application with a given exit code.
 
         .. versionchanged:: 8.2
-            Force closing of callbacks registered with
-            :meth:`call_on_close` before exiting the CLI.
+            Callbacks and context managers registered with :meth:`call_on_close`
+            and :meth:`with_resource` are closed before exiting.
         """
         self.close()
         raise Exit(code)
@@ -728,7 +1018,13 @@ class Context:
 
         :meta private:
         """
-        return type(self)(command, info_name=command.name, parent=self)
+        sub_ctx = type(self)(command, info_name=command.name, parent=self)
+ 
+        # Track child context for validation if enabled
+        if self.validate_nesting:
+            self._child_contexts.add(sub_ctx)
+ 
+        return sub_ctx
 
     @t.overload
     def invoke(
@@ -1140,10 +1436,14 @@ class Command:
         :param args: the arguments to parse as list of strings.
         :param parent: the parent context if available.
         :param extra: extra keyword arguments forwarded to the context
-                      constructor.
+                      constructor. This can include an `on_exit` callback
+                      that is invoked when the context exits.
 
         .. versionchanged:: 8.0
             Added the :attr:`context_class` attribute.
+
+        .. versionchanged:: 8.3
+            Added support for the `on_exit` callback parameter.
         """
         for key, value in self.context_settings.items():
             if key not in extra:
diff --git a/src/click/shell_completion.py b/src/click/shell_completion.py
index 6fd9e54..bfe25a9 100644
--- a/src/click/shell_completion.py
+++ b/src/click/shell_completion.py
@@ -544,44 +544,64 @@ def _resolve_context(
     :param args: List of complete args before the incomplete value.
     """
     ctx_args["resilient_parsing"] = True
-    ctx = cli.make_context(prog_name, args.copy(), **ctx_args)
-    args = ctx._protected_args + ctx.args
-
-    while args:
-        command = ctx.command
-
-        if isinstance(command, Group):
-            if not command.chain:
-                name, cmd, args = command.resolve_command(ctx, args)
-
-                if cmd is None:
-                    return ctx
-
-                ctx = cmd.make_context(name, args, parent=ctx, resilient_parsing=True)
-                args = ctx._protected_args + ctx.args
-            else:
-                sub_ctx = ctx
-
-                while args:
-                    name, cmd, args = command.resolve_command(ctx, args)
-
-                    if cmd is None:
-                        return ctx
-
-                    sub_ctx = cmd.make_context(
-                        name,
-                        args,
-                        parent=ctx,
-                        allow_extra_args=True,
-                        allow_interspersed_args=False,
-                        resilient_parsing=True,
-                    )
-                    args = sub_ctx.args
-
-                ctx = sub_ctx
-                args = [*sub_ctx._protected_args, *sub_ctx.args]
-        else:
-            break
+    # Disable resource limits during shell completion
+    ctx_args["max_resources"] = None
+    # Disable validation during shell completion
+    ctx_args["validate_nesting"] = False
+    # Don't run exit callbacks during shell completion
+    original_on_exit = ctx_args.pop("on_exit", None)
+    with cli.make_context(prog_name, args.copy(), **ctx_args) as ctx:
+        # Save the initial context state to prevent state leaks
+        initial_state = ctx.save_state()
+ 
+        try:
+            args = ctx._protected_args + ctx.args
+
+            while args:
+                command = ctx.command
+
+                if isinstance(command, Group):
+                    if not command.chain:
+                        name, cmd, args = command.resolve_command(ctx, args)
+
+                        if cmd is None:
+                            return ctx
+
+                        with cmd.make_context(
+                            name, args, parent=ctx, resilient_parsing=True, validate_nesting=False
+                        ) as sub_ctx:
+                            args = ctx._protected_args + ctx.args
+                            ctx = sub_ctx
+                    else:
+                        sub_ctx = ctx
+
+                        while args:
+                            name, cmd, args = command.resolve_command(ctx, args)
+
+                            if cmd is None:
+                                return ctx
+
+                            with cmd.make_context(
+                                name,
+                                args,
+                                parent=ctx,
+                                allow_extra_args=True,
+                                allow_interspersed_args=False,
+                                resilient_parsing=True,
+                                validate_nesting=False,
+                            ) as sub_sub_ctx:
+                                args = sub_ctx.args
+                                sub_ctx = sub_sub_ctx
+
+                        ctx = sub_ctx
+                        args = [*sub_ctx._protected_args, *sub_ctx.args]
+                else:
+                    break
+
+        except Exception:
+            # In case of any error, restore the initial state to prevent leaks
+            ctx.restore_state(initial_state)
+            raise
 
     return ctx
 
