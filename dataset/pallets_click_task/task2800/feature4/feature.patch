diff --git a/src/click/core.py b/src/click/core.py
index 666ad68..1b498e9 100644
--- a/src/click/core.py
+++ b/src/click/core.py
@@ -228,6 +228,10 @@ class Context:
         value is not set, it defaults to the value from the parent
         context. ``Command.show_default`` overrides this default for the
         specific command.
+    :param cleanup_timeout: Maximum time in seconds to wait for cleanup
+        operations during context teardown. If None, no timeout is applied.
+        When the timeout is exceeded, cleanup operations are forcibly
+        terminated to prevent hanging processes.
 
     .. versionchanged:: 8.2
         The ``protected_args`` attribute is deprecated and will be removed in
@@ -280,6 +284,7 @@ class Context:
         token_normalize_func: t.Callable[[str], str] | None = None,
         color: bool | None = None,
         show_default: bool | None = None,
+        cleanup_timeout: float | None = None,
     ) -> None:
         #: the parent context or `None` if none exists.
         self.parent = parent
@@ -427,6 +432,16 @@ class Context:
         #: Show option default values when formatting help text.
         self.show_default: bool | None = show_default
 
+        if cleanup_timeout is None and parent is not None:
+            cleanup_timeout = parent.cleanup_timeout
+
+        # Validate cleanup_timeout
+        if cleanup_timeout is not None and cleanup_timeout <= 0:
+            raise ValueError("cleanup_timeout must be greater than 0")
+
+        #: Maximum timeout for cleanup operations in seconds.
+        self.cleanup_timeout: float | None = cleanup_timeout
+
         self._close_callbacks: list[t.Callable[[], t.Any]] = []
         self._depth = 0
         self._parameter_source: dict[str, ParameterSource] = {}
@@ -606,8 +621,53 @@ class Context:
         """Invoke all close callbacks registered with
         :meth:`call_on_close`, and exit all context managers entered
         with :meth:`with_resource`.
+
+        If cleanup_timeout is specified, cleanup operations are limited
+        to that duration. If the timeout is exceeded, cleanup is
+        forcibly terminated to prevent hanging processes.
         """
-        self._exit_stack.close()
+        if self.cleanup_timeout is not None:
+            self._close_with_timeout()
+        else:
+            self._exit_stack.close()
+            # In case the context is reused, create a new exit stack.
+            self._exit_stack = ExitStack()
+
+    def _close_with_timeout(self) -> None:
+        """Close with timeout using threading for timeout mechanism."""
+        import threading
+
+        cleanup_completed = threading.Event()
+        cleanup_error = None
+
+        def _do_cleanup():
+            nonlocal cleanup_error
+            try:
+                self._exit_stack.close()
+            except Exception as e:
+                cleanup_error = e
+            finally:
+                cleanup_completed.set()
+
+        # Start cleanup in a separate thread
+        cleanup_thread = threading.Thread(target=_do_cleanup, daemon=True)
+        cleanup_thread.start()
+
+        # Wait for completion or timeout
+        if cleanup_completed.wait(timeout=self.cleanup_timeout):
+            # Cleanup completed within timeout
+            if cleanup_error:
+                raise cleanup_error
+        else:
+            # Timeout exceeded - log warning and continue
+            # Note: The cleanup thread becomes a daemon and will be
+            # terminated when the main process exits
+            echo(
+                f"Warning: Cleanup operations timed out after "
+                f"{self.cleanup_timeout} seconds and were terminated.",
+                err=True,
+            )
+
         # In case the context is reused, create a new exit stack.
         self._exit_stack = ExitStack()
 
@@ -1582,9 +1642,9 @@ class Group(Command):
         func: t.Callable[..., t.Any] | None = None
 
         if args and callable(args[0]):
-            assert (
-                len(args) == 1 and not kwargs
-            ), "Use 'command(**kwargs)(callable)' to provide arguments."
+            assert len(args) == 1 and not kwargs, (
+                "Use 'command(**kwargs)(callable)' to provide arguments."
+            )
             (func,) = args
             args = ()
 
@@ -1631,9 +1691,9 @@ class Group(Command):
         func: t.Callable[..., t.Any] | None = None
 
         if args and callable(args[0]):
-            assert (
-                len(args) == 1 and not kwargs
-            ), "Use 'group(**kwargs)(callable)' to provide arguments."
+            assert len(args) == 1 and not kwargs, (
+                "Use 'group(**kwargs)(callable)' to provide arguments."
+            )
             (func,) = args
             args = ()
 
