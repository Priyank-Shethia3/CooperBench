diff --git a/dirty_equals/__init__.py b/dirty_equals/__init__.py
index ba8214e..62d5008 100644
--- a/dirty_equals/__init__.py
+++ b/dirty_equals/__init__.py
@@ -18,63 +18,85 @@ from ._numeric import (
     IsPositiveFloat,
     IsPositiveInt,
 )
-from ._other import FunctionCheck, IsJson, IsUUID
+from ._other import (
+    FunctionCheck,
+    IsColor,
+    IsCreditCard,
+    IsEmail,
+    IsHash,
+    IsIP,
+    IsJson,
+    IsMac,
+    IsPhoneNumber,
+    IsRegex,
+    IsURL,
+    IsUUID,
+)
 from ._sequence import Contains, HasLen, IsList, IsListOrTuple, IsTuple
 from ._strings import IsAnyStr, IsBytes, IsStr
 
 __all__ = (
     # base
-    'DirtyEquals',
-    'AnyThing',
-    'IsOneOf',
+    "DirtyEquals",
+    "AnyThing",
+    "IsOneOf",
     # boolean
-    'IsTrueLike',
-    'IsFalseLike',
+    "IsTrueLike",
+    "IsFalseLike",
     # datetime
-    'IsDatetime',
-    'IsNow',
-    'IsDate',
-    'IsToday',
+    "IsDatetime",
+    "IsNow",
+    "IsDate",
+    "IsToday",
     # dict
-    'IsDict',
-    'IsPartialDict',
-    'IsIgnoreDict',
-    'IsStrictDict',
+    "IsDict",
+    "IsPartialDict",
+    "IsIgnoreDict",
+    "IsStrictDict",
     # sequence
-    'Contains',
-    'HasLen',
-    'IsList',
-    'IsTuple',
-    'IsListOrTuple',
+    "Contains",
+    "HasLen",
+    "IsList",
+    "IsTuple",
+    "IsListOrTuple",
     # numeric
-    'IsNumeric',
-    'IsApprox',
-    'IsNumber',
-    'IsPositive',
-    'IsNegative',
-    'IsNonPositive',
-    'IsNonNegative',
-    'IsInt',
-    'IsPositiveInt',
-    'IsNegativeInt',
-    'IsFloat',
-    'IsPositiveFloat',
-    'IsNegativeFloat',
+    "IsNumeric",
+    "IsApprox",
+    "IsNumber",
+    "IsPositive",
+    "IsNegative",
+    "IsNonPositive",
+    "IsNonNegative",
+    "IsInt",
+    "IsPositiveInt",
+    "IsNegativeInt",
+    "IsFloat",
+    "IsPositiveFloat",
+    "IsNegativeFloat",
     # inspection
-    'HasAttributes',
-    'HasName',
-    'HasRepr',
-    'IsInstance',
+    "HasAttributes",
+    "HasName",
+    "HasRepr",
+    "IsInstance",
     # other
-    'FunctionCheck',
-    'IsJson',
-    'IsUUID',
+    "FunctionCheck",
+    "IsColor",
+    "IsCreditCard",
+    "IsEmail",
+    "IsHash",
+    "IsIP",
+    "IsJson",
+    "IsMac",
+    "IsPhoneNumber",
+    "IsRegex",
+    "IsURL",
+    "IsUUID",
     # strings
-    'IsStr',
-    'IsBytes',
-    'IsAnyStr',
+    "IsStr",
+    "IsBytes",
+    "IsAnyStr",
     # version
-    '__version__',
+    "__version__",
 )
 
-__version__ = '0.0.dev0'
+__version__ = "0.0.dev0"
diff --git a/dirty_equals/_other.py b/dirty_equals/_other.py
index b2b8379..2dfbb77 100644
--- a/dirty_equals/_other.py
+++ b/dirty_equals/_other.py
@@ -1,9 +1,12 @@
 import json
-from typing import Any, Callable, TypeVar, overload
+import re
+from ipaddress import IPv4Address, IPv4Network, IPv6Address, IPv6Network, ip_network
+from typing import Any, Callable, List, Optional, TypeVar, Union, overload
+from urllib.parse import urlparse
 from uuid import UUID
 
 from ._base import DirtyEquals
-from ._utils import plain_repr
+from ._utils import Omit, plain_repr
 
 try:
     from typing import Literal
@@ -33,7 +36,7 @@ class IsUUID(DirtyEquals[UUID]):
         ```
         """
         self.version = version
-        super().__init__(version or plain_repr('*'))
+        super().__init__(version or plain_repr("*"))
 
     def equals(self, other: Any) -> bool:
         if isinstance(other, UUID):
@@ -52,7 +55,7 @@ class IsUUID(DirtyEquals[UUID]):
 
 
 AnyJson = object
-JsonType = TypeVar('JsonType', AnyJson, Any)
+JsonType = TypeVar("JsonType", AnyJson, Any)
 
 
 class IsJson(DirtyEquals[JsonType]):
@@ -61,12 +64,10 @@ class IsJson(DirtyEquals[JsonType]):
     """
 
     @overload
-    def __init__(self, expected_value: JsonType = AnyJson):
-        ...
+    def __init__(self, expected_value: JsonType = AnyJson): ...
 
     @overload
-    def __init__(self, **expected_kwargs: Any):
-        ...
+    def __init__(self, **expected_kwargs: Any): ...
 
     def __init__(self, expected_value: JsonType = AnyJson, **expected_kwargs: Any):
         """
@@ -100,13 +101,13 @@ class IsJson(DirtyEquals[JsonType]):
         """
         if expected_kwargs:
             if expected_value is not AnyJson:
-                raise TypeError('IsJson requires either an argument or kwargs, not both')
+                raise TypeError("IsJson requires either an argument or kwargs, not both")
             self.expected_value: Any = expected_kwargs
         else:
             self.expected_value = expected_value
-        super().__init__(plain_repr('*') if expected_value is AnyJson else expected_value)
+        super().__init__(plain_repr("*") if expected_value is AnyJson else expected_value)
 
-    def __class_getitem__(cls, expected_type: JsonType) -> 'IsJson[JsonType]':
+    def __class_getitem__(cls, expected_type: JsonType) -> "IsJson[JsonType]":
         return cls(expected_type)
 
     def equals(self, other: Any) -> bool:
@@ -145,3 +146,602 @@ class FunctionCheck(DirtyEquals[Any]):
 
     def equals(self, other: Any) -> bool:
         return self.func(other)
+
+
+IP = TypeVar("IP", IPv4Address, IPv4Network, IPv6Address, IPv6Network, Union[str, int, bytes])
+
+
+class IsIP(DirtyEquals[IP]):
+    """
+    A class that checks if a value is a valid IP address, optionally checking IP version, netmask.
+    """
+
+    def __init__(self, *, version: Literal[None, 4, 6] = None, netmask: Optional[str] = None):
+        """
+        Args:
+            version: The version of the IP to check, if omitted, versions 4 and 6 are both accepted.
+            netmask: The netmask of the IP to check, if omitted, any netmask is accepted. Requires version.
+
+        ```py title="IsIP"
+        from ipaddress import IPv4Address, IPv6Address, IPv4Network
+        from dirty_equals import IsIP
+
+        assert '179.27.154.96' == IsIP
+        assert '179.27.154.96' == IsIP(version=4)
+        assert '2001:0db8:0a0b:12f0:0000:0000:0000:0001' == IsIP(version=6)
+        assert IPv4Address('127.0.0.1') == IsIP
+        assert IPv4Network('43.48.0.0/12') == IsIP
+        assert IPv6Address('::eeff:ae3f:d473') == IsIP
+        assert '54.43.53.219/10' == IsIP(version=4, netmask='255.192.0.0')
+        assert '54.43.53.219/10' == IsIP(version=4, netmask=4290772992)
+        assert '::ffff:aebf:d473/12' == IsIP(version=6, netmask='fff0::')
+        assert 3232235521 == IsIP
+        ```
+        """
+        self.version = version
+        if netmask and not self.version:
+            raise TypeError("To check the netmask you must specify the IP version")
+        self.netmask = netmask
+        super().__init__(version=version or Omit, netmask=netmask or Omit)
+
+    def equals(self, other: Any) -> bool:
+        if isinstance(other, (IPv4Network, IPv6Network)):
+            ip = other
+        elif isinstance(other, (str, bytes, int, IPv4Address, IPv6Address)):
+            ip = ip_network(other, strict=False)
+        else:
+            return False
+
+        if self.version:
+            if self.netmask:
+                version_check = self.version == ip.version
+                address_format = {4: IPv4Address, 6: IPv6Address}[self.version]
+                netmask_check = int(address_format(self.netmask)) == int(ip.netmask)
+                return version_check and netmask_check
+            elif self.version != ip.version:
+                return False
+
+        return True
+
+
+class IsMac(DirtyEquals[str]):
+    """
+    A class that checks if a value is a valid MAC address, optionally checking format.
+    """
+
+    def __init__(self, format: Literal[None, "colon", "hyphen", "dot", "compact"] = None):
+        """
+        Args:
+            format: The format of the MAC address to check, if omitted, all formats are accepted.
+                - 'colon': colon-separated format (e.g., '00:1B:44:11:3A:B7')
+                - 'hyphen': hyphen-separated format (e.g., '00-1B-44-11-3A-B7')
+                - 'dot': dot-separated format (e.g., '001B.4411.3AB7')
+                - 'compact': compact format without separators (e.g., '001b44113ab7')
+
+        ```py title="IsMac"
+        from dirty_equals import IsMac
+
+        assert '00:1B:44:11:3A:B7' == IsMac
+        assert '00-1B-44-11-3A-B7' == IsMac
+        assert '001B.4411.3AB7' == IsMac
+        assert '001b44113ab7' == IsMac
+        assert '00:1B:44:11:3A:B7' == IsMac('colon')
+        assert '00-1B-44-11-3A-B7' == IsMac('hyphen')
+        assert '001B.4411.3AB7' == IsMac('dot')
+        assert '001b44113ab7' == IsMac('compact')
+        assert '00:1B:44:11:3A:B7' != IsMac('hyphen')
+        ```
+        """
+        self.format = format
+        super().__init__(format or plain_repr("*"))
+
+    def equals(self, other: Any) -> bool:
+        if not isinstance(other, str):
+            return False
+
+        # Define regex patterns for different MAC address formats
+        patterns = {
+            "colon": r"^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$",
+            "hyphen": r"^([0-9A-Fa-f]{2}-){5}[0-9A-Fa-f]{2}$",
+            "dot": r"^([0-9A-Fa-f]{4}\.){2}[0-9A-Fa-f]{4}$",
+            "compact": r"^[0-9A-Fa-f]{12}$",
+        }
+
+        if self.format:
+            # Check specific format
+            return bool(re.match(patterns[self.format], other))
+        else:
+            # Check any valid format
+            return any(re.match(pattern, other) for pattern in patterns.values())
+
+
+class IsEmail(DirtyEquals[str]):
+    """
+    A class that checks if a value is a valid email address, optionally checking domain.
+    """
+
+    def __init__(self, domain: Optional[str] = None):
+        """
+        Args:
+            domain: The domain to check, if omitted, any valid email format is accepted.
+
+        ```py title="IsEmail"
+        from dirty_equals import IsEmail
+
+        assert 'user@example.com' == IsEmail
+        assert 'user@example.com' == IsEmail(domain='example.com')
+        assert 'user@other.com' != IsEmail(domain='example.com')
+        assert 'invalid-email' != IsEmail
+        ```
+        """
+        self.domain = domain
+        # Basic email regex pattern
+        self._email_pattern = re.compile(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$")
+        super().__init__(domain or plain_repr("*"))
+
+    def equals(self, other: Any) -> bool:
+        if not isinstance(other, str):
+            return False
+
+        # Check basic email format
+        if not self._email_pattern.match(other):
+            return False
+
+        # If domain is specified, check it matches
+        if self.domain is not None:
+            email_domain = other.split("@")[1]
+            return email_domain == self.domain
+
+        return True
+
+
+class IsURL(DirtyEquals[str]):
+    """
+    A class that checks if a value is a valid URL, optionally checking protocol and domain.
+    """
+
+    def __init__(self, protocol: Union[str, list[str], None] = None, domain: Union[str, None] = None):
+        """
+        Args:
+            protocol: The protocol(s) to check, if omitted, all protocols are accepted.
+                     Can be a single protocol string or a list of allowed protocols.
+            domain: The domain to check, if omitted, all domains are accepted.
+
+        ```py title="IsURL"
+        from dirty_equals import IsURL
+
+        assert 'https://example.com' == IsURL
+        assert 'https://example.com/path' == IsURL(protocol='https')
+        assert 'http://example.com' == IsURL(protocol=['http', 'https'])
+        assert 'https://example.com' == IsURL(domain='example.com')
+        assert 'https://example.com' == IsURL(protocol='https', domain='example.com')
+        assert 'ftp://example.com' != IsURL(protocol='https')
+        ```
+        """
+        self.protocol = protocol
+        self.domain = domain
+
+        # Build repr args
+        repr_args = []
+        if protocol is not None:
+            repr_args.append(protocol)
+        if domain is not None:
+            repr_args.append(domain)
+
+        if not repr_args:
+            super().__init__(plain_repr("*"))
+        else:
+            super().__init__(*repr_args)
+
+    def equals(self, other: Any) -> bool:
+        if not isinstance(other, str):
+            return False
+
+        try:
+            parsed = urlparse(other)
+        except Exception:
+            return False
+
+        # Check if URL has required components (scheme and netloc)
+        if not parsed.scheme or not parsed.netloc:
+            return False
+
+        # Check protocol if specified
+        if self.protocol is not None:
+            if isinstance(self.protocol, str):
+                if parsed.scheme != self.protocol:
+                    return False
+            elif isinstance(self.protocol, list):
+                if parsed.scheme not in self.protocol:
+                    return False
+
+        # Check domain if specified
+        if self.domain is not None:
+            if parsed.netloc != self.domain:
+                return False
+
+        return True
+
+
+class IsPhoneNumber(DirtyEquals[str]):
+    """
+    A class that checks if a value is a valid phone number, optionally checking country-specific formats.
+    """
+
+    def __init__(self, country: Optional[str] = None):
+        """
+        Args:
+            country: The country code to validate against (e.g., 'US', 'GB'), if omitted, any valid phone number format is accepted.
+
+        ```py title="IsPhoneNumber"
+        from dirty_equals import IsPhoneNumber
+
+        assert '+1-555-123-4567' == IsPhoneNumber()
+        assert '555-123-4567' == IsPhoneNumber('US')
+        assert '+44 20 7946 0958' == IsPhoneNumber('GB')
+        assert '(555) 123-4567' == IsPhoneNumber('US')
+        assert '+1 555 123 4567' == IsPhoneNumber()
+        assert 'invalid-phone' != IsPhoneNumber()
+        ```
+        """
+        self.country = country
+        super().__init__(country or plain_repr("*"))
+
+    def equals(self, other: Any) -> bool:
+        if not isinstance(other, str):
+            return False
+
+        # Normalize the phone number by removing common separators
+        normalized = re.sub(r"[\s\-\(\)\.]", "", other)
+
+        # Basic phone number patterns
+        if self.country is None:
+            # International format with country code
+            international_pattern = r"^\+\d{1,4}\d{7,15}$"
+            # National format (7-15 digits)
+            national_pattern = r"^\d{7,15}$"
+
+            return bool(re.match(international_pattern, normalized) or re.match(national_pattern, normalized))
+
+        elif self.country.upper() == "US":
+            # US phone number patterns
+            # With country code: +1 followed by 10 digits
+            us_international = r"^\+1\d{10}$"
+            # Without country code: 10 digits (area code + number)
+            us_national = r"^\d{10}$"
+
+            return bool(re.match(us_international, normalized) or re.match(us_national, normalized))
+
+        elif self.country.upper() == "GB":
+            # UK phone number patterns
+            # With country code: +44 followed by 10-11 digits
+            gb_international = r"^\+44\d{10,11}$"
+            # Without country code: 10-11 digits starting with 0
+            gb_national = r"^0\d{9,10}$"
+
+            return bool(re.match(gb_international, normalized) or re.match(gb_national, normalized))
+
+        else:
+            # For other countries, use a generic international pattern
+            # Country code (1-4 digits) + phone number (7-15 digits)
+            generic_pattern = r"^\+\d{1,4}\d{7,15}$"
+            return bool(re.match(generic_pattern, normalized))
+
+
+class IsCreditCard(DirtyEquals[str]):
+    """
+    Validates credit card numbers using the Luhn algorithm with optional issuer-specific checks.
+
+    Supports string or integer inputs, ignores common formatting (spaces and dashes), and can
+    restrict to a specific issuer (e.g., 'Visa', 'Mastercard', 'AmericanExpress').
+    """
+
+    try:
+        from typing import Literal as _Literal
+    except Exception:  # pragma: no cover - fallback for older Python versions
+        from typing_extensions import Literal as _Literal  # type: ignore
+
+    Issuer = _Literal["Visa", "Mastercard", "AmericanExpress"]
+
+    def __init__(self, issuer: Issuer = None):  # type: ignore[assignment]
+        """
+        Args:
+            issuer: Optional issuer/brand to validate against. Supported: 'Visa', 'Mastercard', 'AmericanExpress'.
+
+        Examples:
+            >>> from dirty_equals import IsCreditCard
+            >>> '4111 1111 1111 1111' == IsCreditCard
+            True
+            >>> '4111-1111-1111-1111' == IsCreditCard('Visa')
+            True
+            >>> 4111111111111111 == IsCreditCard['Visa']
+            True
+            >>> '378282246310005' == IsCreditCard('AmericanExpress')
+            True
+            >>> '5555555555554444' == IsCreditCard('Mastercard')
+            True
+            >>> '5555555555554444' == IsCreditCard('Visa')
+            False
+        """
+        self.issuer = issuer
+        super().__init__(issuer=issuer or Omit)
+
+    @classmethod
+    def __class_getitem__(cls, issuer: "IsCreditCard.Issuer") -> "IsCreditCard":
+        return cls(issuer)
+
+    def equals(self, other: Any) -> bool:
+        # normalize input
+        if isinstance(other, int):
+            if other < 0:
+                return False
+            num = str(other)
+        elif isinstance(other, str):
+            s = other.strip()
+            # remove spaces and dashes
+            num = s.replace(" ", "").replace("-", "")
+        else:
+            return False
+
+        if not num or not num.isdigit():
+            return False
+
+        # issuer-specific check (prefix and length) if provided
+        if self.issuer is not None:
+            if not self._matches_issuer(num, self.issuer):
+                return False
+        else:
+            # If no issuer specified, still ensure number looks like a plausible PAN length
+            if not self._plausible_length(num):
+                return False
+
+        # Luhn checksum validation
+        if not self._luhn_valid(num):
+            return False
+
+        return True
+
+    # Helper methods
+    @staticmethod
+    def _plausible_length(num: str) -> bool:
+        # Common PAN lengths: 12-19; but most issuers use 13-19. We'll use 12-19 to be permissive
+        # and rely on Luhn for mathematical validity, while also catching too-short/too-long.
+        n = len(num)
+        return 12 <= n <= 19
+
+    @staticmethod
+    def _luhn_valid(num: str) -> bool:
+        total = 0
+        reverse_digits = num[::-1]
+        for i, ch in enumerate(reverse_digits):
+            d = ord(ch) - 48  # faster than int(ch)
+            if i % 2 == 1:
+                d *= 2
+                if d > 9:
+                    d -= 9
+            total += d
+        return total % 10 == 0
+
+    @classmethod
+    def _matches_issuer(cls, num: str, issuer: "IsCreditCard.Issuer") -> bool:  # type: ignore[override]
+        length = len(num)
+        if issuer == "Visa":
+            # Prefix 4; lengths 13, 16, 19
+            return num.startswith("4") and length in (13, 16, 19)
+        elif issuer == "Mastercard":
+            # Prefix 51-55 or 2221-2720; length 16
+            if length != 16:
+                return False
+            p2 = int(num[:2])
+            if 51 <= p2 <= 55:
+                return True
+            p4 = int(num[:4])
+            return 2221 <= p4 <= 2720
+        elif issuer == "AmericanExpress":
+            # Prefix 34 or 37; length 15
+            return length == 15 and (num.startswith("34") or num.startswith("37"))
+        else:
+            # Unknown issuer string: reject to avoid silent acceptance
+            return False
+
+
+class IsHash(DirtyEquals[str]):
+    """
+    A class that checks if a value is a valid cryptographic hash for the specified algorithm.
+    """
+
+    # Hash algorithm specifications: (length, case_sensitive)
+    _ALGORITHMS = {
+        "md5": 32,
+        "sha1": 40,
+        "sha224": 56,
+        "sha256": 64,
+        "sha384": 96,
+        "sha512": 128,
+    }
+
+    def __init__(self, algorithm: str):
+        """
+        Args:
+            algorithm: The hash algorithm to validate against (md5, sha1, sha224, sha256, sha384, sha512).
+
+        ```py title="IsHash"
+        from dirty_equals import IsHash
+
+        assert 'd41d8cd98f00b204e9800998ecf8427e' == IsHash('md5')
+        assert 'da39a3ee5e6b4b0d3255bfef95601890afd80709' == IsHash('sha1')
+        assert 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855' == IsHash('sha256')
+        assert 'invalid' != IsHash('md5')
+        ```
+        """
+        algorithm = algorithm.lower()
+        if algorithm not in self._ALGORITHMS:
+            raise ValueError(
+                f"Unsupported hash algorithm: {algorithm}. Supported algorithms: {', '.join(self._ALGORITHMS.keys())}"
+            )
+
+        self.algorithm = algorithm
+        self.expected_length = self._ALGORITHMS[algorithm]
+        super().__init__(algorithm)
+
+    def equals(self, other: Any) -> bool:
+        if not isinstance(other, str):
+            return False
+
+        # Check length
+        if len(other) != self.expected_length:
+            return False
+
+        # Check if it's a valid hexadecimal string (case insensitive)
+        return bool(re.match(r"^[0-9a-fA-F]+$", other))
+
+
+class IsRegex(DirtyEquals[str]):
+    """
+    A class that checks if a string matches a regular expression pattern.
+    """
+
+    def __init__(self, pattern: str, flags: int = 0):
+        r"""
+        Args:
+            pattern: The regular expression pattern to match against.
+            flags: Optional regex flags (e.g., re.IGNORECASE, re.MULTILINE).
+
+        ```py title="IsRegex"
+        from dirty_equals import IsRegex
+        import re
+
+        assert 'abc123' == IsRegex(r'^[a-z]+\d+$')
+        assert 'ABC123' == IsRegex(r'^[a-z]+\d+$', re.IGNORECASE)
+        assert 'hello@example.com' == IsRegex(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
+        assert 'invalid' != IsRegex(r'^\d+$')
+        ```
+        """
+        self.pattern = pattern
+        self.flags = flags
+        self.compiled_pattern = re.compile(pattern, flags)
+        if flags:
+            super().__init__(pattern, flags)
+        else:
+            super().__init__(pattern)
+
+    def equals(self, other: Any) -> bool:
+        if not isinstance(other, str):
+            return False
+        return bool(self.compiled_pattern.match(other))
+
+
+class IsColor(DirtyEquals[str]):
+    """
+    A class that checks if a value is a valid color code in hex, RGB, or HSL format.
+    """
+
+    def __init__(self, format: Literal[None, "hex", "rgb", "hsl"] = None):
+        """
+        Args:
+            format: The color format to validate against. If None, accepts any valid format.
+
+        ```py title="IsColor"
+        from dirty_equals import IsColor
+
+        # Hex colors
+        assert '#FF5733' == IsColor
+        assert '#f57' == IsColor
+        assert 'FF5733' == IsColor('hex')
+        assert '#FF5733' == IsColor('hex')
+
+        # RGB colors
+        assert 'rgb(255, 87, 51)' == IsColor
+        assert 'rgb(255,87,51)' == IsColor('rgb')
+        assert 'rgb(100%, 34%, 20%)' == IsColor('rgb')
+
+        # HSL colors
+        assert 'hsl(14, 100%, 60%)' == IsColor
+        assert 'hsl(14,100%,60%)' == IsColor('hsl')
+        assert 'hsl(14deg, 100%, 60%)' == IsColor('hsl')
+
+        # Invalid colors
+        assert 'not-a-color' != IsColor
+        assert '#GG5733' != IsColor('hex')
+        assert 'rgb(300, 87, 51)' != IsColor('rgb')
+        ```
+        """
+        self.format = format
+
+        # Regex patterns for different color formats
+        self._hex_pattern = re.compile(r"^#?([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$")
+        self._rgb_pattern = re.compile(
+            r"^rgb\(\s*(\d{1,3}|100%|\d{1,2}%)\s*,\s*(\d{1,3}|100%|\d{1,2}%)\s*,\s*(\d{1,3}|100%|\d{1,2}%)\s*\)$"
+        )
+        self._hsl_pattern = re.compile(r"^hsl\(\s*(\d{1,3}(?:deg)?)\s*,\s*(\d{1,3}%)\s*,\s*(\d{1,3}%)\s*\)$")
+
+        super().__init__(format or plain_repr("*"))
+
+    def equals(self, other: Any) -> bool:
+        if not isinstance(other, str):
+            return False
+
+        other = other.strip()
+
+        if self.format == "hex":
+            return self._is_valid_hex(other)
+        elif self.format == "rgb":
+            return self._is_valid_rgb(other)
+        elif self.format == "hsl":
+            return self._is_valid_hsl(other)
+        else:
+            # No specific format, check all formats
+            return self._is_valid_hex(other) or self._is_valid_rgb(other) or self._is_valid_hsl(other)
+
+    def _is_valid_hex(self, value: str) -> bool:
+        return bool(self._hex_pattern.match(value))
+
+    def _is_valid_rgb(self, value: str) -> bool:
+        match = self._rgb_pattern.match(value)
+        if not match:
+            return False
+
+        # Check if all components are of the same format (all percentage or all integer)
+        components = match.groups()
+        has_percent = any(comp.endswith("%") for comp in components)
+        all_percent = all(comp.endswith("%") for comp in components)
+
+        # Mixed format is not allowed
+        if has_percent and not all_percent:
+            return False
+
+        # Validate RGB values
+        for component in components:
+            if component.endswith("%"):
+                # Percentage value
+                percent = int(component[:-1])
+                if percent < 0 or percent > 100:
+                    return False
+            else:
+                # Integer value
+                val = int(component)
+                if val < 0 or val > 255:
+                    return False
+
+        return True
+
+    def _is_valid_hsl(self, value: str) -> bool:
+        match = self._hsl_pattern.match(value)
+        if not match:
+            return False
+
+        hue_str, sat_str, light_str = match.groups()
+
+        # Validate hue (0-360)
+        hue = int(hue_str.replace("deg", ""))
+        if hue < 0 or hue > 360:
+            return False
+
+        # Validate saturation and lightness (0-100%)
+        sat = int(sat_str[:-1])  # Remove %
+        light = int(light_str[:-1])  # Remove %
+
+        if sat < 0 or sat > 100 or light < 0 or light > 100:
+            return False
+
+        return True
