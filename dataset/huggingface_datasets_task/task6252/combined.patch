diff --git a/src/datasets/features/image.py b/src/datasets/features/image.py
index 7555e160a..3049f0def 100644
--- a/src/datasets/features/image.py
+++ b/src/datasets/features/image.py
@@ -84,10 +84,14 @@ class Image:
     mode: Optional[str] = None
     decode: bool = True
     id: Optional[str] = None
+    crop_to_square: bool = False
+    max_resolution: Optional[int] = None  # New parameter to clamp image size
+    crop_margin: Optional[int] = None
     # Automatically constructed
     dtype: ClassVar[str] = "PIL.Image.Image"
     pa_type: ClassVar[Any] = pa.struct({"bytes": pa.binary(), "path": pa.string()})
     _type: str = field(default="Image", init=False, repr=False)
+    as_array: bool = False
 
     def __call__(self):
         return self.pa_type
@@ -131,7 +135,7 @@ class Image:
                 f"An image sample should have one of 'path' or 'bytes' but they are missing or None in {value}."
             )
 
-    def decode_example(self, value: dict, token_per_repo_id=None) -> "PIL.Image.Image":
+    def decode_example(self, value: dict, token_per_repo_id=None) -> Union[np.ndarray,"PIL.Image.Image"]:
         """Decode example image file into image data.
 
         Args:
@@ -154,6 +158,7 @@ class Image:
 
         if config.PIL_AVAILABLE:
             import PIL.Image
+            import PIL.ImageOps
         else:
             raise ImportError("To support decoding images, please install 'Pillow'.")
 
@@ -186,9 +191,37 @@ class Image:
         else:
             image = PIL.Image.open(BytesIO(bytes_))
         image.load()  # to avoid "Too many open files" errors
+        if self.crop_to_square:
+            width, height = image.size
+            if width != height:
+                min_dim = min(width, height)
+                left = (width - min_dim) // 2
+                top = (height - min_dim) // 2
+                right = left + min_dim
+                bottom = top + min_dim
+                image = image.crop((left, top, right, bottom))
+        if image.getexif().get(PIL.Image.ExifTags.Base.Orientation) is not None:
+            image = PIL.ImageOps.exif_transpose(image)
+        # auto-convert CMYK images to RGB for compatibility
+        if image.mode == "CMYK":
+            image = image.convert("RGB")
+        # apply userâ€‘requested mode conversion if specified
         if self.mode and self.mode != image.mode:
             image = image.convert(self.mode)
-        return image
+        if self.crop_margin:
+            width, height = image.size
+            margin = self.crop_margin
+            if margin * 2 < width and margin * 2 < height:
+                image = image.crop((margin, margin, width - margin, height - margin))
+        if self.max_resolution is not None:
+            max_size = (self.max_resolution, self.max_resolution)
+            if image.size[0] > max_size[0] or image.size[1] > max_size[1]:
+                image.thumbnail(max_size, PIL.Image.Resampling.LANCZOS)
+        if self.as_array:
+            image_array = np.asarray(image).astype(np.float32) / 255.0
+            return image_array
+        else:
+            return image
 
     def flatten(self) -> Union["FeatureType", Dict[str, "FeatureType"]]:
         """If in the decodable state, return the feature itself, otherwise flatten the feature into a dictionary."""
