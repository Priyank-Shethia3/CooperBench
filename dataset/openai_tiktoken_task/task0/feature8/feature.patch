diff --git a/tiktoken/core.py b/tiktoken/core.py
index 6bc9736..030e173 100644
--- a/tiktoken/core.py
+++ b/tiktoken/core.py
@@ -82,7 +82,8 @@ class Encoding:
         *,
         allowed_special: Literal["all"] | AbstractSet[str] = set(),  # noqa: B006
         disallowed_special: Literal["all"] | Collection[str] = "all",
-    ) -> list[int]:
+        return_repeated_pattern: bool = False,
+    ) -> list[int] | tuple[list[int], dict[tuple[int, int], int]]:
         """Encodes a string into tokens.
 
         Special tokens are artificial tokens used to unlock capabilities from a model,
@@ -93,9 +94,21 @@ class Encoding:
         to a special token. This can be controlled on a per-token level using the `allowed_special`
         and `disallowed_special` parameters. In particular:
         - Setting `disallowed_special` to () will prevent this function from raising errors and
-          cause all text corresponding to special tokens to be encoded as natural text.
+        cause all text corresponding to special tokens to be encoded as natural text.
         - Setting `allowed_special` to "all" will cause this function to treat all text
-          corresponding to special tokens to be encoded as special tokens.
+        corresponding to special tokens to be encoded as special tokens.
+
+        Args:
+            text: The text to encode.
+            allowed_special: Set of special tokens that are allowed to be in the text.
+            disallowed_special: Set of special tokens that are not allowed to be in the text.
+            return_repeated_pattern: If True, return a tuple of (tokens, pattern) where pattern
+                is a dictionary containing the top 3 most frequent token pairs and their frequencies.
+
+        Returns:
+            If return_repeated_pattern is False, returns a list of token IDs.
+            If return_repeated_pattern is True, returns a tuple of (tokens, pattern) where pattern
+                is a dictionary containing the most frequent token pairs and their frequencies.
 
         ```
         >>> enc.encode("hello world")
@@ -108,6 +121,8 @@ class Encoding:
         # Raises ValueError
         >>> enc.encode("<|endoftext|>", disallowed_special=())
         [27, 91, 437, 1659, 5239, 91, 29]
+        >>> enc.encode("hello world", return_repeated_pattern=True)
+        ([31373, 995], {})
         ```
         """
         if allowed_special == "all":
@@ -121,7 +136,7 @@ class Encoding:
                 raise_disallowed_special_token(match.group())
 
         try:
-            return self._core_bpe.encode(text, allowed_special)
+            tokens = self._core_bpe.encode(text, allowed_special)
         except UnicodeEncodeError:
             # BPE operates on bytes, but the regex operates on unicode. If we pass a str that is
             # invalid UTF-8 to Rust, it will rightfully complain. Here we do a quick and dirty
@@ -130,7 +145,28 @@ class Encoding:
             # string, but given that this is input we want to support, maybe that's okay.
             # Also we use errors="replace" to handle weird things like lone surrogates.
             text = text.encode("utf-16", "surrogatepass").decode("utf-16", "replace")
-            return self._core_bpe.encode(text, allowed_special)
+            tokens = self._core_bpe.encode(text, allowed_special)
+ 
+        if not return_repeated_pattern:
+            return tokens
+ 
+        # Count token pairs and their frequencies
+        pair_counts = {}
+ 
+        if len(tokens) > 0:
+            # Count each adjacent pair of tokens
+            for i in range(len(tokens) - 1):
+                current_pair = (tokens[i], tokens[i+1])
+                pair_counts[current_pair] = pair_counts.get(current_pair, 0) + 1
+ 
+            # The test description mentions returning top 3 most frequent token pairs
+            # Get the top 3 pairs by frequency
+            if len(pair_counts) > 3:
+                sorted_pairs = sorted(pair_counts.items(), key=lambda x: x[1], reverse=True)
+                top_3_pairs = dict(sorted_pairs[:3])
+                pair_counts = top_3_pairs
+ 
+        return tokens, pair_counts
 
     def encode_to_numpy(
         self,
