diff --git a/tiktoken/core.py b/tiktoken/core.py
index 6bc9736..8b86b1c 100644
--- a/tiktoken/core.py
+++ b/tiktoken/core.py
@@ -76,12 +76,28 @@ class Encoding:
             text = text.encode("utf-16", "surrogatepass").decode("utf-16", "replace")
             return self._core_bpe.encode_ordinary(text)
 
+    def _filter_tokens(self, tokens: list[int], filter_tokens: list[int]) -> list[int]:
+        """Filter out specified tokens from the encoded result.
+
+        Args:
+            tokens: List of token IDs to filter
+            filter_tokens: List of token IDs to remove from the result
+
+        Returns:
+            Filtered list of token IDs
+        """
+        if not filter_tokens:
+            return tokens
+ 
+        return [token for token in tokens if token not in filter_tokens]
+
     def encode(
         self,
         text: str,
         *,
         allowed_special: Literal["all"] | AbstractSet[str] = set(),  # noqa: B006
         disallowed_special: Literal["all"] | Collection[str] = "all",
+        filter_tokens: list[int] = None,  # New parameter for token filtering
     ) -> list[int]:
         """Encodes a string into tokens.
 
@@ -97,6 +113,12 @@ class Encoding:
         - Setting `allowed_special` to "all" will cause this function to treat all text
           corresponding to special tokens to be encoded as special tokens.
 
+        Args:
+            text: The text to encode
+            allowed_special: Special tokens allowed to be encoded as special tokens
+            disallowed_special: Special tokens that will raise an error if encountered
+            filter_tokens: List of token IDs to filter out from the encoded result
+
         ```
         >>> enc.encode("hello world")
         [31373, 995]
@@ -108,8 +130,13 @@ class Encoding:
         # Raises ValueError
         >>> enc.encode("<|endoftext|>", disallowed_special=())
         [27, 91, 437, 1659, 5239, 91, 29]
+        >>> enc.encode("I love you", filter_tokens=[40])
+        [32, 3021]
         ```
         """
+        if filter_tokens is None:
+            filter_tokens = []
+ 
         if allowed_special == "all":
             allowed_special = self.special_tokens_set
         if disallowed_special == "all":
@@ -121,7 +148,7 @@ class Encoding:
                 raise_disallowed_special_token(match.group())
 
         try:
-            return self._core_bpe.encode(text, allowed_special)
+            tokens = self._core_bpe.encode(text, allowed_special)
         except UnicodeEncodeError:
             # BPE operates on bytes, but the regex operates on unicode. If we pass a str that is
             # invalid UTF-8 to Rust, it will rightfully complain. Here we do a quick and dirty
@@ -130,7 +157,11 @@ class Encoding:
             # string, but given that this is input we want to support, maybe that's okay.
             # Also we use errors="replace" to handle weird things like lone surrogates.
             text = text.encode("utf-16", "surrogatepass").decode("utf-16", "replace")
-            return self._core_bpe.encode(text, allowed_special)
+            tokens = self._core_bpe.encode(text, allowed_special)
+ 
+        # Apply token filtering
+        return self._filter_tokens(tokens, filter_tokens)
+
 
     def encode_to_numpy(
         self,
