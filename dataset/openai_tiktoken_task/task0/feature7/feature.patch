diff --git a/tiktoken/core.py b/tiktoken/core.py
index 6bc9736..269de0a 100644
--- a/tiktoken/core.py
+++ b/tiktoken/core.py
@@ -82,6 +82,7 @@ class Encoding:
         *,
         allowed_special: Literal["all"] | AbstractSet[str] = set(),  # noqa: B006
         disallowed_special: Literal["all"] | Collection[str] = "all",
+        validators: list[callable] = None,  # New parameter for validation functions
     ) -> list[int]:
         """Encodes a string into tokens.
 
@@ -93,9 +94,14 @@ class Encoding:
         to a special token. This can be controlled on a per-token level using the `allowed_special`
         and `disallowed_special` parameters. In particular:
         - Setting `disallowed_special` to () will prevent this function from raising errors and
-          cause all text corresponding to special tokens to be encoded as natural text.
+        cause all text corresponding to special tokens to be encoded as natural text.
         - Setting `allowed_special` to "all" will cause this function to treat all text
-          corresponding to special tokens to be encoded as special tokens.
+        corresponding to special tokens to be encoded as special tokens.
+
+        Validation constraints can be applied using the `validators` parameter:
+        - Provide a list of validator functions that each take the token sequence as input
+        - Each function should raise ValueError if its constraint is not met
+        - Validation occurs after encoding but before returning the tokens
 
         ```
         >>> enc.encode("hello world")
@@ -108,6 +114,10 @@ class Encoding:
         # Raises ValueError
         >>> enc.encode("<|endoftext|>", disallowed_special=())
         [27, 91, 437, 1659, 5239, 91, 29]
+        >>> def no_repeats(tokens):
+        ...     return len(tokens) == len(set(tokens))  # Returns False if duplicates exist
+        >>> enc.encode("hello hello", validators=[no_repeats])
+        # Raises ValueError
         ```
         """
         if allowed_special == "all":
@@ -121,7 +131,7 @@ class Encoding:
                 raise_disallowed_special_token(match.group())
 
         try:
-            return self._core_bpe.encode(text, allowed_special)
+            tokens = self._core_bpe.encode(text, allowed_special)
         except UnicodeEncodeError:
             # BPE operates on bytes, but the regex operates on unicode. If we pass a str that is
             # invalid UTF-8 to Rust, it will rightfully complain. Here we do a quick and dirty
@@ -130,7 +140,19 @@ class Encoding:
             # string, but given that this is input we want to support, maybe that's okay.
             # Also we use errors="replace" to handle weird things like lone surrogates.
             text = text.encode("utf-16", "surrogatepass").decode("utf-16", "replace")
-            return self._core_bpe.encode(text, allowed_special)
+            tokens = self._core_bpe.encode(text, allowed_special)
+ 
+        # Apply validation functions if provided
+        if validators:
+            for i, validator in enumerate(validators):
+                # Call each validator function with the tokens
+                # If the validator returns False or raises an exception, fail validation
+                result = validator(tokens)
+                if result is False:  # Check for False return value
+                    raise ValueError(f"Token validation failed for validator at index {i}")
+                # If the validator raises an exception on its own, it will propagate up
+ 
+        return tokens
 
     def encode_to_numpy(
         self,
