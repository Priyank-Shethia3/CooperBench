diff --git a/tiktoken/core.py b/tiktoken/core.py
index 6bc9736..dc8ba3c 100644
--- a/tiktoken/core.py
+++ b/tiktoken/core.py
@@ -82,6 +82,7 @@ class Encoding:
         *,
         allowed_special: Literal["all"] | AbstractSet[str] = set(),  # noqa: B006
         disallowed_special: Literal["all"] | Collection[str] = "all",
+        max_tokens: int | None = None,
     ) -> list[int]:
         """Encodes a string into tokens.

@@ -93,9 +94,21 @@ class Encoding:
         to a special token. This can be controlled on a per-token level using the `allowed_special`
         and `disallowed_special` parameters. In particular:
         - Setting `disallowed_special` to () will prevent this function from raising errors and
-          cause all text corresponding to special tokens to be encoded as natural text.
+        cause all text corresponding to special tokens to be encoded as natural text.
         - Setting `allowed_special` to "all" will cause this function to treat all text
-          corresponding to special tokens to be encoded as special tokens.
+        corresponding to special tokens to be encoded as special tokens.
+
+        Args:
+            text: The text to encode.
+            allowed_special: Set of special tokens that are allowed to be encoded.
+            disallowed_special: Set of special tokens that are not allowed to be encoded.
+            max_tokens: Maximum number of tokens allowed (None means no limit).
+
+        Returns:
+            A list of token ids.
+
+        Raises:
+            ValueError: If the text contains disallowed special tokens or exceeds max_tokens.

         ```
         >>> enc.encode("hello world")
@@ -108,8 +121,14 @@ class Encoding:
         # Raises ValueError
         >>> enc.encode("<|endoftext|>", disallowed_special=())
         [27, 91, 437, 1659, 5239, 91, 29]
+        >>> enc.encode("hello world", max_tokens=1)
+        # Raises ValueError
         ```
         """
+        # Validate max_tokens parameter
+        if max_tokens is not None and max_tokens <= 0:
+            raise ValueError(f"max_tokens must be a positive integer, got {max_tokens}")
+
         if allowed_special == "all":
             allowed_special = self.special_tokens_set
         if disallowed_special == "all":
@@ -121,7 +140,7 @@ class Encoding:
                 raise_disallowed_special_token(match.group())

         try:
-            return self._core_bpe.encode(text, allowed_special)
+            tokens = self._core_bpe.encode(text, allowed_special)
         except UnicodeEncodeError:
             # BPE operates on bytes, but the regex operates on unicode. If we pass a str that is
             # invalid UTF-8 to Rust, it will rightfully complain. Here we do a quick and dirty
@@ -130,7 +149,15 @@ class Encoding:
             # string, but given that this is input we want to support, maybe that's okay.
             # Also we use errors="replace" to handle weird things like lone surrogates.
             text = text.encode("utf-16", "surrogatepass").decode("utf-16", "replace")
-            return self._core_bpe.encode(text, allowed_special)
+            tokens = self._core_bpe.encode(text, allowed_special)
+
+        # Check if token count exceeds the maximum allowed
+        if max_tokens is not None and len(tokens) > max_tokens:
+            raise ValueError(
+                f"Token count ({len(tokens)}) exceeds maximum allowed tokens ({max_tokens})"
+            )
+
+        return tokens

     def encode_to_numpy(
         self,

