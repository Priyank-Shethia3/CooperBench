diff --git a/tiktoken/core.py b/tiktoken/core.py
index 6bc9736..c76fd32 100644
--- a/tiktoken/core.py
+++ b/tiktoken/core.py
@@ -82,6 +82,7 @@ class Encoding:
         *,
         allowed_special: Literal["all"] | AbstractSet[str] = set(),  # noqa: B006
         disallowed_special: Literal["all"] | Collection[str] = "all",
+        compression: bool = False,
     ) -> list[int]:
         """Encodes a string into tokens.
 
@@ -93,9 +94,10 @@ class Encoding:
         to a special token. This can be controlled on a per-token level using the `allowed_special`
         and `disallowed_special` parameters. In particular:
         - Setting `disallowed_special` to () will prevent this function from raising errors and
-          cause all text corresponding to special tokens to be encoded as natural text.
+        cause all text corresponding to special tokens to be encoded as natural text.
         - Setting `allowed_special` to "all" will cause this function to treat all text
-          corresponding to special tokens to be encoded as special tokens.
+        corresponding to special tokens to be encoded as special tokens.
+        - Setting `compression` to True will remove adjacent repeated tokens in the output.
 
         ```
         >>> enc.encode("hello world")
@@ -108,6 +110,8 @@ class Encoding:
         # Raises ValueError
         >>> enc.encode("<|endoftext|>", disallowed_special=())
         [27, 91, 437, 1659, 5239, 91, 29]
+        >>> enc.encode(" like like like", compression=True)
+        [1093]
         ```
         """
         if allowed_special == "all":
@@ -121,7 +125,7 @@ class Encoding:
                 raise_disallowed_special_token(match.group())
 
         try:
-            return self._core_bpe.encode(text, allowed_special)
+            tokens = self._core_bpe.encode(text, allowed_special)
         except UnicodeEncodeError:
             # BPE operates on bytes, but the regex operates on unicode. If we pass a str that is
             # invalid UTF-8 to Rust, it will rightfully complain. Here we do a quick and dirty
@@ -130,7 +134,32 @@ class Encoding:
             # string, but given that this is input we want to support, maybe that's okay.
             # Also we use errors="replace" to handle weird things like lone surrogates.
             text = text.encode("utf-16", "surrogatepass").decode("utf-16", "replace")
-            return self._core_bpe.encode(text, allowed_special)
+            tokens = self._core_bpe.encode(text, allowed_special)
+ 
+        # Apply token compression if requested
+        if compression:
+            tokens = self._compress_tokens(tokens)
+ 
+        return tokens
+
+    def _compress_tokens(self, tokens: list[int]) -> list[int]:
+        """Compresses the token sequence by removing adjacent repeated tokens.
+ 
+        Args:
+            tokens: A list of token IDs.
+ 
+        Returns:
+            A compressed list of token IDs with adjacent duplicates removed.
+        """
+        if not tokens:
+            return tokens
+ 
+        compressed = [tokens[0]]
+        for token in tokens[1:]:
+            if token != compressed[-1]:
+                compressed.append(token)
+ 
+        return compressed
 
     def encode_to_numpy(
         self,
