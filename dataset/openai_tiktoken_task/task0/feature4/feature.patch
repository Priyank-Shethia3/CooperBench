diff --git a/tiktoken/core.py b/tiktoken/core.py
index 6bc9736..e45b429 100644
--- a/tiktoken/core.py
+++ b/tiktoken/core.py
@@ -82,7 +82,8 @@ class Encoding:
         *,
         allowed_special: Literal["all"] | AbstractSet[str] = set(),  # noqa: B006
         disallowed_special: Literal["all"] | Collection[str] = "all",
-    ) -> list[int]:
+        chunk_size: int | None = None,
+    ) -> list[int] | list[list[int]]:
         """Encodes a string into tokens.
 
         Special tokens are artificial tokens used to unlock capabilities from a model,
@@ -93,9 +94,12 @@ class Encoding:
         to a special token. This can be controlled on a per-token level using the `allowed_special`
         and `disallowed_special` parameters. In particular:
         - Setting `disallowed_special` to () will prevent this function from raising errors and
-          cause all text corresponding to special tokens to be encoded as natural text.
+        cause all text corresponding to special tokens to be encoded as natural text.
         - Setting `allowed_special` to "all" will cause this function to treat all text
-          corresponding to special tokens to be encoded as special tokens.
+        corresponding to special tokens to be encoded as special tokens.
+
+        If `chunk_size` is provided, the text will be split into chunks of approximately
+        `chunk_size` characters, and a list of token lists will be returned, one for each chunk.
 
         ```
         >>> enc.encode("hello world")
@@ -108,6 +112,8 @@ class Encoding:
         # Raises ValueError
         >>> enc.encode("<|endoftext|>", disallowed_special=())
         [27, 91, 437, 1659, 5239, 91, 29]
+        >>> enc.encode("This is a long text", chunk_size=10)
+        [[1212, 318, 257], [2420, 1310]]
         ```
         """
         if allowed_special == "all":
@@ -120,17 +126,73 @@ class Encoding:
             if match := _special_token_regex(disallowed_special).search(text):
                 raise_disallowed_special_token(match.group())
 
-        try:
-            return self._core_bpe.encode(text, allowed_special)
-        except UnicodeEncodeError:
-            # BPE operates on bytes, but the regex operates on unicode. If we pass a str that is
-            # invalid UTF-8 to Rust, it will rightfully complain. Here we do a quick and dirty
-            # fixup for any surrogate pairs that may have sneaked their way into the text.
-            # Technically, this introduces a place where encode + decode doesn't roundtrip a Python
-            # string, but given that this is input we want to support, maybe that's okay.
-            # Also we use errors="replace" to handle weird things like lone surrogates.
-            text = text.encode("utf-16", "surrogatepass").decode("utf-16", "replace")
-            return self._core_bpe.encode(text, allowed_special)
+        # If no chunking is requested, use the original behavior
+        if chunk_size is None:
+            try:
+                return self._core_bpe.encode(text, allowed_special)
+            except UnicodeEncodeError:
+                # BPE operates on bytes, but the regex operates on unicode. If we pass a str that is
+                # invalid UTF-8 to Rust, it will rightfully complain. Here we do a quick and dirty
+                # fixup for any surrogate pairs that may have sneaked their way into the text.
+                # Technically, this introduces a place where encode + decode doesn't roundtrip a Python
+                # string, but given that this is input we want to support, maybe that's okay.
+                # Also we use errors="replace" to handle weird things like lone surrogates.
+                text = text.encode("utf-16", "surrogatepass").decode("utf-16", "replace")
+                return self._core_bpe.encode(text, allowed_special)
+ 
+        # Implement chunking
+        return self._encode_with_chunking(
+            text=text,
+            allowed_special=allowed_special,
+            chunk_size=chunk_size
+        )
+
+    def _encode_with_chunking(
+        self,
+        text: str,
+        allowed_special: AbstractSet[str],
+        chunk_size: int,
+    ) -> list[list[int]]:
+        """Helper function to handle text chunking and encoding.
+ 
+        This function divides the text into character chunks of size chunk_size,
+        then encodes each chunk separately.
+        """
+        # If the text is short enough to fit in one chunk, encode it directly
+        if len(text) <= chunk_size:
+            try:
+                tokens = self._core_bpe.encode(text, allowed_special)
+            except UnicodeEncodeError:
+                text = text.encode("utf-16", "surrogatepass").decode("utf-16", "replace")
+                tokens = self._core_bpe.encode(text, allowed_special)
+            return [tokens]
+ 
+        # Split the text into chunks of chunk_size characters
+        chunks = []
+        start_pos = 0
+        text_length = len(text)
+ 
+        while start_pos < text_length:
+            # Determine the end position for the current chunk
+            end_pos = min(start_pos + chunk_size, text_length)
+ 
+            # Extract the current chunk
+            chunk_text = text[start_pos:end_pos]
+ 
+            # Encode the chunk
+            try:
+                chunk_tokens = self._core_bpe.encode(chunk_text, allowed_special)
+            except UnicodeEncodeError:
+                chunk_text = chunk_text.encode("utf-16", "surrogatepass").decode("utf-16", "replace")
+                chunk_tokens = self._core_bpe.encode(chunk_text, allowed_special)
+ 
+            # Add the encoded chunk to our results
+            chunks.append(chunk_tokens)
+ 
+            # Move to the next chunk
+            start_pos = end_pos
+ 
+        return chunks
 
     def encode_to_numpy(
         self,
