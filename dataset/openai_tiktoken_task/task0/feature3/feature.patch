diff --git a/tiktoken/core.py b/tiktoken/core.py
index 6bc9736..779cf03 100644
--- a/tiktoken/core.py
+++ b/tiktoken/core.py
@@ -76,13 +76,28 @@ class Encoding:
             text = text.encode("utf-16", "surrogatepass").decode("utf-16", "replace")
             return self._core_bpe.encode_ordinary(text)
 
+    def _count_token_frequency(self, tokens: list[int]) -> Dict[int, int]:
+        """Helper function to count token frequencies.
+ 
+        Args:
+            tokens: List of token IDs
+ 
+        Returns:
+            Dictionary mapping token IDs to their frequencies
+        """
+        freq = {}
+        for token in tokens:
+            freq[token] = freq.get(token, 0) + 1
+        return freq
+
     def encode(
         self,
         text: str,
         *,
         allowed_special: Literal["all"] | AbstractSet[str] = set(),  # noqa: B006
         disallowed_special: Literal["all"] | Collection[str] = "all",
-    ) -> list[int]:
+        return_frequency: bool = False,
+    ) -> Union[list[int], Tuple[list[int], Dict[int, int]]]:
         """Encodes a string into tokens.
 
         Special tokens are artificial tokens used to unlock capabilities from a model,
@@ -96,6 +111,8 @@ class Encoding:
           cause all text corresponding to special tokens to be encoded as natural text.
         - Setting `allowed_special` to "all" will cause this function to treat all text
           corresponding to special tokens to be encoded as special tokens.
+        - Setting `return_frequency` to True will return a tuple of (tokens, frequencies), where
+          frequencies is a dict mapping token IDs to their frequencies.
 
         ```
         >>> enc.encode("hello world")
@@ -108,6 +125,8 @@ class Encoding:
         # Raises ValueError
         >>> enc.encode("<|endoftext|>", disallowed_special=())
         [27, 91, 437, 1659, 5239, 91, 29]
+        >>> enc.encode("hello world", return_frequency=True)
+        ([31373, 995], {31373: 1, 995: 1})
         ```
         """
         if allowed_special == "all":
@@ -121,7 +140,7 @@ class Encoding:
                 raise_disallowed_special_token(match.group())
 
         try:
-            return self._core_bpe.encode(text, allowed_special)
+            tokens = self._core_bpe.encode(text, allowed_special)
         except UnicodeEncodeError:
             # BPE operates on bytes, but the regex operates on unicode. If we pass a str that is
             # invalid UTF-8 to Rust, it will rightfully complain. Here we do a quick and dirty
@@ -130,8 +149,14 @@ class Encoding:
             # string, but given that this is input we want to support, maybe that's okay.
             # Also we use errors="replace" to handle weird things like lone surrogates.
             text = text.encode("utf-16", "surrogatepass").decode("utf-16", "replace")
-            return self._core_bpe.encode(text, allowed_special)
-
+            tokens = self._core_bpe.encode(text, allowed_special)
+ 
+        if return_frequency:
+            frequencies = self._count_token_frequency(tokens)
+            return tokens, frequencies
+ 
+        return tokens    
+ 
     def encode_to_numpy(
         self,
         text: str,
