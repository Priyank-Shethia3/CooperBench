diff --git a/mux.go b/mux.go
index 56fa4d2..ad4c95e 100644
--- a/mux.go
+++ b/mux.go
@@ -10,6 +10,19 @@ import (
 
 var _ Router = &Mux{}
 
+var (
+	// Method alias mapping
+	methodAliases = map[string]methodTyp{
+		"GET":     mGET,
+		"POST":    mPOST,
+		"PUT":     mPUT,
+		"DELETE":  mDELETE,
+		"HEAD":    mHEAD,
+		"OPTIONS": mOPTIONS,
+		"PATCH":   mPATCH,
+	}
+)
+
 // Mux is a simple HTTP route multiplexer that parses a request path,
 // records any URL params, and executes an end handler. It implements
 // the http.Handler interface and is friendly with the standard library.
@@ -109,24 +122,35 @@ func (mx *Mux) Use(middlewares ...func(http.Handler) http.Handler) {
 func (mx *Mux) Handle(pattern string, handler http.Handler) {
 	parts := strings.SplitN(pattern, " ", 2)
 	if len(parts) == 2 {
-		methodStr := strings.ToUpper(parts[0])
-		path := parts[1]
-
-		method, ok := methodMap[methodStr]
-		if !ok {
-			panic("chi: invalid HTTP method specified in pattern: " + methodStr)
-		}
-
-		mx.handle(method, path, handler)
+		mx.handleWithMethod(parts[0], parts[1], handler)
 		return
 	}
 
 	mx.handle(mALL, pattern, handler)
 }
 
+// handleWithMethod parses and normalizes the HTTP method before handling the route
+func (mx *Mux) handleWithMethod(methodStr string, path string, handler http.Handler) {
+	// Case insensitive method matching
+	methodStr = strings.ToUpper(methodStr)
+
+	method, ok := methodAliases[methodStr]
+	if !ok {
+		panic("chi: invalid HTTP method specified in pattern: " + methodStr)
+	}
+
+	mx.handle(method, path, handler)
+}
+
 // HandleFunc adds the route `pattern` that matches any http method to
 // execute the `handlerFn` http.HandlerFunc.
 func (mx *Mux) HandleFunc(pattern string, handlerFn http.HandlerFunc) {
+	parts := strings.SplitN(pattern, " ", 2)
+	if len(parts) == 2 {
+		mx.handleWithMethod(parts[0], parts[1], handlerFn)
+		return
+	}
+
 	mx.handle(mALL, pattern, handlerFn)
 }
 
