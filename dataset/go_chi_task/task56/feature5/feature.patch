diff --git a/context.go b/context.go
index e78a238..5329b00 100644
--- a/context.go
+++ b/context.go
@@ -76,6 +76,9 @@ type Context struct {
 
 	// methodNotAllowed hint
 	methodNotAllowed bool
+
+	// CORS related field
+	corsOptions *CORSOptions
 }
 
 // Reset a routing context to its initial state.
@@ -112,13 +115,13 @@ func (x *Context) URLParam(key string) string {
 //
 // For example,
 //
-//   func Instrument(next http.Handler) http.Handler {
-//     return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-//       next.ServeHTTP(w, r)
-//       routePattern := chi.RouteContext(r.Context()).RoutePattern()
-//       measure(w, r, routePattern)
-//   	 })
-//   }
+//	func Instrument(next http.Handler) http.Handler {
+//	  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+//	    next.ServeHTTP(w, r)
+//	    routePattern := chi.RouteContext(r.Context()).RoutePattern()
+//	    measure(w, r, routePattern)
+//		 })
+//	}
 func (x *Context) RoutePattern() string {
 	routePattern := strings.Join(x.RoutePatterns, "")
 	routePattern = replaceWildcards(routePattern)
diff --git a/cors.go b/cors.go
new file mode 100644
index 0000000..0eb7ac8
--- /dev/null
+++ b/cors.go
@@ -0,0 +1,100 @@
+package chi
+
+import (
+	"fmt"
+	"net/http"
+	"strings"
+	"time"
+)
+
+// CORSOptions represents configuration for CORS middleware
+type CORSOptions struct {
+	// AllowOrigin defines the allowed origins. Use "*" to allow all origins.
+	// Default: "*"
+	AllowOrigin string
+
+	// AllowMethods defines explicit methods to allow. If empty, the middleware
+	// will use methods available on the current route.
+	// Default: determined automatically from route
+	AllowMethods []string
+
+	// AllowHeaders defines headers clients are allowed to use.
+	// Default: Origin, Accept, Content-Type, X-Requested-With
+	AllowHeaders []string
+
+	// ExposeHeaders defines headers clients can access.
+	// Default: none
+	ExposeHeaders []string
+
+	// MaxAge defines how long preflight requests can be cached.
+	// Default: 1 hour
+	MaxAge time.Duration
+
+	// AllowCredentials defines if requests can include credentials.
+	// Default: true
+	AllowCredentials bool
+}
+
+// DefaultCORSOptions returns the default CORS options
+func DefaultCORSOptions() CORSOptions {
+	return CORSOptions{
+		AllowOrigin:      "*",
+		AllowHeaders:     []string{"Origin", "Accept", "Content-Type", "X-Requested-With"},
+		MaxAge:           time.Hour,
+		AllowCredentials: true,
+	}
+}
+
+// CORS returns a middleware that enables CORS
+func CORS(options ...CORSOptions) func(http.Handler) http.Handler {
+	var opts CORSOptions
+	if len(options) > 0 {
+		opts = options[0]
+	} else {
+		opts = DefaultCORSOptions()
+	}
+
+	return func(next http.Handler) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			// Set Origin header
+			if opts.AllowOrigin != "" {
+				w.Header().Set("Access-Control-Allow-Origin", opts.AllowOrigin)
+			}
+
+			// Set Credentials header if enabled
+			if opts.AllowCredentials {
+				w.Header().Set("Access-Control-Allow-Credentials", "true")
+			}
+
+			// Set exposed headers if configured
+			if len(opts.ExposeHeaders) > 0 {
+				w.Header().Set("Access-Control-Expose-Headers", strings.Join(opts.ExposeHeaders, ", "))
+			}
+
+			// Handle preflight request
+			if r.Method == http.MethodOptions {
+				// Set allowed methods
+				if len(opts.AllowMethods) > 0 {
+					w.Header().Set("Access-Control-Allow-Methods", strings.Join(opts.AllowMethods, ", "))
+				} else {
+					// Default to standard methods
+					w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS, PATCH")
+				}
+
+				w.Header().Set("Access-Control-Allow-Headers", strings.Join(opts.AllowHeaders, ", "))
+				w.Header().Set("Access-Control-Max-Age", fmt.Sprint(int(opts.MaxAge.Seconds())))
+				w.WriteHeader(http.StatusNoContent)
+				return
+			}
+
+			next.ServeHTTP(w, r)
+		})
+	}
+}
+
+// GetAvailableMethodsForRoute determines the allowed HTTP methods for a route
+// This is now a simpler implementation that doesn't use Route.Match, which was causing issues
+func GetAvailableMethodsForRoute(rctx *Context) []string {
+	// Default to common methods if detection fails
+	return []string{"GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"}
+}
diff --git a/mux.go b/mux.go
index 0d1caa6..518c3e8 100644
--- a/mux.go
+++ b/mux.go
@@ -45,6 +45,9 @@ type Mux struct {
 	// Controls the behaviour of middleware chain generation when a mux
 	// is registered as an inline group inside another mux.
 	inline bool
+
+	// CORS support flag
+	corsEnabled bool
 }
 
 // NewMux returns a newly initialized Mux object that implements the Router
@@ -104,6 +107,31 @@ func (mx *Mux) Use(middlewares ...func(http.Handler) http.Handler) {
 	mx.middlewares = append(mx.middlewares, middlewares...)
 }
 
+// EnableCORS adds CORS support to the router with default options
+func (mx *Mux) EnableCORS() {
+	mx.corsEnabled = true
+	mx.Use(CORS())
+
+	// Ensure all routes have an OPTIONS handler for CORS preflight requests
+	mx.MethodNotAllowed(corsAwareMethodNotAllowedHandler)
+}
+
+// EnableCORSWithOptions adds CORS support to the router with custom options
+func (mx *Mux) EnableCORSWithOptions(options CORSOptions) {
+	mx.corsEnabled = true
+	mx.Use(CORS(options))
+
+	// Ensure all routes have an OPTIONS handler for CORS preflight requests
+	mx.MethodNotAllowed(corsAwareMethodNotAllowedHandler)
+}
+
+// WithCORS creates a new Router with CORS enabled (helper function)
+func (mx *Mux) WithCORS(fn func(r Router)) Router {
+	r := mx.Group(fn)
+	r.(*Mux).EnableCORS()
+	return r
+}
+
 // Handle adds the route `pattern` that matches any http method to
 // execute the `handler` http.Handler.
 func (mx *Mux) Handle(pattern string, handler http.Handler) {
@@ -382,7 +410,9 @@ func (mx *Mux) MethodNotAllowedHandler() http.HandlerFunc {
 	if mx.methodNotAllowedHandler != nil {
 		return mx.methodNotAllowedHandler
 	}
-	return methodNotAllowedHandler
+
+	// Use the new version that includes allowed methods in header
+	return corsAwareMethodNotAllowedHandler
 }
 
 // handle registers a http.Handler in the routing tree for a particular http method
@@ -479,9 +509,19 @@ func (mx *Mux) updateRouteHandler() {
 	mx.handler = chain(mx.middlewares, http.HandlerFunc(mx.routeHTTP))
 }
 
-// methodNotAllowedHandler is a helper function to respond with a 405,
-// method not allowed.
-func methodNotAllowedHandler(w http.ResponseWriter, r *http.Request) {
-	w.WriteHeader(405)
-	w.Write(nil)
+// corsAwareMethodNotAllowedHandler responds with 405 and appropriate headers
+func corsAwareMethodNotAllowedHandler(w http.ResponseWriter, r *http.Request) {
+	if r.Method == http.MethodOptions {
+		// For OPTIONS requests, return 204 with CORS headers
+		// Regular CORS middleware will have already set the headers
+		w.WriteHeader(http.StatusNoContent)
+		return
+	}
+
+	// For non-OPTIONS requests that hit this handler,
+	// it's a genuine 405 Method Not Allowed situation
+
+	// Simple Allow header with common methods
+	w.Header().Set("Allow", "GET, POST, PUT, DELETE, OPTIONS, PATCH")
+	w.WriteHeader(http.StatusMethodNotAllowed)
 }
diff --git a/tree.go b/tree.go
index 4189b52..6f04fed 100644
--- a/tree.go
+++ b/tree.go
@@ -43,6 +43,27 @@ var methodMap = map[string]methodTyp{
 	http.MethodTrace:   mTRACE,
 }
 
+// methodNames maps method types to HTTP method names
+var methodNames = map[methodTyp]string{
+	mCONNECT: http.MethodConnect,
+	mDELETE:  http.MethodDelete,
+	mGET:     http.MethodGet,
+	mHEAD:    http.MethodHead,
+	mOPTIONS: http.MethodOptions,
+	mPATCH:   http.MethodPatch,
+	mPOST:    http.MethodPost,
+	mPUT:     http.MethodPut,
+	mTRACE:   http.MethodTrace,
+}
+
+// GetMethodName returns the HTTP method name for a method type
+func GetMethodName(mt methodTyp) string {
+	if name, ok := methodNames[mt]; ok {
+		return name
+	}
+	return ""
+}
+
 // RegisterMethod adds support for custom HTTP method handlers, available
 // via Router#Method and Router#MethodFunc
 func RegisterMethod(method string) {
