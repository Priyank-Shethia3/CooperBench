diff --git a/context.go b/context.go
index e78a238..bc84963 100644
--- a/context.go
+++ b/context.go
@@ -2,6 +2,7 @@ package chi
 
 import (
 	"context"
+	"fmt"
 	"net/http"
 	"strings"
 )
@@ -76,6 +77,17 @@ type Context struct {
 
 	// methodNotAllowed hint
 	methodNotAllowed bool
+	methodsAllowed   []methodTyp // allowed methods in case of a 405
+
+	// invalidMethod flag for invalid/unrecognized HTTP method
+	invalidMethod bool
+
+	// Trace information
+	matchedPath string
+	triedPaths  []string
+
+	// CORS related field
+	corsOptions *CORSOptions
 }
 
 // Reset a routing context to its initial state.
@@ -91,6 +103,10 @@ func (x *Context) Reset() {
 	x.routeParams.Keys = x.routeParams.Keys[:0]
 	x.routeParams.Values = x.routeParams.Values[:0]
 	x.methodNotAllowed = false
+	x.methodsAllowed = x.methodsAllowed[:0]
+	x.invalidMethod = false
+	x.matchedPath = ""
+	x.triedPaths = x.triedPaths[:0]
 	x.parentCtx = nil
 }
 
@@ -157,3 +173,18 @@ type contextKey struct {
 func (k *contextKey) String() string {
 	return "chi context value " + k.name
 }
+
+// SetMatchedPath records the pattern that matched the current request
+func (x *Context) SetMatchedPath(path string) {
+	x.matchedPath = path
+}
+
+// GetMatchedPath returns the pattern that matched the current request
+func (x *Context) GetMatchedPath() string {
+	return x.matchedPath
+}
+
+// GetRouteDebugInfo returns debug information about route matching
+func (x *Context) GetRouteDebugInfo() string {
+	return fmt.Sprintf("Matched: %s\nTried paths: %s", x.matchedPath, strings.Join(x.triedPaths, ", "))
+}
diff --git a/cors.go b/cors.go
new file mode 100644
index 0000000..9a34428
--- /dev/null
+++ b/cors.go
@@ -0,0 +1,71 @@
+package chi
+
+import (
+	"fmt"
+	"net/http"
+	"strings"
+	"time"
+)
+
+// CORSOptions represents configuration for CORS middleware
+type CORSOptions struct {
+	AllowOrigin      string
+	AllowMethods     []string
+	AllowHeaders     []string
+	ExposeHeaders    []string
+	MaxAge           time.Duration
+	AllowCredentials bool
+}
+
+// DefaultCORSOptions returns the default CORS options
+func DefaultCORSOptions() CORSOptions {
+	return CORSOptions{
+		AllowOrigin:      "*",
+		AllowHeaders:     []string{"Origin", "Accept", "Content-Type", "X-Requested-With"},
+		MaxAge:           time.Hour,
+		AllowCredentials: true,
+	}
+}
+
+// CORS returns a middleware that enables CORS
+func CORS(options ...CORSOptions) func(http.Handler) http.Handler {
+	var opts CORSOptions
+	if len(options) > 0 {
+		opts = options[0]
+	} else {
+		opts = DefaultCORSOptions()
+	}
+
+	return func(next http.Handler) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			if opts.AllowOrigin != "" {
+				w.Header().Set("Access-Control-Allow-Origin", opts.AllowOrigin)
+			}
+			if opts.AllowCredentials {
+				w.Header().Set("Access-Control-Allow-Credentials", "true")
+			}
+			if len(opts.ExposeHeaders) > 0 {
+				w.Header().Set("Access-Control-Expose-Headers", strings.Join(opts.ExposeHeaders, ", "))
+			}
+
+			if r.Method == http.MethodOptions {
+				if len(opts.AllowMethods) > 0 {
+					w.Header().Set("Access-Control-Allow-Methods", strings.Join(opts.AllowMethods, ", "))
+				} else {
+					w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS, PATCH")
+				}
+				w.Header().Set("Access-Control-Allow-Headers", strings.Join(opts.AllowHeaders, ", "))
+				w.Header().Set("Access-Control-Max-Age", fmt.Sprint(int(opts.MaxAge.Seconds())))
+				w.WriteHeader(http.StatusNoContent)
+				return
+			}
+
+			next.ServeHTTP(w, r)
+		})
+	}
+}
+
+// GetAvailableMethodsForRoute returns available methods for a route
+func GetAvailableMethodsForRoute(rctx *Context) []string {
+	return []string{"GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"}
+}
diff --git a/middleware/allowed_methods.go b/middleware/allowed_methods.go
new file mode 100644
index 0000000..da8e92a
--- /dev/null
+++ b/middleware/allowed_methods.go
@@ -0,0 +1,28 @@
+package middleware
+
+import (
+	"net/http"
+
+	"github.com/go-chi/chi/v5"
+)
+
+// SetAllowHeader adds the Allow header to the response based on
+// the methods that are registered for the requested path.
+func SetAllowHeader(next http.Handler) http.Handler {
+	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		rctx := chi.RouteContext(r.Context())
+		url := r.URL.Path
+
+		if rctx.Routes.Match(rctx, r.Method, url) {
+			next.ServeHTTP(w, r)
+			return
+		}
+
+		for _, method := range []string{"GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS", "CONNECT", "TRACE"} {
+			if rctx.Routes.Match(rctx, method, url) {
+				w.Header().Add("Allow", method)
+			}
+		}
+		next.ServeHTTP(w, r)
+	})
+}
diff --git a/middleware/method_validator.go b/middleware/method_validator.go
new file mode 100644
index 0000000..c574860
--- /dev/null
+++ b/middleware/method_validator.go
@@ -0,0 +1,54 @@
+package middleware
+
+import (
+	"net/http"
+	"strings"
+)
+
+// StandardMethods contains the standard HTTP methods as defined in RFC 9110
+var StandardMethods = []string{
+	http.MethodGet,
+	http.MethodHead,
+	http.MethodPost,
+	http.MethodPut,
+	http.MethodPatch,
+	http.MethodDelete,
+	http.MethodConnect,
+	http.MethodOptions,
+	http.MethodTrace,
+}
+
+// MethodValidator returns a middleware that validates the HTTP method
+func MethodValidator(allowedMethods ...string) func(http.Handler) http.Handler {
+	return func(next http.Handler) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			if !isMethodAllowed(r.Method, allowedMethods) {
+				w.Header().Set("Allow", strings.Join(allowedMethods, ", "))
+				http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
+				return
+			}
+			next.ServeHTTP(w, r)
+		})
+	}
+}
+
+func isMethodAllowed(method string, allowedMethods []string) bool {
+	if len(allowedMethods) == 0 {
+		return isStandardMethod(method)
+	}
+	for _, m := range allowedMethods {
+		if m == method {
+			return true
+		}
+	}
+	return false
+}
+
+func isStandardMethod(method string) bool {
+	for _, m := range StandardMethods {
+		if m == method {
+			return true
+		}
+	}
+	return false
+}
diff --git a/mux.go b/mux.go
index 0d1caa6..16317d6 100644
--- a/mux.go
+++ b/mux.go
@@ -2,6 +2,7 @@ package chi
 
 import (
 	"context"
+	"encoding/json"
 	"fmt"
 	"net/http"
 	"strings"
@@ -45,6 +46,12 @@ type Mux struct {
 	// Controls the behaviour of middleware chain generation when a mux
 	// is registered as an inline group inside another mux.
 	inline bool
+
+	// Handler for unrecognized methods
+	invalidMethodHandler http.HandlerFunc
+
+	// CORS support flag
+	corsEnabled bool
 }
 
 // NewMux returns a newly initialized Mux object that implements the Router
@@ -104,6 +111,27 @@ func (mx *Mux) Use(middlewares ...func(http.Handler) http.Handler) {
 	mx.middlewares = append(mx.middlewares, middlewares...)
 }
 
+// EnableCORS adds CORS support to the router with default options
+func (mx *Mux) EnableCORS() {
+	mx.corsEnabled = true
+	mx.Use(CORS())
+	mx.MethodNotAllowed(corsAwareMethodNotAllowedHandler)
+}
+
+// EnableCORSWithOptions adds CORS support to the router with custom options
+func (mx *Mux) EnableCORSWithOptions(options CORSOptions) {
+	mx.corsEnabled = true
+	mx.Use(CORS(options))
+	mx.MethodNotAllowed(corsAwareMethodNotAllowedHandler)
+}
+
+// WithCORS creates a new Router with CORS enabled
+func (mx *Mux) WithCORS(fn func(r Router)) Router {
+	r := mx.Group(fn)
+	r.(*Mux).EnableCORS()
+	return r
+}
+
 // Handle adds the route `pattern` that matches any http method to
 // execute the `handler` http.Handler.
 func (mx *Mux) Handle(pattern string, handler http.Handler) {
@@ -226,6 +254,19 @@ func (mx *Mux) MethodNotAllowed(handlerFn http.HandlerFunc) {
 	})
 }
 
+// SetInvalidMethodHandler sets a custom http.HandlerFunc for invalid HTTP methods
+func (mx *Mux) SetInvalidMethodHandler(fn http.HandlerFunc) {
+	mx.invalidMethodHandler = fn
+}
+
+// InvalidMethodHandler returns the handler for unrecognized HTTP methods
+func (mx *Mux) InvalidMethodHandler() http.HandlerFunc {
+	if mx.invalidMethodHandler != nil {
+		return mx.invalidMethodHandler
+	}
+	return invalidMethodHandler
+}
+
 // With adds inline middlewares for an endpoint handler.
 func (mx *Mux) With(middlewares ...func(http.Handler) http.Handler) Router {
 	// Similarly as in handle(), we must build the mux handler once additional
@@ -377,12 +418,41 @@ func (mx *Mux) NotFoundHandler() http.HandlerFunc {
 }
 
 // MethodNotAllowedHandler returns the default Mux 405 responder whenever
-// a method cannot be resolved for a route.
-func (mx *Mux) MethodNotAllowedHandler() http.HandlerFunc {
+// a method cannot be resolved for a route. Optionally accepts allowed methods
+// to set the Allow header.
+func (mx *Mux) MethodNotAllowedHandler(allowedMethods ...methodTyp) http.HandlerFunc {
+	// Build allowed methods string
+	var allowedMethodsStr string
+	if len(allowedMethods) > 0 {
+		methods := []string{}
+		for _, m := range allowedMethods {
+			if name := GetMethodStringFromType(m); name != "" {
+				methods = append(methods, name)
+			}
+		}
+		if len(methods) > 0 {
+			allowedMethodsStr = strings.Join(methods, ", ")
+		}
+	}
+
+	// If custom handler is set, wrap it to also set Allow header
 	if mx.methodNotAllowedHandler != nil {
-		return mx.methodNotAllowedHandler
+		return func(w http.ResponseWriter, r *http.Request) {
+			if allowedMethodsStr != "" {
+				w.Header().Set("Allow", allowedMethodsStr)
+			}
+			mx.methodNotAllowedHandler(w, r)
+		}
+	}
+
+	// Default handler with Allow header
+	return func(w http.ResponseWriter, r *http.Request) {
+		if allowedMethodsStr != "" {
+			w.Header().Set("Allow", allowedMethodsStr)
+		}
+		w.WriteHeader(405)
+		w.Write(nil)
 	}
-	return methodNotAllowedHandler
 }
 
 // handle registers a http.Handler in the routing tree for a particular http method
@@ -435,17 +505,37 @@ func (mx *Mux) routeHTTP(w http.ResponseWriter, r *http.Request) {
 	}
 	method, ok := methodMap[rctx.RouteMethod]
 	if !ok {
-		mx.MethodNotAllowedHandler().ServeHTTP(w, r)
+		// Method is unknown/invalid - check if custom handler is set
+		if mx.invalidMethodHandler != nil {
+			rctx.invalidMethod = true
+			mx.invalidMethodHandler.ServeHTTP(w, r)
+			return
+		}
+		// No custom handler - check if route exists with ANY method
+		// Try to find if path exists (use mGET as probe)
+		tempRctx := NewRouteContext()
+		if _, _, h := mx.tree.FindRoute(tempRctx, mGET, routePath); h != nil || tempRctx.methodNotAllowed {
+			// Route exists, return 405
+			mx.MethodNotAllowedHandler().ServeHTTP(w, r)
+			return
+		}
+		// Route doesn't exist, return 501
+		rctx.invalidMethod = true
+		invalidMethodHandler(w, r)
 		return
 	}
 
 	// Find the route
 	if _, _, h := mx.tree.FindRoute(rctx, method, routePath); h != nil {
+		// Add debug header with matched path
+		if rctx.matchedPath != "" {
+			w.Header().Set("X-Chi-Route-Pattern", rctx.matchedPath)
+		}
 		h.ServeHTTP(w, r)
 		return
 	}
 	if rctx.methodNotAllowed {
-		mx.MethodNotAllowedHandler().ServeHTTP(w, r)
+		mx.MethodNotAllowedHandler(rctx.methodsAllowed...).ServeHTTP(w, r)
 	} else {
 		mx.NotFoundHandler().ServeHTTP(w, r)
 	}
@@ -485,3 +575,39 @@ func methodNotAllowedHandler(w http.ResponseWriter, r *http.Request) {
 	w.WriteHeader(405)
 	w.Write(nil)
 }
+
+// invalidMethodHandler is a helper function to respond with a 501, not implemented.
+func invalidMethodHandler(w http.ResponseWriter, r *http.Request) {
+	w.WriteHeader(501)
+	w.Write([]byte("Method not implemented"))
+}
+
+// corsAwareMethodNotAllowedHandler handles 405 responses with CORS support
+func corsAwareMethodNotAllowedHandler(w http.ResponseWriter, r *http.Request) {
+	if r.Method == http.MethodOptions {
+		w.WriteHeader(http.StatusNoContent)
+		return
+	}
+	w.WriteHeader(405)
+	w.Write(nil)
+}
+
+// SetMethodNotAllowedResponseWithAllow sets the Allow header and returns 405
+func SetMethodNotAllowedResponseWithAllow(w http.ResponseWriter, methods []string) {
+	if len(methods) > 0 {
+		w.Header().Set("Allow", strings.Join(methods, ", "))
+	}
+	w.WriteHeader(405)
+}
+
+// RoutesInfo returns info about all registered routes
+func (mx *Mux) RoutesInfo() map[string][]string {
+	return mx.tree.routesInfo()
+}
+
+// GetRoutesDebugInfo returns a JSON string of all registered routes
+func (mx *Mux) GetRoutesDebugInfo() string {
+	info := mx.RoutesInfo()
+	data, _ := json.Marshal(info)
+	return string(data)
+}
diff --git a/tree.go b/tree.go
index 4189b52..9c29ea7 100644
--- a/tree.go
+++ b/tree.go
@@ -43,6 +43,44 @@ var methodMap = map[string]methodTyp{
 	http.MethodTrace:   mTRACE,
 }
 
+var reverseMethodMap = map[methodTyp]string{
+	mCONNECT: http.MethodConnect,
+	mDELETE:  http.MethodDelete,
+	mGET:     http.MethodGet,
+	mHEAD:    http.MethodHead,
+	mOPTIONS: http.MethodOptions,
+	mPATCH:   http.MethodPatch,
+	mPOST:    http.MethodPost,
+	mPUT:     http.MethodPut,
+	mTRACE:   http.MethodTrace,
+}
+
+var methodNames = reverseMethodMap
+
+// ValidMethod checks if a given HTTP method is recognized by the router
+func ValidMethod(method string) bool {
+	_, ok := methodMap[method]
+	return ok
+}
+
+// GetAllMethods returns all HTTP methods recognized by the router
+func GetAllMethods() []string {
+	return []string{http.MethodGet, http.MethodHead, http.MethodPost, http.MethodPut, http.MethodPatch, http.MethodDelete, http.MethodConnect, http.MethodOptions, http.MethodTrace}
+}
+
+// GetMethodStringFromType returns the string representation of a method type
+func GetMethodStringFromType(mt methodTyp) string {
+	if name, ok := reverseMethodMap[mt]; ok {
+		return name
+	}
+	return ""
+}
+
+// GetMethodName returns the HTTP method name for a method type
+func GetMethodName(mt methodTyp) string {
+	return GetMethodStringFromType(mt)
+}
+
 // RegisterMethod adds support for custom HTTP method handlers, available
 // via Router#Method and Router#MethodFunc
 func RegisterMethod(method string) {
@@ -388,6 +426,11 @@ func (n *node) findRoute(rctx *Context, method methodTyp, path string) *node {
 	nn := n
 	search := path
 
+	// Add to tracing info
+	if len(rctx.triedPaths) < 100 {
+		rctx.triedPaths = append(rctx.triedPaths, path)
+	}
+
 	for t, nds := range nn.children {
 		ntyp := nodeTyp(t)
 		if len(nds) == 0 {
@@ -451,9 +494,17 @@ func (n *node) findRoute(rctx *Context, method methodTyp, path string) *node {
 						h := xn.endpoints[method]
 						if h != nil && h.handler != nil {
 							rctx.routeParams.Keys = append(rctx.routeParams.Keys, h.paramKeys...)
+							rctx.SetMatchedPath(h.pattern)
 							return xn
 						}
 
+						for endpoints := range xn.endpoints {
+							if endpoints == mALL || endpoints == mSTUB {
+								continue
+							}
+							rctx.methodsAllowed = append(rctx.methodsAllowed, endpoints)
+						}
+
 						// flag that the routing context found a route, but not a corresponding
 						// supported method
 						rctx.methodNotAllowed = true
@@ -490,9 +541,17 @@ func (n *node) findRoute(rctx *Context, method methodTyp, path string) *node {
 				h := xn.endpoints[method]
 				if h != nil && h.handler != nil {
 					rctx.routeParams.Keys = append(rctx.routeParams.Keys, h.paramKeys...)
+					rctx.SetMatchedPath(h.pattern)
 					return xn
 				}
 
+				for endpoints := range xn.endpoints {
+					if endpoints == mALL || endpoints == mSTUB {
+						continue
+					}
+					rctx.methodsAllowed = append(rctx.methodsAllowed, endpoints)
+				}
+
 				// flag that the routing context found a route, but not a corresponding
 				// supported method
 				rctx.methodNotAllowed = true
@@ -641,6 +700,20 @@ func (n *node) routes() []Route {
 	return rts
 }
 
+// routesInfo returns a map of all registered routes with their methods
+func (n *node) routesInfo() map[string][]string {
+	info := make(map[string][]string)
+	routes := n.routes()
+	for _, rt := range routes {
+		methods := []string{}
+		for method := range rt.Handlers {
+			methods = append(methods, method)
+		}
+		info[rt.Pattern] = methods
+	}
+	return info
+}
+
 func (n *node) walk(fn func(eps endpoints, subroutes Routes) bool) bool {
 	// Visit the leaf values if any
 	if (n.endpoints != nil || n.subroutes != nil) && fn(n.endpoints, n.subroutes) {
