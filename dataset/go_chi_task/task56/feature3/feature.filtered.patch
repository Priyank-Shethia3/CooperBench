diff --git a/context.go b/context.go
index e78a238..a13d197 100644
--- a/context.go
+++ b/context.go
@@ -2,6 +2,7 @@ package chi
 
 import (
 	"context"
+	"fmt"
 	"net/http"
 	"strings"
 )
@@ -76,6 +77,10 @@ type Context struct {
 
 	// methodNotAllowed hint
 	methodNotAllowed bool
+
+	// Trace information
+	matchedPath string   // Records the path pattern that matched
+	triedPaths  []string // Records paths that were tried during routing
 }
 
 // Reset a routing context to its initial state.
@@ -91,6 +96,8 @@ func (x *Context) Reset() {
 	x.routeParams.Keys = x.routeParams.Keys[:0]
 	x.routeParams.Values = x.routeParams.Values[:0]
 	x.methodNotAllowed = false
+	x.matchedPath = ""
+	x.triedPaths = x.triedPaths[:0]
 	x.parentCtx = nil
 }
 
@@ -112,13 +119,13 @@ func (x *Context) URLParam(key string) string {
 //
 // For example,
 //
-//   func Instrument(next http.Handler) http.Handler {
-//     return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-//       next.ServeHTTP(w, r)
-//       routePattern := chi.RouteContext(r.Context()).RoutePattern()
-//       measure(w, r, routePattern)
-//   	 })
-//   }
+//	func Instrument(next http.Handler) http.Handler {
+//	  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+//	    next.ServeHTTP(w, r)
+//	    routePattern := chi.RouteContext(r.Context()).RoutePattern()
+//	    measure(w, r, routePattern)
+//		 })
+//	}
 func (x *Context) RoutePattern() string {
 	routePattern := strings.Join(x.RoutePatterns, "")
 	routePattern = replaceWildcards(routePattern)
@@ -157,3 +164,18 @@ type contextKey struct {
 func (k *contextKey) String() string {
 	return "chi context value " + k.name
 }
+
+// SetMatchedPath records the pattern that matched the current request
+func (x *Context) SetMatchedPath(path string) {
+	x.matchedPath = path
+}
+
+// GetMatchedPath returns the pattern that matched the current request
+func (x *Context) GetMatchedPath() string {
+	return x.matchedPath
+}
+
+// GetRouteDebugInfo returns a string with debug information about route matching
+func (x *Context) GetRouteDebugInfo() string {
+	return fmt.Sprintf("Matched: %s\nTried paths: %s", x.matchedPath, strings.Join(x.triedPaths, ", "))
+}
diff --git a/mux.go b/mux.go
index 0d1caa6..63fafa4 100644
--- a/mux.go
+++ b/mux.go
@@ -2,6 +2,7 @@ package chi
 
 import (
 	"context"
+	"encoding/json"
 	"fmt"
 	"net/http"
 	"strings"
@@ -440,11 +441,18 @@ func (mx *Mux) routeHTTP(w http.ResponseWriter, r *http.Request) {
 	}
 
 	// Find the route
-	if _, _, h := mx.tree.FindRoute(rctx, method, routePath); h != nil {
+	_, _, h := mx.tree.FindRoute(rctx, method, routePath)
+	if h != nil {
 		h.ServeHTTP(w, r)
 		return
 	}
+
 	if rctx.methodNotAllowed {
+		// Add debug headers if available
+		if rctx.GetMatchedPath() != "" {
+			w.Header().Set("X-Route-Match", rctx.GetMatchedPath())
+			w.Header().Set("X-Route-Debug", "method_not_allowed")
+		}
 		mx.MethodNotAllowedHandler().ServeHTTP(w, r)
 	} else {
 		mx.NotFoundHandler().ServeHTTP(w, r)
@@ -460,6 +468,13 @@ func (mx *Mux) nextRoutePath(rctx *Context) string {
 	return routePath
 }
 
+// RouteDebugInfo returns JSON string with routing tree info for debugging
+func (mx *Mux) RouteDebugInfo() string {
+	routeInfo := mx.tree.routesInfo()
+	debug, _ := json.MarshalIndent(routeInfo, "", "  ")
+	return string(debug)
+}
+
 // Recursively update data on child routers.
 func (mx *Mux) updateSubRoutes(fn func(subMux *Mux)) {
 	for _, r := range mx.tree.routes() {
diff --git a/tree.go b/tree.go
index 4189b52..1cdbec7 100644
--- a/tree.go
+++ b/tree.go
@@ -357,6 +357,8 @@ func (n *node) setEndpoint(method methodTyp, handler http.Handler, pattern strin
 	}
 }
 
+// FindRoute searches for a handler that matches the method/path, returning the node, path
+// parameters and whether the method is allowed if no handler is found with the exact method.
 func (n *node) FindRoute(rctx *Context, method methodTyp, path string) (*node, endpoints, http.Handler) {
 	// Reset the context routing pattern and params
 	rctx.routePattern = ""
@@ -388,6 +390,11 @@ func (n *node) findRoute(rctx *Context, method methodTyp, path string) *node {
 	nn := n
 	search := path
 
+	// Add to tracing info
+	if len(rctx.triedPaths) < 100 { // Prevent excessive memory usage
+		rctx.triedPaths = append(rctx.triedPaths, path)
+	}
+
 	for t, nds := range nn.children {
 		ntyp := nodeTyp(t)
 		if len(nds) == 0 {
@@ -451,6 +458,7 @@ func (n *node) findRoute(rctx *Context, method methodTyp, path string) *node {
 						h := xn.endpoints[method]
 						if h != nil && h.handler != nil {
 							rctx.routeParams.Keys = append(rctx.routeParams.Keys, h.paramKeys...)
+							rctx.SetMatchedPath(h.pattern)
 							return xn
 						}
 
@@ -490,6 +498,7 @@ func (n *node) findRoute(rctx *Context, method methodTyp, path string) *node {
 				h := xn.endpoints[method]
 				if h != nil && h.handler != nil {
 					rctx.routeParams.Keys = append(rctx.routeParams.Keys, h.paramKeys...)
+					rctx.SetMatchedPath(h.pattern)
 					return xn
 				}
 
@@ -593,7 +602,26 @@ func (n *node) findPattern(pattern string) bool {
 
 func (n *node) routes() []Route {
 	rts := []Route{}
+	return n.walkRoutes(rts)
+}
+
+// RoutesInfo returns a map of all registered routes with their methods
+func (n *node) routesInfo() map[string][]string {
+	info := make(map[string][]string)
+	routes := n.routes()
+	for _, rt := range routes {
+		methods := []string{}
+		for method := range rt.Handlers {
+			methods = append(methods, method)
+		}
+		info[rt.Pattern] = methods
+	}
+	return info
+}
 
+// walkRoutes recursively walks the node tree and collects routes
+func (n *node) walkRoutes(rts []Route) []Route {
+	// Handle walking the tree and collecting routes
 	n.walk(func(eps endpoints, subroutes Routes) bool {
 		if eps[mSTUB] != nil && eps[mSTUB].handler != nil && subroutes == nil {
 			return false

