From e2e56a5275a47e04133815c751f00b2f720d5784 Mon Sep 17 00:00:00 2001
From: EwenQuim <ewen.quimerch@gmail.com>
Date: Sat, 24 Dec 2022 03:05:43 +0100
Subject: [PATCH 1/2] middleware: SetAllowHeader adds the Allow header on 405
 response Makes chi compliant with rfc9110 (cf
 https://httpwg.org/specs/rfc9110.html#field.allow) Currently this behaviour
 is not supported, and it adds a small but non-negligable performance offset.
 That's why it is proposed as a middleware

---
 middleware/allowed_methods.go      |  28 ++++++
 middleware/allowed_methods_test.go | 149 +++++++++++++++++++++++++++++
 2 files changed, 177 insertions(+)
 create mode 100644 middleware/allowed_methods.go
 create mode 100644 middleware/allowed_methods_test.go

diff --git a/middleware/allowed_methods_test.go b/middleware/allowed_methods_test.go
new file mode 100644
index 00000000..4e87c1f5
--- /dev/null
+++ b/middleware/allowed_methods_test.go
@@ -0,0 +1,149 @@
+package middleware
+
+import (
+	"fmt"
+	"net/http"
+	"net/http/httptest"
+	"testing"
+
+	"github.com/go-chi/chi/v5"
+)
+
+// setupRouter returns a chi router with a GET and HEAD handler for /hi.
+// It is just a small helper to avoid code duplication in the tests.
+func setupRouter(withAllowHeader bool) *chi.Mux {
+	r := chi.NewRouter()
+	if withAllowHeader {
+		r.Use(SetAllowHeader)
+	}
+	r.Get("/hi", func(w http.ResponseWriter, r *http.Request) {
+		w.Write([]byte("hi, get"))
+	})
+
+	r.Head("/hi", func(w http.ResponseWriter, r *http.Request) {
+		w.Write([]byte("hi, head"))
+	})
+
+	return r
+}
+
+func TestSetAllowHeader(t *testing.T) {
+	r := setupRouter(true)
+
+	ts := httptest.NewServer(r)
+	defer ts.Close()
+
+	t.Run("Registered Method", func(t *testing.T) {
+		res, err := http.Get(ts.URL + "/hi")
+		if err != nil {
+			t.Fatal(err)
+		}
+		if res.StatusCode != 200 {
+			t.Fatal(res.Status)
+		}
+		if res.Header.Values("Allow") != nil {
+			t.Fatal("allow:", res.Header.Values("Allow"))
+		}
+	})
+
+	t.Run("Unregistered Method", func(t *testing.T) {
+		res, err := http.Post(ts.URL+"/hi", "text/plain", nil)
+		if err != nil {
+			t.Fatal(err)
+		}
+		if res.StatusCode != 405 {
+			t.Fatal(res.Status)
+		}
+		if res.Header.Values("Allow")[0] != "GET" || res.Header.Values("Allow")[1] != "HEAD" {
+			t.Fatal(res.Header.Get("Allow"))
+		}
+	})
+}
+
+func ExampleSetAllowHeader() {
+	r := chi.NewRouter()
+	r.Use(SetAllowHeader)
+	r.Get("/hi", func(w http.ResponseWriter, r *http.Request) {
+		w.Write([]byte("hi, get"))
+	})
+	r.Head("/hi", func(w http.ResponseWriter, r *http.Request) {
+		w.Write([]byte("hi, head"))
+	})
+
+	ts := httptest.NewServer(r)
+	defer ts.Close()
+
+	res, _ := http.Post(ts.URL+"/hi", "text/plain", nil)
+	fmt.Println(res.Status)
+	fmt.Println(res.Header.Values("Allow"))
+
+	// Output:
+	// 405 Method Not Allowed
+	// [GET HEAD]
+}
+
+func BenchmarkSetAllowHeaderWhen405(b *testing.B) {
+	r := setupRouter(true)
+
+	req, err := http.NewRequest("POST", "/hi", nil)
+	if err != nil {
+		b.Fatal(err)
+	}
+
+	w := httptest.NewRecorder()
+
+	for i := 0; i < b.N; i++ {
+		r.ServeHTTP(w, req)
+		res := w.Result()
+		if res.StatusCode != 405 {
+			b.Fatal(res.Status)
+		}
+		if res.Header.Values("Allow")[0] != "GET" || res.Header.Values("Allow")[1] != "HEAD" {
+			b.Fatal(res.Header.Get("Allow"))
+		}
+	}
+}
+
+func BenchmarkSetAllowHeaderWhen200(b *testing.B) {
+	r := setupRouter(true)
+
+	req, err := http.NewRequest("GET", "/hi", nil)
+	if err != nil {
+		b.Fatal(err)
+	}
+
+	w := httptest.NewRecorder()
+
+	for i := 0; i < b.N; i++ {
+		r.ServeHTTP(w, req)
+		res := w.Result()
+		if res.StatusCode != 200 {
+			b.Fatal(res.Status)
+		}
+		if res.Header.Values("Allow") != nil {
+			b.Fatal(res.Header.Get("Allow"))
+		}
+	}
+}
+
+func BenchmarkWithoutSetAllowHeader(b *testing.B) {
+	r := setupRouter(false)
+
+	req, err := http.NewRequest("GET", "/hi", nil)
+	if err != nil {
+		b.Fatal(err)
+	}
+
+	w := httptest.NewRecorder()
+
+	for i := 0; i < b.N; i++ {
+		r.ServeHTTP(w, req)
+		res := w.Result()
+		if res.StatusCode != 200 {
+			b.Fatal(res.Status)
+		}
+		if res.Header.Values("Allow") != nil {
+			b.Fatal(res.Header.Get("Allow"))
+		}
+	}
+}

diff --git a/mux_test.go b/mux_test.go
index 68fc94c0..0f8f8995 100644
--- a/mux_test.go
+++ b/mux_test.go
@@ -392,6 +392,43 @@ func TestMuxNestedNotFound(t *testing.T) {
 	}
 }
 
+func TestMethodNotAllowed(t *testing.T) {
+	r := NewRouter()
+
+	r.Get("/hi", func(w http.ResponseWriter, r *http.Request) {
+		w.Write([]byte("hi, get"))
+	})
+
+	r.Head("/hi", func(w http.ResponseWriter, r *http.Request) {
+		w.Write([]byte("hi, head"))
+	})
+
+	ts := httptest.NewServer(r)
+	defer ts.Close()
+
+	t.Run("Registered Method", func(t *testing.T) {
+		resp, _ := testRequest(t, ts, "GET", "/hi", nil)
+		if resp.StatusCode != 200 {
+			t.Fatal(resp.Status)
+		}
+		if resp.Header.Values("Allow") != nil {
+			t.Fatal("allow should be empty when method is registered")
+		}
+	})
+
+	t.Run("Unregistered Method", func(t *testing.T) {
+		resp, _ := testRequest(t, ts, "POST", "/hi", nil)
+		if resp.StatusCode != 405 {
+			t.Fatal(resp.Status)
+		}
+		allowedMethods := resp.Header.Values("Allow")
+		if len(allowedMethods) != 2 || allowedMethods[0] != "GET" || allowedMethods[1] != "HEAD" {
+			t.Fatal("Allow header should contain 2 headers: GET, HEAD. Received: ", allowedMethods)
+
+		}
+	})
+}
+
 func TestMuxNestedMethodNotAllowed(t *testing.T) {
 	r := NewRouter()
 	r.Get("/root", func(w http.ResponseWriter, r *http.Request) {
@@ -1771,6 +1808,7 @@ func BenchmarkMux(b *testing.B) {
 	mx := NewRouter()
 	mx.Get("/", h1)
 	mx.Get("/hi", h2)
+	mx.Post("/hi-post", h2) // used to benchmark 405 responses
 	mx.Get("/sup/{id}/and/{this}", h3)
 	mx.Get("/sup/{id}/{bar:foo}/{this}", h3)
 
@@ -1787,6 +1825,7 @@ func BenchmarkMux(b *testing.B) {
 	routes := []string{
 		"/",
 		"/hi",
+		"/hi-post",
 		"/sup/123/and/this",
 		"/sup/123/foo/this",
 		"/sharing/z/aBc",                 // subrouter-1
