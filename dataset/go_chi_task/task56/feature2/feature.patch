diff --git a/context.go b/context.go
index e78a238..a0c8b44 100644
--- a/context.go
+++ b/context.go
@@ -76,6 +76,9 @@ type Context struct {
 
 	// methodNotAllowed hint
 	methodNotAllowed bool
+
+	// invalidMethod flag for invalid/unrecognized HTTP method
+	invalidMethod bool
 }
 
 // Reset a routing context to its initial state.
@@ -91,6 +94,7 @@ func (x *Context) Reset() {
 	x.routeParams.Keys = x.routeParams.Keys[:0]
 	x.routeParams.Values = x.routeParams.Values[:0]
 	x.methodNotAllowed = false
+	x.invalidMethod = false
 	x.parentCtx = nil
 }
 
diff --git a/mux.go b/mux.go
index 0d1caa6..ee8cffe 100644
--- a/mux.go
+++ b/mux.go
@@ -45,6 +45,9 @@ type Mux struct {
 	// Controls the behaviour of middleware chain generation when a mux
 	// is registered as an inline group inside another mux.
 	inline bool
+
+	// Handler for unrecognized methods
+	invalidMethodHandler http.HandlerFunc
 }
 
 // NewMux returns a newly initialized Mux object that implements the Router
@@ -226,6 +229,19 @@ func (mx *Mux) MethodNotAllowed(handlerFn http.HandlerFunc) {
 	})
 }
 
+// SetInvalidMethodHandler sets a custom http.HandlerFunc for invalid HTTP methods
+func (mx *Mux) SetInvalidMethodHandler(fn http.HandlerFunc) {
+	mx.invalidMethodHandler = fn
+}
+
+// InvalidMethodHandler returns the handler for unrecognized HTTP methods
+func (mx *Mux) InvalidMethodHandler() http.HandlerFunc {
+	if mx.invalidMethodHandler != nil {
+		return mx.invalidMethodHandler
+	}
+	return invalidMethodHandler
+}
+
 // With adds inline middlewares for an endpoint handler.
 func (mx *Mux) With(middlewares ...func(http.Handler) http.Handler) Router {
 	// Similarly as in handle(), we must build the mux handler once additional
@@ -435,7 +451,22 @@ func (mx *Mux) routeHTTP(w http.ResponseWriter, r *http.Request) {
 	}
 	method, ok := methodMap[rctx.RouteMethod]
 	if !ok {
-		mx.MethodNotAllowedHandler().ServeHTTP(w, r)
+		rctx.invalidMethod = true
+		// Method is unknown/invalid - check if custom handler is set
+		if mx.invalidMethodHandler != nil {
+			mx.invalidMethodHandler.ServeHTTP(w, r)
+			return
+		}
+		// No custom handler - check if route exists with ANY method
+		// Try to find if path exists (use mGET as probe)
+		tempRctx := NewRouteContext()
+		if _, _, h := mx.tree.FindRoute(tempRctx, mGET, routePath); h != nil || tempRctx.methodNotAllowed {
+			// Route exists, return 405
+			mx.MethodNotAllowedHandler().ServeHTTP(w, r)
+			return
+		}
+		// Route doesn't exist, return 501
+		invalidMethodHandler(w, r)
 		return
 	}
 
@@ -485,3 +516,9 @@ func methodNotAllowedHandler(w http.ResponseWriter, r *http.Request) {
 	w.WriteHeader(405)
 	w.Write(nil)
 }
+
+// invalidMethodHandler is a helper function to respond with a 501, not implemented.
+func invalidMethodHandler(w http.ResponseWriter, r *http.Request) {
+	w.WriteHeader(501)
+	w.Write([]byte("Method not implemented"))
+}
diff --git a/tree.go b/tree.go
index 4189b52..4ffe22e 100644
--- a/tree.go
+++ b/tree.go
@@ -43,6 +43,17 @@ var methodMap = map[string]methodTyp{
 	http.MethodTrace:   mTRACE,
 }
 
+// ValidMethod checks if a given HTTP method is recognized by the router
+func ValidMethod(method string) bool {
+	_, ok := methodMap[method]
+	return ok
+}
+
+// GetAllMethods returns all HTTP methods recognized by the router
+func GetAllMethods() []string {
+	return []string{http.MethodGet, http.MethodHead, http.MethodPost, http.MethodPut, http.MethodPatch, http.MethodDelete, http.MethodConnect, http.MethodOptions, http.MethodTrace}
+}
+
 // RegisterMethod adds support for custom HTTP method handlers, available
 // via Router#Method and Router#MethodFunc
 func RegisterMethod(method string) {
