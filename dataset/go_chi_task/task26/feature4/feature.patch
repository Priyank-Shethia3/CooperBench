diff --git a/context.go b/context.go
index 82e5f28..b925d4d 100644
--- a/context.go
+++ b/context.go
@@ -77,6 +77,10 @@ type Context struct {
 	// methodNotAllowed hint
 	methodNotAllowed bool
 	methodsAllowed   []methodTyp // allowed methods in case of a 405
+
+	// Priority routing fields
+	priorityHandler http.Handler
+	routePriority   int
 }
 
 // Reset a routing context to its initial state.
@@ -94,6 +98,10 @@ func (x *Context) Reset() {
 	x.methodNotAllowed = false
 	x.methodsAllowed = x.methodsAllowed[:0]
 	x.parentCtx = nil
+
+	// Reset priority routing fields
+	x.priorityHandler = nil
+	x.routePriority = 0
 }
 
 // URLParam returns the corresponding URL parameter value from the request
diff --git a/mux.go b/mux.go
index 56fa4d2..ebd92a7 100644
--- a/mux.go
+++ b/mux.go
@@ -45,6 +45,9 @@ type Mux struct {
 	// Controls the behaviour of middleware chain generation when a mux
 	// is registered as an inline group inside another mux.
 	inline bool
+
+	// The priority of the next registered route
+	nextRoutePriority int
 }
 
 // NewMux returns a newly initialized Mux object that implements the Router
@@ -264,6 +267,12 @@ func (mx *Mux) With(middlewares ...func(http.Handler) http.Handler) Router {
 	return im
 }
 
+// WithPriority sets a priority for the next registered route
+func (mx *Mux) WithPriority(priority int) *Mux {
+	mx.nextRoutePriority = priority
+	return mx
+}
+
 // Group creates a new inline-Mux with a copy of middleware stack. It's useful
 // for a group of handlers along the same routing path that use an additional
 // set of middlewares. See _examples/.
@@ -420,7 +429,24 @@ func (mx *Mux) handle(method methodTyp, pattern string, handler http.Handler) *n
 	}
 
 	// Add the endpoint to the tree and return the node
-	return mx.tree.InsertRoute(method, pattern, h)
+	n := mx.tree.InsertRoute(method, pattern, h)
+
+	// If there's a priority set, store it in the node
+	if mx.nextRoutePriority > 0 {
+		if n.endpoints == nil {
+			n.endpoints = make(endpoints)
+		}
+
+		methodEndpoint := n.endpoints[method]
+		if methodEndpoint != nil {
+			methodEndpoint.priority = mx.nextRoutePriority
+		}
+
+		// Reset priority for next route
+		mx.nextRoutePriority = 0
+	}
+
+	return n
 }
 
 // routeHTTP routes a http.Request through the Mux routing tree to serve
@@ -454,7 +480,14 @@ func (mx *Mux) routeHTTP(w http.ResponseWriter, r *http.Request) {
 
 	// Find the route
 	if _, _, h := mx.tree.FindRoute(rctx, method, routePath); h != nil {
-		h.ServeHTTP(w, r)
+		// Check if there's a priority handler to consider
+		if rctx.priorityHandler != nil {
+			// A higher priority handler was found during route matching
+			rctx.priorityHandler.ServeHTTP(w, r)
+		} else {
+			// No priority handler found, use the matched handler
+			h.ServeHTTP(w, r)
+		}
 		return
 	}
 	if rctx.methodNotAllowed {
diff --git a/priority.go b/priority.go
new file mode 100644
index 0000000..adebcdf
--- /dev/null
+++ b/priority.go
@@ -0,0 +1,36 @@
+package chi
+
+import (
+	"net/http"
+)
+
+// Route priorities
+const (
+	// PriorityHighest is the highest possible priority for a route
+	PriorityHighest = 100
+
+	// PriorityHigh is a high priority route
+	PriorityHigh = 75
+
+	// PriorityNormal is the default priority
+	PriorityNormal = 50
+
+	// PriorityLow is a low priority route
+	PriorityLow = 25
+
+	// PriorityLowest is the lowest possible priority
+	PriorityLowest = 0
+)
+
+// evalPriorityHandler evaluates if a handler should take precedence based on priority
+func evalPriorityHandler(ctx *Context, pattern string, handler http.Handler, priority int) bool {
+	// If no priority handler is set, or if this handler has higher priority
+	if ctx.priorityHandler == nil || priority > ctx.routePriority {
+		ctx.priorityHandler = handler
+		ctx.routePriority = priority
+		ctx.routePattern = pattern
+		return true
+	}
+
+	return false
+}
diff --git a/tree.go b/tree.go
index c7d3bc5..2fa3502 100644
--- a/tree.go
+++ b/tree.go
@@ -123,6 +123,9 @@ type endpoint struct {
 
 	// parameter keys recorded on handler nodes
 	paramKeys []string
+
+	// priority for this endpoint
+	priority int
 }
 
 func (s endpoints) Value(method methodTyp) *endpoint {
@@ -369,6 +372,8 @@ func (n *node) setEndpoint(method methodTyp, handler http.Handler, pattern strin
 	}
 }
 
+// FindRoute searches the routing tree for a handler that matches
+// the method/path combo, also tracking param keys and values.
 func (n *node) FindRoute(rctx *Context, method methodTyp, path string) (*node, endpoints, http.Handler) {
 	// Reset the context routing pattern and params
 	rctx.routePattern = ""
@@ -391,6 +396,11 @@ func (n *node) FindRoute(rctx *Context, method methodTyp, path string) (*node, e
 		rctx.RoutePatterns = append(rctx.RoutePatterns, rctx.routePattern)
 	}
 
+	// During the FindRoute process, check and store priority handlers in rctx
+	if rn.endpoints[method].priority > 0 {
+		evalPriorityHandler(rctx, rn.endpoints[method].pattern, rn.endpoints[method].handler, rn.endpoints[method].priority)
+	}
+
 	return rn, rn.endpoints, rn.endpoints[method].handler
 }
 
