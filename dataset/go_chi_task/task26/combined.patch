diff --git a/context.go b/context.go
index 82e5f28..8dde952 100644
--- a/context.go
+++ b/context.go
@@ -34,6 +34,25 @@ func NewRouteContext() *Context {
 	return &Context{}
 }
 
+// WithRouteSelector adds a dynamic route selector to the request context
+func WithRouteSelector(r *http.Request, selector RouteSelector) *http.Request {
+	rctx := RouteContext(r.Context())
+	if rctx == nil {
+		rctx = NewRouteContext()
+		r = r.WithContext(context.WithValue(r.Context(), RouteCtxKey, rctx))
+	}
+	rctx.RouteSelector = selector
+	return r
+}
+
+// GetRouteSelector returns the route selector from the request context, if any
+func GetRouteSelector(r *http.Request) RouteSelector {
+	if rctx := RouteContext(r.Context()); rctx != nil {
+		return rctx.RouteSelector
+	}
+	return nil
+}
+
 var (
 	// RouteCtxKey is the context.Context key to store the request context.
 	RouteCtxKey = &contextKey{"RouteContext"}
@@ -77,6 +96,16 @@ type Context struct {
 	// methodNotAllowed hint
 	methodNotAllowed bool
 	methodsAllowed   []methodTyp // allowed methods in case of a 405
+
+	// RouteSelector allows dynamic selection of handlers based on request
+	RouteSelector RouteSelector
+
+	// RouteTransformer allows modification of handlers after selection
+	RouteTransformer RouteTransformer
+
+	// Priority routing fields
+	priorityHandler http.Handler
+	routePriority   int
 }
 
 // Reset a routing context to its initial state.
@@ -94,6 +123,12 @@ func (x *Context) Reset() {
 	x.methodNotAllowed = false
 	x.methodsAllowed = x.methodsAllowed[:0]
 	x.parentCtx = nil
+	x.RouteSelector = nil
+	x.RouteTransformer = nil
+
+	// Reset priority routing fields
+	x.priorityHandler = nil
+	x.routePriority = 0
 }
 
 // URLParam returns the corresponding URL parameter value from the request
diff --git a/dynamic_route.go b/dynamic_route.go
new file mode 100644
index 0000000..e372b9e
--- /dev/null
+++ b/dynamic_route.go
@@ -0,0 +1,118 @@
+package chi
+
+import (
+	"net/http"
+	"strings"
+)
+
+// RouteSelector allows dynamic selection of handlers based on request properties
+type RouteSelector interface {
+	// SelectRoute chooses a handler based on the request and the matched pattern
+	SelectRoute(r *http.Request, pattern string, handler http.Handler) http.Handler
+}
+
+// RouteTransformer allows modification of handlers after selection
+type RouteTransformer interface {
+	// TransformHandler wraps or replaces a handler based on request properties
+	TransformHandler(r *http.Request, pattern string, handler http.Handler) http.Handler
+}
+
+// VersionSelector implements RouteSelector to provide API versioning
+type VersionSelector struct {
+	// DefaultVersion is used if no version is specified in the request
+	DefaultVersion string
+
+	// Handlers maps versions to their specific handlers
+	Handlers map[string]map[string]http.Handler
+}
+
+// NewVersionSelector creates a new version selector with the given default version
+func NewVersionSelector(defaultVersion string) *VersionSelector {
+	return &VersionSelector{
+		DefaultVersion: defaultVersion,
+		Handlers:       make(map[string]map[string]http.Handler),
+	}
+}
+
+// AddHandler registers a handler for a specific route pattern and version
+func (vs *VersionSelector) AddHandler(pattern, version string, handler http.Handler) {
+	if vs.Handlers[pattern] == nil {
+		vs.Handlers[pattern] = make(map[string]http.Handler)
+	}
+	vs.Handlers[pattern][version] = handler
+}
+
+// SelectRoute implements RouteSelector interface
+func (vs *VersionSelector) SelectRoute(r *http.Request, pattern string, defaultHandler http.Handler) http.Handler {
+	// Extract version from Accept header or query param
+	version := r.URL.Query().Get("version")
+	if version == "" {
+		accept := r.Header.Get("Accept")
+		if strings.Contains(accept, "version=") {
+			parts := strings.Split(accept, "version=")
+			if len(parts) > 1 {
+				version = strings.Split(parts[1], ";")[0]
+			}
+		}
+	}
+
+	// If no version found, use default
+	if version == "" {
+		version = vs.DefaultVersion
+	}
+
+	// Find handler for this pattern and version
+	if vs.Handlers[pattern] != nil && vs.Handlers[pattern][version] != nil {
+		return vs.Handlers[pattern][version]
+	}
+
+	return defaultHandler
+}
+
+// RoleBasedSelector implements RouteSelector to provide role-based routing
+type RoleBasedSelector struct {
+	// RoleExtractor is a function that determines the user's role from the request
+	RoleExtractor func(r *http.Request) string
+
+	// DefaultRole is used when no role can be determined from the request
+	DefaultRole string
+
+	// Handlers maps roles to their specific handlers for each pattern
+	Handlers map[string]map[string]http.Handler
+}
+
+// NewRoleBasedSelector creates a new role-based selector
+func NewRoleBasedSelector(roleExtractor func(r *http.Request) string, defaultRole string) *RoleBasedSelector {
+	return &RoleBasedSelector{
+		RoleExtractor: roleExtractor,
+		DefaultRole:   defaultRole,
+		Handlers:      make(map[string]map[string]http.Handler),
+	}
+}
+
+// AddHandler registers a handler for a specific route pattern and role
+func (rs *RoleBasedSelector) AddHandler(pattern, role string, handler http.Handler) {
+	if rs.Handlers[pattern] == nil {
+		rs.Handlers[pattern] = make(map[string]http.Handler)
+	}
+	rs.Handlers[pattern][role] = handler
+}
+
+// SelectRoute implements RouteSelector interface
+func (rs *RoleBasedSelector) SelectRoute(r *http.Request, pattern string, defaultHandler http.Handler) http.Handler {
+	// Extract role from request using the provided extractor
+	role := rs.RoleExtractor(r)
+
+	// If no role found, use default
+	if role == "" {
+		role = rs.DefaultRole
+	}
+
+	// Find handler for this pattern and role
+	if rs.Handlers[pattern] != nil && rs.Handlers[pattern][role] != nil {
+		return rs.Handlers[pattern][role]
+	}
+
+	return defaultHandler
+}
+
diff --git a/metrics.go b/metrics.go
new file mode 100644
index 0000000..f71bd03
--- /dev/null
+++ b/metrics.go
@@ -0,0 +1,52 @@
+package chi
+
+import (
+	"net/http"
+	"time"
+)
+
+// RouteMetric contains information about a route hit
+type RouteMetric struct {
+	// Pattern is the route pattern that was matched
+	Pattern string
+
+	// Method is the HTTP method used
+	Method string
+
+	// Path is the actual request path
+	Path string
+
+	// Duration is how long the request took to process
+	Duration time.Duration
+
+	// Params contains any URL parameters
+	Params map[string]string
+}
+
+// MetricsCollector defines an interface for collecting router metrics
+type MetricsCollector interface {
+	// RecordHit records a hit on a particular route
+	RecordHit(ctx *Context, r *http.Request, duration time.Duration)
+}
+
+// SimpleMetricsCollector is a basic implementation of MetricsCollector
+type SimpleMetricsCollector struct {
+	OnHit func(metric RouteMetric)
+}
+
+// RecordHit implements the MetricsCollector interface
+func (s *SimpleMetricsCollector) RecordHit(ctx *Context, r *http.Request, duration time.Duration) {
+	params := make(map[string]string)
+	for i, key := range ctx.URLParams.Keys {
+		params[key] = ctx.URLParams.Values[i]
+	}
+
+	s.OnHit(RouteMetric{
+		Pattern:  ctx.RoutePattern(),
+		Method:   r.Method,
+		Path:     r.URL.Path,
+		Duration: duration,
+		Params:   params,
+	})
+}
+
diff --git a/mux.go b/mux.go
index 56fa4d2..05a1806 100644
--- a/mux.go
+++ b/mux.go
@@ -6,6 +6,7 @@ import (
 	"net/http"
 	"strings"
 	"sync"
+	"time"
 )
 
 var _ Router = &Mux{}
@@ -45,6 +46,12 @@ type Mux struct {
 	// Controls the behaviour of middleware chain generation when a mux
 	// is registered as an inline group inside another mux.
 	inline bool
+
+	// Metrics collector for route monitoring
+	metricsCollector MetricsCollector
+
+	// The priority of the next registered route
+	nextRoutePriority int
 }
 
 // NewMux returns a newly initialized Mux object that implements the Router
@@ -264,6 +271,12 @@ func (mx *Mux) With(middlewares ...func(http.Handler) http.Handler) Router {
 	return im
 }
 
+// WithPriority sets a priority for the next registered route
+func (mx *Mux) WithPriority(priority int) *Mux {
+	mx.nextRoutePriority = priority
+	return mx
+}
+
 // Group creates a new inline-Mux with a copy of middleware stack. It's useful
 // for a group of handlers along the same routing path that use an additional
 // set of middlewares. See _examples/.
@@ -420,7 +433,24 @@ func (mx *Mux) handle(method methodTyp, pattern string, handler http.Handler) *n
 	}
 
 	// Add the endpoint to the tree and return the node
-	return mx.tree.InsertRoute(method, pattern, h)
+	n := mx.tree.InsertRoute(method, pattern, h)
+
+	// If there's a priority set, store it in the node
+	if mx.nextRoutePriority > 0 {
+		if n.endpoints == nil {
+			n.endpoints = make(endpoints)
+		}
+
+		methodEndpoint := n.endpoints[method]
+		if methodEndpoint != nil {
+			methodEndpoint.priority = mx.nextRoutePriority
+		}
+
+		// Reset priority for next route
+		mx.nextRoutePriority = 0
+	}
+
+	return n
 }
 
 // routeHTTP routes a http.Request through the Mux routing tree to serve
@@ -453,8 +483,43 @@ func (mx *Mux) routeHTTP(w http.ResponseWriter, r *http.Request) {
 	}
 
 	// Find the route
-	if _, _, h := mx.tree.FindRoute(rctx, method, routePath); h != nil {
+	_, _, h := mx.tree.FindRoute(rctx, method, routePath)
+
+	if h != nil {
+		// Check for dynamic route selection
+		if rctx.RouteSelector != nil {
+			routePattern := rctx.RoutePattern()
+			if dynamicHandler := rctx.RouteSelector.SelectRoute(r, routePattern, h); dynamicHandler != nil {
+				h = dynamicHandler
+			}
+		}
+
+		// Apply any route transformations from request context
+		if rctx.RouteTransformer != nil {
+			routePattern := rctx.RoutePattern()
+			h = rctx.RouteTransformer.TransformHandler(r, routePattern, h)
+		}
+
+		// Check if there's a priority handler to consider
+		if rctx.priorityHandler != nil {
+			h = rctx.priorityHandler
+		}
+
+		// Set path values for Go 1.22+
+		if supportsPathValue {
+			setPathValue(rctx, r)
+		}
+
+		// Start measuring request duration
+		start := time.Now()
+
+		// Serve the request with the found handler
 		h.ServeHTTP(w, r)
+
+		// Record metrics if collector is configured
+		if mx.metricsCollector != nil {
+			mx.metricsCollector.RecordHit(rctx, r, time.Since(start))
+		}
 		return
 	}
 	if rctx.methodNotAllowed {
@@ -504,3 +569,8 @@ func methodNotAllowedHandler(methodsAllowed ...methodTyp) func(w http.ResponseWr
 		w.Write(nil)
 	}
 }
+
+// SetMetricsCollector sets the metrics collector for the router
+func (mx *Mux) SetMetricsCollector(collector MetricsCollector) {
+	mx.metricsCollector = collector
+}
diff --git a/path_value.go b/path_value.go
new file mode 100644
index 0000000..1675e53
--- /dev/null
+++ b/path_value.go
@@ -0,0 +1,21 @@
+//go:build go1.22
+// +build go1.22
+
+package chi
+
+import "net/http"
+
+// supportsPathValue is true if the Go version is 1.22 and above.
+//
+// If this is true, `net/http.Request` has methods `SetPathValue` and `PathValue`.
+const supportsPathValue = true
+
+// setPathValue sets the path values in the Request value
+// based on the provided request context.
+func setPathValue(rctx *Context, r *http.Request) {
+	for i, key := range rctx.URLParams.Keys {
+		value := rctx.URLParams.Values[i]
+		r.SetPathValue(key, value)
+	}
+}
+
diff --git a/path_value_fallback.go b/path_value_fallback.go
new file mode 100644
index 0000000..5317dc3
--- /dev/null
+++ b/path_value_fallback.go
@@ -0,0 +1,20 @@
+//go:build !go1.22
+// +build !go1.22
+
+package chi
+
+import "net/http"
+
+// supportsPathValue is true if the Go version is 1.22 and above.
+//
+// If this is true, `net/http.Request` has methods `SetPathValue` and `PathValue`.
+const supportsPathValue = false
+
+// setPathValue sets the path values in the Request value
+// based on the provided request context.
+//
+// setPathValue is only supported in Go 1.22 and above so
+// this is just a blank function so that it compiles.
+func setPathValue(rctx *Context, r *http.Request) {
+}
+
diff --git a/priority.go b/priority.go
new file mode 100644
index 0000000..a0e3068
--- /dev/null
+++ b/priority.go
@@ -0,0 +1,37 @@
+package chi
+
+import (
+	"net/http"
+)
+
+// Route priorities
+const (
+	// PriorityHighest is the highest possible priority for a route
+	PriorityHighest = 100
+
+	// PriorityHigh is a high priority route
+	PriorityHigh = 75
+
+	// PriorityNormal is the default priority
+	PriorityNormal = 50
+
+	// PriorityLow is a low priority route
+	PriorityLow = 25
+
+	// PriorityLowest is the lowest possible priority
+	PriorityLowest = 0
+)
+
+// evalPriorityHandler evaluates if a handler should take precedence based on priority
+func evalPriorityHandler(ctx *Context, pattern string, handler http.Handler, priority int) bool {
+	// If no priority handler is set, or if this handler has higher priority
+	if ctx.priorityHandler == nil || priority > ctx.routePriority {
+		ctx.priorityHandler = handler
+		ctx.routePriority = priority
+		ctx.routePattern = pattern
+		return true
+	}
+
+	return false
+}
+
diff --git a/tree.go b/tree.go
index c7d3bc5..d2bcc02 100644
--- a/tree.go
+++ b/tree.go
@@ -123,6 +123,9 @@ type endpoint struct {
 
 	// parameter keys recorded on handler nodes
 	paramKeys []string
+
+	// priority for this endpoint
+	priority int
 }
 
 func (s endpoints) Value(method methodTyp) *endpoint {
@@ -391,6 +394,11 @@ func (n *node) FindRoute(rctx *Context, method methodTyp, path string) (*node, e
 		rctx.RoutePatterns = append(rctx.RoutePatterns, rctx.routePattern)
 	}
 
+	// During the FindRoute process, check and store priority handlers in rctx
+	if rn.endpoints[method].priority > 0 {
+		evalPriorityHandler(rctx, rn.endpoints[method].pattern, rn.endpoints[method].handler, rn.endpoints[method].priority)
+	}
+
 	return rn, rn.endpoints, rn.endpoints[method].handler
 }
 
