diff --git a/outlines/backends/xgrammar.py b/outlines/backends/xgrammar.py
index fcb1672d..1a598835 100644
--- a/outlines/backends/xgrammar.py
+++ b/outlines/backends/xgrammar.py
@@ -1,6 +1,9 @@
 """Backend class for XGrammar."""

 from typing import TYPE_CHECKING
+import hashlib
+import threading
+

 from outlines.backends.base import BaseBackend
 from outlines.models import SteerableModel
@@ -53,12 +56,14 @@ class XGrammarLogitsProcessor(OutlinesLogitsProcessor):
 class XGrammarBackend(BaseBackend):
     """Backend for XGRammar."""

-    def __init__(self, model: SteerableModel):
+    def __init__(self, model: SteerableModel, cache_compiled_grammars: bool = False):
         """
         Parameters
         ----------
         model
             The Outlines model of the user.
+        cache_compiled_grammars
+            Enable in-memory caching of compiled grammars. Defaults to False.

         """
         import xgrammar as xgr
@@ -77,6 +82,33 @@ class XGrammarBackend(BaseBackend):
             vocab_size=vocab_size
         )
         self.grammar_compiler = xgr.GrammarCompiler(tokenizer_info)
+        # Caching infrastructure
+        self._cache_enabled = bool(cache_compiled_grammars)
+        self._grammar_cache = {}
+        self._cache_lock = threading.Lock() if self._cache_enabled else None
+
+
+    def _compile_with_cache(self, kind: str, source: str, compiler_func):
+        """Compile a grammar with optional caching.
+
+        kind: a short string to distinguish grammar types (e.g., 'json', 'regex', 'cfg')
+        source: the grammar string
+        compiler_func: callable that takes the source string and returns compiled grammar
+        """
+        if not self._cache_enabled:
+            return compiler_func(source)
+
+        key_material = f"{kind}\0{source}".encode("utf-8")
+        cache_key = hashlib.sha256(key_material).hexdigest()
+        # Simple locking strategy: serialize compiles and cache access
+        # This ensures thread safety and avoids duplicate compilations.
+        assert self._cache_lock is not None
+        with self._cache_lock:
+            if cache_key in self._grammar_cache:
+                return self._grammar_cache[cache_key]
+            compiled = compiler_func(source)
+            self._grammar_cache[cache_key] = compiled
+            return compiled

     def get_json_schema_logits_processor(
         self, json_schema: str
@@ -94,8 +126,8 @@ class XGrammarBackend(BaseBackend):
             The logits processor to use to constrain the generation.

         """
-        compiled_grammar = self.grammar_compiler.compile_json_schema(
-            json_schema
+        compiled_grammar = self._compile_with_cache(
+            "json", json_schema, self.grammar_compiler.compile_json_schema
         )
         return XGrammarLogitsProcessor(compiled_grammar)

@@ -113,7 +145,9 @@ class XGrammarBackend(BaseBackend):
             The logits processor to use to constrain the generation.

         """
-        compiled_grammar = self.grammar_compiler.compile_regex(regex)
+        compiled_grammar = self._compile_with_cache(
+            "regex", regex, self.grammar_compiler.compile_regex
+        )
         return XGrammarLogitsProcessor(compiled_grammar)

     def get_cfg_logits_processor(self, grammar: str) -> "LogitsProcessor":
@@ -130,5 +164,7 @@ class XGrammarBackend(BaseBackend):
             The logits processor to use to constrain the generation.

         """
-        compiled_grammar = self.grammar_compiler.compile_grammar(grammar)
+        compiled_grammar = self._compile_with_cache(
+            "cfg", grammar, self.grammar_compiler.compile_grammar
+        )
         return XGrammarLogitsProcessor(compiled_grammar)

