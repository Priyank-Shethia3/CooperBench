diff --git a/tests/backends/test_xgrammar.py b/tests/backends/test_xgrammar.py
index 1133b9f0..0b6e35bd 100644
--- a/tests/backends/test_xgrammar.py
+++ b/tests/backends/test_xgrammar.py
@@ -93,3 +93,135 @@ def test_xgrammar_backend_invalid_model(model_llamacpp):
         match="The xgrammar backend only supports Transformers models",
     ):
         XGrammarBackend(model_llamacpp)
+
+
+def test_validate_grammar_json_schema_success(model_transformers, json_schema):
+    """Test successful validation with custom validator for JSON schema."""
+    backend = XGrammarBackend(model_transformers)
+ 
+    def custom_validator(schema: str):
+        # Simple validation - check if it contains required fields
+        if "name" not in schema or "age" not in schema:
+            raise ValueError("Schema must contain name and age fields")
+ 
+    # Should not raise any exception
+    processor = backend.get_json_schema_logits_processor(json_schema, validate_grammar=custom_validator)
+    assert isinstance(processor, XGrammarLogitsProcessor)
+
+
+def test_validate_grammar_json_schema_failure(model_transformers):
+    """Test validation failure with custom validator for JSON schema."""
+    backend = XGrammarBackend(model_transformers)
+    invalid_schema = '{"type": "object", "properties": {"invalid": {"type": "string"}}}'
+ 
+    def strict_validator(schema: str):
+        if "name" not in schema:
+            raise ValueError("Schema must contain name field")
+ 
+    with pytest.raises(ValueError, match="Schema must contain name field"):
+        backend.get_json_schema_logits_processor(invalid_schema, validate_grammar=strict_validator)
+
+
+def test_validate_grammar_regex_success(model_transformers, regex):
+    """Test successful validation with custom validator for regex."""
+    backend = XGrammarBackend(model_transformers)
+ 
+    def regex_validator(pattern: str):
+        # Check if regex contains digits
+        if not any(char.isdigit() for char in pattern):
+            raise ValueError("Regex must contain digits")
+ 
+    # Should not raise any exception
+    processor = backend.get_regex_logits_processor(regex, validate_grammar=regex_validator)
+    assert isinstance(processor, XGrammarLogitsProcessor)
+
+
+def test_validate_grammar_regex_failure(model_transformers):
+    """Test validation failure with custom validator for regex."""
+    backend = XGrammarBackend(model_transformers)
+    invalid_regex = "[a-z]+"
+ 
+    def digit_validator(pattern: str):
+        if not any(char.isdigit() for char in pattern):
+            raise ValueError("Regex must contain digits")
+ 
+    with pytest.raises(ValueError, match="Regex must contain digits"):
+        backend.get_regex_logits_processor(invalid_regex, validate_grammar=digit_validator)
+
+
+def test_validate_grammar_cfg_success(model_transformers, cfg):
+    """Test successful validation with custom validator for CFG."""
+    backend = XGrammarBackend(model_transformers)
+ 
+    def cfg_validator(grammar: str):
+        # Check if grammar contains root rule
+        if "root ::" not in grammar:
+            raise ValueError("Grammar must contain root rule")
+ 
+    # Should not raise any exception
+    processor = backend.get_cfg_logits_processor(cfg, validate_grammar=cfg_validator)
+    assert isinstance(processor, XGrammarLogitsProcessor)
+
+
+def test_validate_grammar_cfg_failure(model_transformers):
+    """Test validation failure with custom validator for CFG."""
+    backend = XGrammarBackend(model_transformers)
+    invalid_cfg = 'answer ::= "yes" | "no"'
+ 
+    def root_validator(grammar: str):
+        if "root ::" not in grammar:
+            raise ValueError("Grammar must contain root rule")
+ 
+    with pytest.raises(ValueError, match="Grammar must contain root rule"):
+        backend.get_cfg_logits_processor(invalid_cfg, validate_grammar=root_validator)
+
+
+def test_validate_grammar_none_parameter(model_transformers, json_schema, regex, cfg):
+    """Test that None validate_grammar parameter works (backward compatibility)."""
+    backend = XGrammarBackend(model_transformers)
+ 
+    # All should work without validation
+    json_processor = backend.get_json_schema_logits_processor(json_schema, validate_grammar=None)
+    regex_processor = backend.get_regex_logits_processor(regex, validate_grammar=None)
+    cfg_processor = backend.get_cfg_logits_processor(cfg, validate_grammar=None)
+ 
+    assert isinstance(json_processor, XGrammarLogitsProcessor)
+    assert isinstance(regex_processor, XGrammarLogitsProcessor)
+    assert isinstance(cfg_processor, XGrammarLogitsProcessor)
+
+
+def test_validate_grammar_edge_cases(model_transformers):
+    """Test edge cases for validation."""
+    backend = XGrammarBackend(model_transformers)
+ 
+    # Empty string validation
+    def empty_validator(content: str):
+        if not content.strip():
+            raise ValueError("Content cannot be empty")
+ 
+    with pytest.raises(ValueError, match="Content cannot be empty"):
+        backend.get_json_schema_logits_processor("", validate_grammar=empty_validator)
+ 
+    # Large input validation
+    large_schema = '{"type": "object", "properties": {' + ', '.join([f'"field{i}": {{"type": "string"}}' for i in range(100)]) + '}}'
+ 
+    def size_validator(content: str):
+        if len(content) > 1000:
+            raise ValueError("Content too large")
+ 
+    with pytest.raises(ValueError, match="Content too large"):
+        backend.get_json_schema_logits_processor(large_schema, validate_grammar=size_validator)
+
+
+def test_validate_grammar_custom_exceptions(model_transformers, json_schema):
+    """Test custom exception types from validators."""
+    backend = XGrammarBackend(model_transformers)
+ 
+    class CustomValidationError(Exception):
+        pass
+ 
+    def custom_exception_validator(content: str):
+        raise CustomValidationError("Custom validation failed")
+ 
+    with pytest.raises(CustomValidationError, match="Custom validation failed"):
+        backend.get_json_schema_logits_processor(json_schema, validate_grammar=custom_exception_validator)
