diff --git a/tests/backends/test_xgrammar.py b/tests/backends/test_xgrammar.py
index 1133b9f0..ba8e0940 100644
--- a/tests/backends/test_xgrammar.py
+++ b/tests/backends/test_xgrammar.py
@@ -93,3 +93,199 @@ def test_xgrammar_backend_invalid_model(model_llamacpp):
         match="The xgrammar backend only supports Transformers models",
     ):
         XGrammarBackend(model_llamacpp)
+
+
+def test_memory_tracking_initialization():
+    """Test memory tracking initialization and default values."""
+    compiled_grammar = "test_grammar"
+ 
+    # Test default behavior (no memory tracking)
+    processor = XGrammarLogitsProcessor(compiled_grammar)
+    assert processor.track_memory_usage is False
+    stats = processor.get_memory_stats()
+    assert stats["peak_memory_mb"] == 0.0
+    assert stats["total_calls"] == 0
+    assert stats["avg_memory_per_call_mb"] == 0.0
+    assert stats["memory_history"] == []
+ 
+    # Test with memory tracking enabled
+    processor_with_tracking = XGrammarLogitsProcessor(compiled_grammar, track_memory_usage=True)
+    assert processor_with_tracking.track_memory_usage is True
+    stats = processor_with_tracking.get_memory_stats()
+    assert stats["peak_memory_mb"] == 0.0
+    assert stats["total_calls"] == 0
+    assert stats["avg_memory_per_call_mb"] == 0.0
+    assert stats["memory_history"] == []
+
+
+def test_memory_tracking_backend_methods(model_transformers, json_schema, regex, cfg):
+    """Test that backend methods accept track_memory_usage parameter."""
+    backend = XGrammarBackend(model_transformers)
+ 
+    # Test JSON schema processor with memory tracking
+    processor = backend.get_json_schema_logits_processor(json_schema, track_memory_usage=True)
+    assert isinstance(processor, XGrammarLogitsProcessor)
+    assert processor.track_memory_usage is True
+ 
+    # Test regex processor with memory tracking
+    processor = backend.get_regex_logits_processor(regex, track_memory_usage=True)
+    assert isinstance(processor, XGrammarLogitsProcessor)
+    assert processor.track_memory_usage is True
+ 
+    # Test CFG processor with memory tracking
+    processor = backend.get_cfg_logits_processor(cfg, track_memory_usage=True)
+    assert isinstance(processor, XGrammarLogitsProcessor)
+    assert processor.track_memory_usage is True
+ 
+    # Test default behavior (no memory tracking)
+    processor = backend.get_json_schema_logits_processor(json_schema)
+    assert processor.track_memory_usage is False
+
+
+def test_memory_usage_tracking():
+    """Test memory usage tracking functionality through public API."""
+    import torch
+ 
+    compiled_grammar = "test_grammar"
+    processor = XGrammarLogitsProcessor(compiled_grammar, track_memory_usage=True)
+ 
+    # Create dummy input_ids and logits tensors
+    input_ids = torch.tensor([[1, 2, 3]])
+    logits = torch.randn(1, 4, 1000)  # batch_size=1, seq_len=4, vocab_size=1000
+ 
+    # Initial stats should be empty
+    stats = processor.get_memory_stats()
+    assert stats["total_calls"] == 0
+    assert stats["peak_memory_mb"] == 0.0
+    assert stats["avg_memory_per_call_mb"] == 0.0
+    assert stats["memory_history"] == []
+ 
+    # Process logits multiple times to generate memory stats
+    try:
+        processor.process_logits(input_ids, logits)
+        processor.process_logits(input_ids, logits)
+        processor.process_logits(input_ids, logits)
+ 
+        # Check that stats are updated after processing
+        stats = processor.get_memory_stats()
+        assert stats["total_calls"] >= 1  # Should have recorded at least some calls
+        assert isinstance(stats["peak_memory_mb"], float)
+        assert isinstance(stats["avg_memory_per_call_mb"], float)
+        assert isinstance(stats["memory_history"], list)
+        assert len(stats["memory_history"]) == stats["total_calls"]
+ 
+        # Peak should be >= average (basic sanity check)
+        if stats["total_calls"] > 0:
+            assert stats["peak_memory_mb"] >= stats["avg_memory_per_call_mb"]
+ 
+    except Exception:
+        # If xgrammar processing fails (e.g., due to invalid grammar), 
+        # we still want to verify the memory tracking API works
+        stats = processor.get_memory_stats()
+        assert isinstance(stats, dict)
+        assert "total_calls" in stats
+        assert "peak_memory_mb" in stats
+        assert "avg_memory_per_call_mb" in stats
+        assert "memory_history" in stats
+
+
+def test_get_memory_stats():
+    """Test get_memory_stats method returns a copy."""
+    compiled_grammar = "test_grammar"
+    processor = XGrammarLogitsProcessor(compiled_grammar, track_memory_usage=True)
+ 
+    # Get initial stats
+    stats = processor.get_memory_stats()
+ 
+    # Verify it's a copy (modifying returned dict shouldn't affect original)
+    original_calls = stats["total_calls"]
+    stats["total_calls"] = 999
+ 
+    # Get stats again to verify original wasn't modified
+    new_stats = processor.get_memory_stats()
+    assert new_stats["total_calls"] == original_calls
+
+
+def test_reset_with_memory_tracking():
+    """Test reset method behavior with memory tracking."""
+    import torch
+ 
+    compiled_grammar = "test_grammar"
+    processor = XGrammarLogitsProcessor(compiled_grammar, track_memory_usage=True)
+ 
+    # Create dummy tensors for processing
+    input_ids = torch.tensor([[1, 2, 3]])
+    logits = torch.randn(1, 4, 1000)
+ 
+    # Try to process some logits to potentially generate stats
+    try:
+        processor.process_logits(input_ids, logits)
+    except Exception:
+        # If processing fails, that's okay for this test
+        pass
+ 
+    # Reset processor
+    processor.reset()
+ 
+    # Verify stats are reset after reset
+    stats = processor.get_memory_stats()
+    assert stats["total_calls"] == 0
+    assert stats["peak_memory_mb"] == 0.0
+    assert stats["avg_memory_per_call_mb"] == 0.0
+    assert stats["memory_history"] == []
+    assert processor.xgrammar_logits_processor is None
+
+
+def test_reset_without_memory_tracking():
+    """Test reset method behavior without memory tracking."""
+    compiled_grammar = "test_grammar"
+    processor = XGrammarLogitsProcessor(compiled_grammar, track_memory_usage=False)
+ 
+    # Set some dummy processor
+    processor.xgrammar_logits_processor = "dummy"
+ 
+    # Reset processor
+    processor.reset()
+ 
+    # Verify processor is reset but stats remain unchanged
+    assert processor.xgrammar_logits_processor is None
+    stats = processor.get_memory_stats()
+    assert stats["total_calls"] == 0  # Should remain at initial value
+
+
+def test_memory_tracking_exception_handling():
+    """Test memory tracking handles exceptions gracefully."""
+    compiled_grammar = "test_grammar"
+    processor = XGrammarLogitsProcessor(compiled_grammar, track_memory_usage=True)
+ 
+    # Even if memory tracking encounters issues internally, 
+    # the public API should still work and return valid data
+    stats = processor.get_memory_stats()
+    assert isinstance(stats, dict)
+    assert "total_calls" in stats
+    assert "peak_memory_mb" in stats
+    assert "avg_memory_per_call_mb" in stats
+    assert "memory_history" in stats
+ 
+    # All values should be valid numbers/lists
+    assert isinstance(stats["total_calls"], int)
+    assert isinstance(stats["peak_memory_mb"], (int, float))
+    assert isinstance(stats["avg_memory_per_call_mb"], (int, float))
+    assert isinstance(stats["memory_history"], list)
+
+
+def test_memory_tracking_parameter_validation():
+    """Test parameter validation for track_memory_usage."""
+    compiled_grammar = "test_grammar"
+ 
+    # Test with boolean True
+    processor = XGrammarLogitsProcessor(compiled_grammar, track_memory_usage=True)
+    assert processor.track_memory_usage is True
+ 
+    # Test with boolean False
+    processor = XGrammarLogitsProcessor(compiled_grammar, track_memory_usage=False)
+    assert processor.track_memory_usage is False
+ 
+    # Test default value
+    processor = XGrammarLogitsProcessor(compiled_grammar)
+    assert processor.track_memory_usage is False
