diff --git a/outlines/prompts.py b/outlines/prompts.py
index 86519ada..d7ef3ffa 100644
--- a/outlines/prompts.py
+++ b/outlines/prompts.py
@@ -6,12 +6,87 @@ import re
 import textwrap
 from dataclasses import dataclass
 from pathlib import Path
-from typing import Any, Callable, Dict, Optional, Type, cast
+from typing import Any, Callable, Dict, Optional, Type, cast, List
 
 import jinja2
 import pydantic
 
 
+# Global filter registry (Feature 2)
+_global_filters: Dict[str, Callable] = {}
+
+
+def register_filter(name: str, func: Callable) -> None:
+    """Register a custom filter globally for use in all prompt templates.
+
+    Parameters
+    ----------
+    name : str
+        The name of the filter to register.
+    func : Callable
+        The function to use as the filter.
+    """
+    _global_filters[name] = func
+
+
+def unregister_filter(name: str) -> None:
+    """Remove a custom filter from the global registry.
+
+    Parameters
+    ----------
+    name : str
+        The name of the filter to remove.
+    """
+    _global_filters.pop(name, None)
+
+
+# Builtin filter implementations (Feature 4)
+def _get_builtin_filters() -> dict[str, dict[str, Callable]]:
+    """Get all available builtin filter categories."""
+    return {
+        "string_utils": {
+            "upper": lambda x: str(x).upper(),
+            "lower": lambda x: str(x).lower(),
+            "title": lambda x: str(x).title(),
+        },
+        "math_utils": {
+            "add": lambda x, y: x + y,
+            "multiply": lambda x, y: x * y,
+        },
+        "format_utils": {
+            "json": lambda x: json.dumps(x),
+            "yaml": _yaml_filter,
+        },
+    }
+
+
+def _yaml_filter(data: Any) -> str:
+    """Convert data to YAML format."""
+    def _to_yaml_string(obj, indent=0):
+        if isinstance(obj, dict):
+            lines = []
+            for key, value in obj.items():
+                if isinstance(value, (dict, list)):
+                    lines.append("  " * indent + f"{key}:")
+                    lines.append(_to_yaml_string(value, indent + 1))
+                else:
+                    lines.append("  " * indent + f"{key}: {value}")
+            return "\n".join(lines)
+        elif isinstance(obj, list):
+            lines = []
+            for item in obj:
+                if isinstance(item, (dict, list)):
+                    lines.append("  " * indent + "-")
+                    lines.append(_to_yaml_string(item, indent + 1))
+                else:
+                    lines.append("  " * indent + f"- {item}")
+            return "\n".join(lines)
+        else:
+            return str(obj)
+
+    return _to_yaml_string(data)
+
+
 @dataclass
 class Prompt:
     """Represents a prompt function.
@@ -23,6 +98,8 @@ class Prompt:
 
     template: jinja2.Template
     signature: Optional[inspect.Signature]
+    conditional_filters: Optional[Dict[str, Dict[str, Callable]]] = None
+    _template_content: Optional[str] = None
 
     def __call__(self, *args, **kwargs) -> str:
         """Render and return the template.
@@ -32,15 +109,85 @@ class Prompt:
         The rendered template as a Python ``str``.
 
         """
+        # Apply conditional filters if specified
+        template = self._get_template_with_conditional_filters()
+
         if self.signature is not None:
             bound_arguments = self.signature.bind(*args, **kwargs)
             bound_arguments.apply_defaults()
-            return self.template.render(**bound_arguments.arguments)
+            return template.render(**bound_arguments.arguments)
         else:
-            return self.template.render(**kwargs)
+            return template.render(**kwargs)
+
+    def _get_template_with_conditional_filters(self) -> jinja2.Template:
+        """Get template with conditional filters applied based on runtime conditions."""
+        if self.conditional_filters is None:
+            return self.template
+
+        # Evaluate conditions and select appropriate filter set
+        active_condition = self._evaluate_conditions()
+        if active_condition and active_condition in self.conditional_filters:
+            # Create a new environment with the conditional filters applied
+            env = jinja2.Environment(
+                trim_blocks=True,
+                lstrip_blocks=True,
+                keep_trailing_newline=True,
+                undefined=jinja2.StrictUndefined,
+            )
+            # Copy existing filters
+            env.filters.update(self.template.environment.filters)
+            # Add conditional filters
+            filters = self.conditional_filters[active_condition]
+            env.filters.update(filters)
+            # Use stored template content or fallback to recreating from template
+            if self._template_content:
+                return env.from_string(self._template_content)
+            else:
+                # Fallback: try to get template source from the template name/filename
+                try:
+                    return env.from_string(self.template.source)
+                except AttributeError:
+                    # If no source available, return original template
+                    return self.template
+
+        return self.template
+
+    def _evaluate_conditions(self) -> Optional[str]:
+        """Evaluate runtime conditions to determine which filter set to use."""
+        if self.conditional_filters is None:
+            return None
+
+        # Check environment variables for condition indicators
+        # Priority order: debug, testing, production, development
+        condition_priorities = ["debug", "testing", "production", "development"]
+
+        for condition in condition_priorities:
+            if condition in self.conditional_filters:
+                # Check various environment variable patterns
+                env_patterns = [
+                    f"OUTLINES_{condition.upper()}",
+                    f"{condition.upper()}_MODE",
+                    "ENVIRONMENT",
+                    "ENV",
+                    "MODE"
+                ]
+
+                for pattern in env_patterns:
+                    env_value = os.environ.get(pattern, "").lower()
+                    if condition in env_value or env_value == condition:
+                        return condition
+
+        # Default to first available condition if no environment match
+        return next(iter(self.conditional_filters.keys())) if self.conditional_filters else None
 
     @classmethod
-    def from_str(cls, content: str):
+    def from_str(
+        cls,
+        content: str,
+        filters: Dict[str, Callable] = {},
+        conditional_filters: Optional[Dict[str, Dict[str, Callable]]] = None,
+        builtin_filters: Optional[List[str]] = None,
+    ):
         """
         Create an instance of the class from a string.
 
@@ -48,15 +195,29 @@ class Prompt:
         ----------
         content : str
             The string content to be converted into a template.
+        filters : Dict[str, Callable]
+            Custom Jinja2 filters to register with the template environment.
+        conditional_filters : Optional[Dict[str, Dict[str, Callable]]], optional
+            A dictionary mapping condition names to filter sets for conditional filter loading.
+        builtin_filters : Optional[List[str]]
+            List of builtin filter categories to include.
+            Available categories: "string_utils", "math_utils", "format_utils"
 
         Returns
         -------
         An instance of the class with the provided content as a template.
         """
-        return cls(cls._template_from_str(content), None)
+        template = cls._template_from_str(content, filters, conditional_filters, builtin_filters)
+        return cls(template, None, conditional_filters, content)
 
     @classmethod
-    def from_file(cls, path: Path):
+    def from_file(
+        cls,
+        path: Path,
+        filters: Dict[str, Callable] = {},
+        conditional_filters: Optional[Dict[str, Dict[str, Callable]]] = None,
+        builtin_filters: Optional[List[str]] = None,
+    ):
         """
         Create a Prompt instance from a file containing a Jinja template.
 
@@ -67,6 +228,13 @@ class Prompt:
         ----------
         path : Path
             The path to the file containing the Jinja template.
+        filters : Dict[str, Callable]
+            Custom Jinja2 filters to register with the template environment.
+        conditional_filters : Optional[Dict[str, Dict[str, Callable]]], optional
+            A dictionary mapping condition names to filter sets for conditional filter loading.
+        builtin_filters : Optional[List[str]]
+            List of builtin filter categories to include.
+            Available categories: "string_utils", "math_utils", "format_utils"
 
         Returns
         -------
@@ -75,10 +243,17 @@ class Prompt:
         """
         # We don't use a `Signature` here because it seems not feasible to infer one from a Jinja2 environment that is
         # split across multiple files (since e.g. we support features like Jinja2 includes and template inheritance)
-        return cls(cls._template_from_file(path), None)
+        template = cls._template_from_file(path, filters, conditional_filters, builtin_filters)
+        return cls(template, None, conditional_filters, str(path))
 
     @classmethod
-    def _template_from_str(_, content: str) -> jinja2.Template:
+    def _template_from_str(
+        cls,
+        content: str,
+        filters: Dict[str, Callable] = {},
+        conditional_filters: Optional[Dict[str, Dict[str, Callable]]] = None,
+        builtin_filters: Optional[List[str]] = None,
+    ) -> jinja2.Template:
         # Dedent, and remove extra linebreak
         cleaned_template = inspect.cleandoc(content)
 
@@ -93,12 +268,12 @@ class Prompt:
         # used to continue to the next line without linebreak.
         cleaned_template = re.sub(r"(?![\r\n])(\b\s+)", " ", cleaned_template)
 
-        env = jinja2.Environment(
-            trim_blocks=True,
-            lstrip_blocks=True,
-            keep_trailing_newline=True,
-            undefined=jinja2.StrictUndefined,
-        )
+        env = create_jinja_env(None, filters, builtin_filters)
+
+        # Add global filters first (Feature 2)
+        env.filters.update(_global_filters)
+
+        # Core filters always present
         env.filters["name"] = get_fn_name
         env.filters["description"] = get_fn_description
         env.filters["source"] = get_fn_source
@@ -106,22 +281,54 @@ class Prompt:
         env.filters["schema"] = get_schema
         env.filters["args"] = get_fn_args
 
+        # Add placeholder filters for conditional filters to avoid template compilation errors
+        if conditional_filters:
+            for condition_filters in conditional_filters.values():
+                for filter_name in condition_filters.keys():
+                    if filter_name not in env.filters:
+                        # Add a placeholder filter that will be replaced at runtime
+                        env.filters[filter_name] = lambda x: x
+
         return env.from_string(cleaned_template)
 
     @classmethod
-    def _template_from_file(_, path: Path) -> jinja2.Template:
+    def _template_from_file(
+        cls,
+        path: Path,
+        filters: Dict[str, Callable] = {},
+        conditional_filters: Optional[Dict[str, Dict[str, Callable]]] = None,
+        builtin_filters: Optional[List[str]] = None,
+    ) -> jinja2.Template:
         file_directory = os.path.dirname(os.path.abspath(path))
-        env = jinja2.Environment(
-            loader=jinja2.FileSystemLoader(file_directory),
-            trim_blocks=True,
-            lstrip_blocks=True,
-            keep_trailing_newline=True,
-            undefined=jinja2.StrictUndefined,
-        )
+        env = create_jinja_env(jinja2.FileSystemLoader(file_directory), filters, builtin_filters)
+
+        # Add global filters first (Feature 2)
+        env.filters.update(_global_filters)
+
+        # Core filters always present
+        env.filters["name"] = get_fn_name
+        env.filters["description"] = get_fn_description
+        env.filters["source"] = get_fn_source
+        env.filters["signature"] = get_fn_signature
+        env.filters["schema"] = get_schema
+        env.filters["args"] = get_fn_args
+
+        # Add placeholder filters for conditional filters to avoid template compilation errors
+        if conditional_filters:
+            for condition_filters in conditional_filters.values():
+                for filter_name in condition_filters.keys():
+                    if filter_name not in env.filters:
+                        # Add a placeholder filter that will be replaced at runtime
+                        env.filters[filter_name] = lambda x: x
+
         return env.get_template(os.path.basename(path))
 
 
-def prompt(fn: Callable) -> Prompt:
+def prompt(
+    fn: Optional[Callable] = None,
+    filters: Dict[str, Callable] = {},
+    conditional_filters: Optional[Dict[str, Dict[str, Callable]]] = None,
+) -> Callable:
     """Decorate a function that contains a prompt template.
 
     This allows to define prompts in the docstring of a function and simplify their
@@ -152,23 +359,98 @@ def prompt(fn: Callable) -> Prompt:
     ...
     >>> hal = ft.partial(solve_task, "HAL", "Travel to Jupiter")
 
+    Additional Jinja2 filters can be provided as keyword arguments to the decorator.
+
+    >>> def reverse(s: str) -> str:
+    ...     return s[::-1]
+    ...
+    >>> @outlines.prompt(filters={ 'reverse': reverse })
+    ... def reverse_prompt(text):
+    ...     '''{{ text | reverse }}'''
+    ...
+    >>> prompt = reverse_prompt("Hello")
+    >>> print(prompt)
+    ... "olleH"
+
+    Parameters
+    ----------
+    fn : Callable, optional
+        The function containing the prompt template in its docstring.
+    filters : Dict[str, Callable]
+        Custom Jinja2 filters to register with the template environment.
+    conditional_filters : Optional[Dict[str, Dict[str, Callable]]], optional
+        A dictionary mapping condition names to filter sets for conditional filter loading.
+
     Returns
     -------
     A `Prompt` callable class which will render the template when called.
 
     """
+    def decorator(func: Callable) -> Prompt:
+        signature = inspect.signature(func)
 
-    signature = inspect.signature(fn)
+        # The docstring contains the template that will be rendered to be used
+        # as a prompt to the language model.
+        docstring = func.__doc__
+        if docstring is None:
+            raise TypeError("Could not find a template in the function's docstring.")
 
-    # The docstring contains the template that will be rendered to be used
-    # as a prompt to the language model.
-    docstring = fn.__doc__
-    if docstring is None:
-        raise TypeError("Could not find a template in the function's docstring.")
+        template = Prompt._template_from_str(cast(str, docstring), filters, conditional_filters)
+
+        return Prompt(template, signature, conditional_filters, cast(str, docstring))
+
+    if fn is None:
+        # Called with arguments: @prompt(filters=...) or @prompt(conditional_filters=...)
+        return decorator
+    else:
+        # Called without arguments: @prompt
+        return decorator(fn)
+
+
+def create_jinja_env(
+    loader: Optional[jinja2.BaseLoader],
+    filters: Dict[str, Callable],
+    builtin_filters: Optional[List[str]] = None,
+) -> jinja2.Environment:
+    """Create a Jinja2 environment with custom and builtin filters.
+
+    Parameters
+    ----------
+    loader : Optional[jinja2.BaseLoader]
+        The loader to use for the environment.
+    filters : Dict[str, Callable]
+        Custom Jinja2 filters to register with the template environment.
+    builtin_filters : Optional[List[str]]
+        List of builtin filter categories to include.
 
-    template = Prompt._template_from_str(cast(str, docstring))
+    Returns
+    -------
+    jinja2.Environment
+        The configured Jinja2 environment.
+    """
+    env = jinja2.Environment(
+        loader=loader,
+        trim_blocks=True,
+        lstrip_blocks=True,
+        keep_trailing_newline=True,
+        undefined=jinja2.StrictUndefined,
+    )
 
-    return Prompt(template, signature)
+    # Load optional built-in filter categories (Feature 4)
+    if builtin_filters is not None:
+        available_filters = _get_builtin_filters()
+        for category in builtin_filters:
+            if category == "":
+                raise ValueError("Filter category cannot be empty string")
+            if category not in available_filters:
+                raise ValueError(f"Unknown builtin filter category: {category}")
+            env.filters.update(available_filters[category])
+
+    # Add custom filters (Feature 1)
+    for name, filter_fn in filters.items():
+        env.filters[name] = filter_fn
+
+    return env
 
 
 def get_fn_name(fn: Callable):
