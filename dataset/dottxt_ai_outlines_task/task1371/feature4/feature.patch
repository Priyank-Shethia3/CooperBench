diff --git a/outlines/prompts.py b/outlines/prompts.py
index 86519ada..45f1448f 100644
--- a/outlines/prompts.py
+++ b/outlines/prompts.py
@@ -6,12 +6,59 @@ import re
 import textwrap
 from dataclasses import dataclass
 from pathlib import Path
-from typing import Any, Callable, Dict, Optional, Type, cast
+from typing import Any, Callable, Dict, Optional, Type, cast, List
 
 import jinja2
 import pydantic
 
 
+# Builtin filter implementations
+def _get_builtin_filters() -> dict[str, dict[str, Callable]]:
+    """Get all available builtin filter categories."""
+    return {
+        "string_utils": {
+            "upper": lambda x: str(x).upper(),
+            "lower": lambda x: str(x).lower(),
+            "title": lambda x: str(x).title(),
+        },
+        "math_utils": {
+            "add": lambda x, y: x + y,
+            "multiply": lambda x, y: x * y,
+        },
+        "format_utils": {
+            "json": lambda x: json.dumps(x),
+            "yaml": _yaml_filter,
+        },
+    }
+
+
+def _yaml_filter(data: Any) -> str:
+    """Convert data to YAML format."""
+    def _to_yaml_string(obj, indent=0):
+        if isinstance(obj, dict):
+            lines = []
+            for key, value in obj.items():
+                if isinstance(value, (dict, list)):
+                    lines.append("  " * indent + f"{key}:")
+                    lines.append(_to_yaml_string(value, indent + 1))
+                else:
+                    lines.append("  " * indent + f"{key}: {value}")
+            return "\n".join(lines)
+        elif isinstance(obj, list):
+            lines = []
+            for item in obj:
+                if isinstance(item, (dict, list)):
+                    lines.append("  " * indent + "-")
+                    lines.append(_to_yaml_string(item, indent + 1))
+                else:
+                    lines.append("  " * indent + f"- {item}")
+            return "\n".join(lines)
+        else:
+            return str(obj)
+ 
+    return _to_yaml_string(data)
+
+
 @dataclass
 class Prompt:
     """Represents a prompt function.
@@ -40,7 +87,7 @@ class Prompt:
             return self.template.render(**kwargs)
 
     @classmethod
-    def from_str(cls, content: str):
+    def from_str(cls, content: str, builtin_filters: Optional[List[str]] = None):
         """
         Create an instance of the class from a string.
 
@@ -48,15 +95,18 @@ class Prompt:
         ----------
         content : str
             The string content to be converted into a template.
+        builtin_filters : Optional[List[str]]
+            List of builtin filter categories to include.
+            Available categories: "string_utils", "math_utils", "format_utils"
 
         Returns
         -------
         An instance of the class with the provided content as a template.
         """
-        return cls(cls._template_from_str(content), None)
+        return cls(cls._template_from_str(content, builtin_filters=builtin_filters), None)
 
     @classmethod
-    def from_file(cls, path: Path):
+    def from_file(cls, path: Path, builtin_filters: Optional[List[str]] = None):
         """
         Create a Prompt instance from a file containing a Jinja template.
 
@@ -67,6 +117,9 @@ class Prompt:
         ----------
         path : Path
             The path to the file containing the Jinja template.
+        builtin_filters : Optional[List[str]]
+            List of builtin filter categories to include.
+            Available categories: "string_utils", "math_utils", "format_utils"
 
         Returns
         -------
@@ -75,10 +128,10 @@ class Prompt:
         """
         # We don't use a `Signature` here because it seems not feasible to infer one from a Jinja2 environment that is
         # split across multiple files (since e.g. we support features like Jinja2 includes and template inheritance)
-        return cls(cls._template_from_file(path), None)
+        return cls(cls._template_from_file(path, builtin_filters=builtin_filters), None)
 
     @classmethod
-    def _template_from_str(_, content: str) -> jinja2.Template:
+    def _template_from_str(cls, content: str, builtin_filters: Optional[List[str]] = None) -> jinja2.Template:
         # Dedent, and remove extra linebreak
         cleaned_template = inspect.cleandoc(content)
 
@@ -99,6 +152,7 @@ class Prompt:
             keep_trailing_newline=True,
             undefined=jinja2.StrictUndefined,
         )
+        # Core filters always present
         env.filters["name"] = get_fn_name
         env.filters["description"] = get_fn_description
         env.filters["source"] = get_fn_source
@@ -106,10 +160,20 @@ class Prompt:
         env.filters["schema"] = get_schema
         env.filters["args"] = get_fn_args
 
+        # Load optional built-in filter categories
+        if builtin_filters is not None:
+            available_filters = _get_builtin_filters()
+            for category in builtin_filters:
+                if category == "":
+                    raise ValueError("Filter category cannot be empty string")
+                if category not in available_filters:
+                    raise ValueError(f"Unknown builtin filter category: {category}")
+                env.filters.update(available_filters[category])
+
         return env.from_string(cleaned_template)
 
     @classmethod
-    def _template_from_file(_, path: Path) -> jinja2.Template:
+    def _template_from_file(cls, path: Path, builtin_filters: Optional[List[str]] = None) -> jinja2.Template:
         file_directory = os.path.dirname(os.path.abspath(path))
         env = jinja2.Environment(
             loader=jinja2.FileSystemLoader(file_directory),
@@ -118,6 +182,24 @@ class Prompt:
             keep_trailing_newline=True,
             undefined=jinja2.StrictUndefined,
         )
+        # Core filters always present
+        env.filters["name"] = get_fn_name
+        env.filters["description"] = get_fn_description
+        env.filters["source"] = get_fn_source
+        env.filters["signature"] = get_fn_signature
+        env.filters["schema"] = get_schema
+        env.filters["args"] = get_fn_args
+
+        # Load optional built-in filter categories
+        if builtin_filters is not None:
+            available_filters = _get_builtin_filters()
+            for category in builtin_filters:
+                if category == "":
+                    raise ValueError("Filter category cannot be empty string")
+                if category not in available_filters:
+                    raise ValueError(f"Unknown builtin filter category: {category}")
+                env.filters.update(available_filters[category])
+
         return env.get_template(os.path.basename(path))
 
 
