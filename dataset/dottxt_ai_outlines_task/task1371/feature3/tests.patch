diff --git a/tests/test_prompts.py b/tests/test_prompts.py
index 4cc4d8ff..6206b5bc 100644
--- a/tests/test_prompts.py
+++ b/tests/test_prompts.py
@@ -403,3 +403,285 @@ def test_template_from_str_with_extra_linebreaks():
     """
     template = Prompt._template_from_str(content)
     assert template.render(name="World") == "Hello, World!\n"
+
+
+def test_conditional_filters_basic():
+    """Test basic conditional filter functionality."""
+    def debug_filter(value):
+        return f"DEBUG: {value}"
+ 
+    def prod_filter(value):
+        return f"PROD: {value}"
+ 
+    conditional_filters = {
+        "debug": {"custom": debug_filter},
+        "production": {"custom": prod_filter}
+    }
+ 
+    # Test debug condition - create prompt instance after setting env var
+    os.environ["OUTLINES_DEBUG"] = "true"
+ 
+    @outlines.prompt(conditional_filters=conditional_filters)
+    def test_prompt_debug(name):
+        """Hello {{name|custom}}!"""
+ 
+    result = test_prompt_debug(name="World")
+    assert result == "Hello DEBUG: World!"
+ 
+    # Test production condition - create new prompt instance after changing env
+    os.environ.pop("OUTLINES_DEBUG", None)
+    os.environ["ENVIRONMENT"] = "production"
+ 
+    @outlines.prompt(conditional_filters=conditional_filters)
+    def test_prompt_prod(name):
+        """Hello {{name|custom}}!"""
+ 
+    result = test_prompt_prod(name="World")
+    assert result == "Hello PROD: World!"
+ 
+    # Clean up
+    os.environ.pop("ENVIRONMENT", None)
+
+
+def test_conditional_filters_environment_variables():
+    """Test different environment variable patterns for condition evaluation."""
+    def test_filter(value):
+        return f"TEST: {value}"
+ 
+    conditional_filters = {
+        "testing": {"custom": test_filter}
+    }
+ 
+    @outlines.prompt(conditional_filters=conditional_filters)
+    def test_prompt(value):
+        """{{value|custom}}"""
+ 
+    # Test OUTLINES_TESTING pattern
+    os.environ["OUTLINES_TESTING"] = "true"
+    result = test_prompt(value="data")
+    assert result == "TEST: data"
+    os.environ.pop("OUTLINES_TESTING", None)
+ 
+    # Test TESTING_MODE pattern
+    os.environ["TESTING_MODE"] = "on"
+    result = test_prompt(value="data")
+    assert result == "TEST: data"
+    os.environ.pop("TESTING_MODE", None)
+ 
+    # Test ENV pattern
+    os.environ["ENV"] = "testing"
+    result = test_prompt(value="data")
+    assert result == "TEST: data"
+    os.environ.pop("ENV", None)
+
+
+def test_conditional_filters_priority():
+    """Test condition priority order."""
+    def debug_filter(value):
+        return f"DEBUG: {value}"
+ 
+    def test_filter(value):
+        return f"TEST: {value}"
+ 
+    conditional_filters = {
+        "debug": {"custom": debug_filter},
+        "testing": {"custom": test_filter}
+    }
+ 
+    @outlines.prompt(conditional_filters=conditional_filters)
+    def test_prompt(value):
+        """{{value|custom}}"""
+ 
+    # Set both conditions, debug should have priority
+    os.environ["OUTLINES_DEBUG"] = "true"
+    os.environ["OUTLINES_TESTING"] = "true"
+    result = test_prompt(value="data")
+    assert result == "DEBUG: data"
+ 
+    # Clean up
+    os.environ.pop("OUTLINES_DEBUG", None)
+    os.environ.pop("OUTLINES_TESTING", None)
+
+
+def test_conditional_filters_no_match():
+    """Test behavior when no condition matches."""
+    def debug_filter(value):
+        return f"DEBUG: {value}"
+ 
+    conditional_filters = {
+        "debug": {"custom": debug_filter}
+    }
+ 
+    # Clear all relevant environment variables
+    for key in ["OUTLINES_DEBUG", "ENVIRONMENT", "ENV", "OUTLINES_TESTING", "TESTING_MODE"]:
+        os.environ.pop(key, None)
+ 
+    # Use public API - Prompt.from_str() method
+    # Should use first available condition alphabetically ("debug") when no env vars match
+    prompt_instance = Prompt.from_str(
+        "{{value|custom}}", 
+        conditional_filters=conditional_filters
+    )
+ 
+    result = prompt_instance(value="data")
+    assert result == "DEBUG: data"
+
+
+def test_conditional_filters_none():
+    """Test behavior when conditional_filters is None."""
+    @outlines.prompt
+    def test_prompt(name):
+        """Hello {{name}}!"""
+ 
+    # Should work normally without conditional filters
+    result = test_prompt(name="World")
+    assert result == "Hello World!"
+
+
+def test_conditional_filters_empty():
+    """Test behavior with empty conditional_filters dict."""
+    prompt_instance = outlines.prompts.Prompt(
+        outlines.prompts.Prompt._template_from_str("Hello {{name}}!"),
+        None,
+        {},
+        "Hello {{name}}!"
+    )
+ 
+    result = prompt_instance(name="World")
+    assert result == "Hello World!"
+
+
+def test_conditional_filters_invalid_condition():
+    """Test behavior with invalid condition name."""
+    def test_filter(value):
+        return f"TEST: {value}"
+ 
+    conditional_filters = {
+        "nonexistent": {"custom": test_filter}
+    }
+ 
+    prompt_instance = outlines.prompts.Prompt(
+        outlines.prompts.Prompt._template_from_str("{{value}}"),
+        None,
+        conditional_filters,
+        "{{value}}"
+    )
+ 
+    # Should use first available condition when no env match
+    os.environ["SOME_OTHER_VAR"] = "value"
+    result = prompt_instance(value="data")
+    # Should fall back to original template since no matching condition
+    assert result == "data"
+ 
+    os.environ.pop("SOME_OTHER_VAR", None)
+
+
+def test_conditional_filters_multiple_filters():
+    """Test multiple filters in a condition."""
+    def upper_filter(value):
+        return value.upper()
+ 
+    def prefix_filter(value):
+        return f"PREFIX_{value}"
+ 
+    conditional_filters = {
+        "debug": {
+            "upper": upper_filter,
+            "prefix": prefix_filter
+        }
+    }
+ 
+    @outlines.prompt(conditional_filters=conditional_filters)
+    def test_prompt(name):
+        """{{name|upper|prefix}}"""
+ 
+    os.environ["OUTLINES_DEBUG"] = "true"
+    result = test_prompt(name="world")
+    assert result == "PREFIX_WORLD"
+ 
+    os.environ.pop("OUTLINES_DEBUG", None)
+
+
+def test_conditional_filters_with_existing_filters():
+    """Test that conditional filters work alongside existing filters."""
+    def custom_filter(value):
+        if callable(value):
+            return f"CUSTOM: {value.__name__}"
+        return f"CUSTOM: {value}"
+ 
+    conditional_filters = {
+        "debug": {"custom": custom_filter}
+    }
+ 
+    @outlines.prompt(conditional_filters=conditional_filters)
+    def test_prompt(fn):
+        """{{fn|name}} - {{fn|custom}}"""
+ 
+    def sample_function():
+        pass
+ 
+    os.environ["OUTLINES_DEBUG"] = "true"
+    result = test_prompt(fn=sample_function)
+    assert result == "sample_function - CUSTOM: sample_function"
+ 
+    os.environ.pop("OUTLINES_DEBUG", None)
+
+
+def test_conditional_filters_edge_cases():
+    """Test edge cases for conditional filters."""
+    def test_filter(value):
+        return str(value).replace(" ", "_")
+ 
+    conditional_filters = {
+        "testing": {"replace_spaces": test_filter}
+    }
+ 
+    @outlines.prompt(conditional_filters=conditional_filters)
+    def test_prompt(text):
+        """{{text|replace_spaces}}"""
+ 
+    os.environ["ENV"] = "testing"
+ 
+    # Test with empty string
+    result = test_prompt(text="")
+    assert result == ""
+ 
+    # Test with None (should convert to string)
+    result = test_prompt(text=None)
+    assert result == "None"
+ 
+    # Test with spaces
+    result = test_prompt(text="hello world test")
+    assert result == "hello_world_test"
+ 
+    os.environ.pop("ENV", None)
+
+
+def test_conditional_filters_performance():
+    """Test that conditional filters don't significantly impact performance."""
+    import time
+ 
+    def simple_filter(value):
+        return f"FILTERED: {value}"
+ 
+    conditional_filters = {
+        "production": {"perf": simple_filter}
+    }
+ 
+    @outlines.prompt(conditional_filters=conditional_filters)
+    def test_prompt(data):
+        """{{data|perf}}"""
+ 
+    os.environ["ENVIRONMENT"] = "production"
+ 
+    # Measure time for multiple renders
+    start_time = time.time()
+    for i in range(100):
+        result = test_prompt(data=f"test_{i}")
+        assert result == f"FILTERED: test_{i}"
+    end_time = time.time()
+ 
+    # Should complete reasonably quickly (less than 1 second for 100 renders)
+    assert end_time - start_time < 1.0
+ 
+    os.environ.pop("ENVIRONMENT", None)
