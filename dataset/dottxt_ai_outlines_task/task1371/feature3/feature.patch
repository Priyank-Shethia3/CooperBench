diff --git a/outlines/prompts.py b/outlines/prompts.py
index 86519ada..2da4a863 100644
--- a/outlines/prompts.py
+++ b/outlines/prompts.py
@@ -23,6 +23,8 @@ class Prompt:
 
     template: jinja2.Template
     signature: Optional[inspect.Signature]
+    conditional_filters: Optional[Dict[str, Dict[str, Callable]]] = None
+    _template_content: Optional[str] = None
 
     def __call__(self, *args, **kwargs) -> str:
         """Render and return the template.
@@ -32,15 +34,79 @@ class Prompt:
         The rendered template as a Python ``str``.
 
         """
+        # Apply conditional filters if specified
+        template = self._get_template_with_conditional_filters()
+ 
         if self.signature is not None:
             bound_arguments = self.signature.bind(*args, **kwargs)
             bound_arguments.apply_defaults()
-            return self.template.render(**bound_arguments.arguments)
+            return template.render(**bound_arguments.arguments)
         else:
-            return self.template.render(**kwargs)
+            return template.render(**kwargs)
+
+    def _get_template_with_conditional_filters(self) -> jinja2.Template:
+        """Get template with conditional filters applied based on runtime conditions."""
+        if self.conditional_filters is None:
+            return self.template
+ 
+        # Evaluate conditions and select appropriate filter set
+        active_condition = self._evaluate_conditions()
+        if active_condition and active_condition in self.conditional_filters:
+            # Create a new environment with the conditional filters applied
+            env = jinja2.Environment(
+                trim_blocks=True,
+                lstrip_blocks=True,
+                keep_trailing_newline=True,
+                undefined=jinja2.StrictUndefined,
+            )
+            # Copy existing filters
+            env.filters.update(self.template.environment.filters)
+            # Add conditional filters
+            filters = self.conditional_filters[active_condition]
+            env.filters.update(filters)
+            # Use stored template content or fallback to recreating from template
+            if self._template_content:
+                return env.from_string(self._template_content)
+            else:
+                # Fallback: try to get template source from the template name/filename
+                try:
+                    return env.from_string(self.template.source)
+                except AttributeError:
+                    # If no source available, return original template
+                    return self.template
+ 
+        return self.template
+
+    def _evaluate_conditions(self) -> Optional[str]:
+        """Evaluate runtime conditions to determine which filter set to use."""
+        if self.conditional_filters is None:
+            return None
+ 
+        # Check environment variables for condition indicators
+        # Priority order: debug, testing, production, development
+        condition_priorities = ["debug", "testing", "production", "development"]
+ 
+        for condition in condition_priorities:
+            if condition in self.conditional_filters:
+                # Check various environment variable patterns
+                env_patterns = [
+                    f"OUTLINES_{condition.upper()}",
+                    f"{condition.upper()}_MODE",
+                    "ENVIRONMENT",
+                    "ENV",
+                    "MODE"
+                ]
+ 
+                for pattern in env_patterns:
+                    env_value = os.environ.get(pattern, "").lower()
+                    if condition in env_value or env_value == condition:
+                        return condition
+ 
+        # Default to first available condition if no environment match
+        return next(iter(self.conditional_filters.keys())) if self.conditional_filters else None
 
     @classmethod
-    def from_str(cls, content: str):
+    def from_str(cls, content: str, conditional_filters: Optional[Dict[str, Dict[str, Callable]]] = None):
         """
         Create an instance of the class from a string.
 
@@ -48,15 +114,18 @@ class Prompt:
         ----------
         content : str
             The string content to be converted into a template.
+        conditional_filters : Optional[Dict[str, Dict[str, Callable]]], optional
+            A dictionary mapping condition names to filter sets for conditional filter loading.
 
         Returns
         -------
         An instance of the class with the provided content as a template.
         """
-        return cls(cls._template_from_str(content), None)
+        template = cls._template_from_str(content, conditional_filters)
+        return cls(template, None, conditional_filters, content)
 
     @classmethod
-    def from_file(cls, path: Path):
+    def from_file(cls, path: Path, conditional_filters: Optional[Dict[str, Dict[str, Callable]]] = None):
         """
         Create a Prompt instance from a file containing a Jinja template.
 
@@ -67,6 +136,8 @@ class Prompt:
         ----------
         path : Path
             The path to the file containing the Jinja template.
+        conditional_filters : Optional[Dict[str, Dict[str, Callable]]], optional
+            A dictionary mapping condition names to filter sets for conditional filter loading.
 
         Returns
         -------
@@ -75,10 +146,11 @@ class Prompt:
         """
         # We don't use a `Signature` here because it seems not feasible to infer one from a Jinja2 environment that is
         # split across multiple files (since e.g. we support features like Jinja2 includes and template inheritance)
-        return cls(cls._template_from_file(path), None)
+        template = cls._template_from_file(path, conditional_filters)
+        return cls(template, None, conditional_filters, str(path))
 
     @classmethod
-    def _template_from_str(_, content: str) -> jinja2.Template:
+    def _template_from_str(_, content: str, conditional_filters: Optional[Dict[str, Dict[str, Callable]]] = None) -> jinja2.Template:
         # Dedent, and remove extra linebreak
         cleaned_template = inspect.cleandoc(content)
 
@@ -105,11 +177,19 @@ class Prompt:
         env.filters["signature"] = get_fn_signature
         env.filters["schema"] = get_schema
         env.filters["args"] = get_fn_args
+ 
+        # Add placeholder filters for conditional filters to avoid template compilation errors
+        if conditional_filters:
+            for condition_filters in conditional_filters.values():
+                for filter_name in condition_filters.keys():
+                    if filter_name not in env.filters:
+                        # Add a placeholder filter that will be replaced at runtime
+                        env.filters[filter_name] = lambda x: x
 
         return env.from_string(cleaned_template)
 
     @classmethod
-    def _template_from_file(_, path: Path) -> jinja2.Template:
+    def _template_from_file(_, path: Path, conditional_filters: Optional[Dict[str, Dict[str, Callable]]] = None) -> jinja2.Template:
         file_directory = os.path.dirname(os.path.abspath(path))
         env = jinja2.Environment(
             loader=jinja2.FileSystemLoader(file_directory),
@@ -118,10 +198,25 @@ class Prompt:
             keep_trailing_newline=True,
             undefined=jinja2.StrictUndefined,
         )
+        env.filters["name"] = get_fn_name
+        env.filters["description"] = get_fn_description
+        env.filters["source"] = get_fn_source
+        env.filters["signature"] = get_fn_signature
+        env.filters["schema"] = get_schema
+        env.filters["args"] = get_fn_args
+ 
+        # Add placeholder filters for conditional filters to avoid template compilation errors
+        if conditional_filters:
+            for condition_filters in conditional_filters.values():
+                for filter_name in condition_filters.keys():
+                    if filter_name not in env.filters:
+                        # Add a placeholder filter that will be replaced at runtime
+                        env.filters[filter_name] = lambda x: x
+ 
         return env.get_template(os.path.basename(path))
 
 
-def prompt(fn: Callable) -> Prompt:
+def prompt(fn: Callable = None, *, conditional_filters: Optional[Dict[str, Dict[str, Callable]]] = None):
     """Decorate a function that contains a prompt template.
 
     This allows to define prompts in the docstring of a function and simplify their
@@ -152,23 +247,37 @@ def prompt(fn: Callable) -> Prompt:
     ...
     >>> hal = ft.partial(solve_task, "HAL", "Travel to Jupiter")
 
+    Parameters
+    ----------
+    fn : Callable, optional
+        The function containing the prompt template in its docstring.
+    conditional_filters : Optional[Dict[str, Dict[str, Callable]]], optional
+        A dictionary mapping condition names to filter sets for conditional filter loading.
+
     Returns
     -------
     A `Prompt` callable class which will render the template when called.
 
     """
-
-    signature = inspect.signature(fn)
-
-    # The docstring contains the template that will be rendered to be used
-    # as a prompt to the language model.
-    docstring = fn.__doc__
-    if docstring is None:
-        raise TypeError("Could not find a template in the function's docstring.")
-
-    template = Prompt._template_from_str(cast(str, docstring))
-
-    return Prompt(template, signature)
+    def decorator(func: Callable) -> Prompt:
+        signature = inspect.signature(func)
+
+        # The docstring contains the template that will be rendered to be used
+        # as a prompt to the language model.
+        docstring = func.__doc__
+        if docstring is None:
+            raise TypeError("Could not find a template in the function's docstring.")
+
+        template = Prompt._template_from_str(cast(str, docstring), conditional_filters)
+
+        return Prompt(template, signature, conditional_filters, cast(str, docstring))
+ 
+    if fn is None:
+        # Called with arguments: @prompt(conditional_filters=...)
+        return decorator
+    else:
+        # Called without arguments: @prompt
+        return decorator(fn)
 
 
 def get_fn_name(fn: Callable):
