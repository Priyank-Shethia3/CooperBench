diff --git a/src/logic/createFormControl.ts b/src/logic/createFormControl.ts
index fb589b9a..f51256a2 100644
--- a/src/logic/createFormControl.ts
+++ b/src/logic/createFormControl.ts
@@ -129,6 +129,7 @@ export function createFormControl<
     action: false,
     mount: false,
     watch: false,
+    hasResolvedInitialDefaults: false,
   };
   let _names: Names = {
     mount: new Set(),
@@ -1325,7 +1326,7 @@ export function createFormControl<
         : 0,
       isDirty: isEmptyResetValues
         ? false
-        : keepStateOptions.keepDirty
+        : keepStateOptions.keepDirtyValues
           ? _formState.isDirty
           : !!(
               keepStateOptions.keepDefaultValues &&
@@ -1393,6 +1394,10 @@ export function createFormControl<
     isFunction(_options.defaultValues) &&
     _options.defaultValues().then((values: TFieldValues) => {
       reset(values, _options.resetOptions);
+      if (!_state.hasResolvedInitialDefaults) {
+        _options.onDefaultValuesResolved?.(values);
+        _state.hasResolvedInitialDefaults = true;
+      }
       _subjects.state.next({
         isLoading: false,
       });
diff --git a/src/types/form.ts b/src/types/form.ts
index c25c1387..45e4d756 100644
--- a/src/types/form.ts
+++ b/src/types/form.ts
@@ -124,6 +124,7 @@ export type UseFormProps<
   progressive: boolean;
   criteriaMode: CriteriaMode;
   delayError: number;
+  onDefaultValuesResolved?: (values: DefaultValues<TFieldValues>) => void;
 }>;
 
 export type FieldNamesMarkedBoolean<TFieldValues extends FieldValues> = DeepMap<
@@ -777,6 +778,7 @@ export type Control<
     mount: boolean;
     action: boolean;
     watch: boolean;
+    hasResolvedInitialDefaults: boolean;
   };
   _reset: UseFormReset<TFieldValues>;
   _options: UseFormProps<TFieldValues, TContext>;
diff --git a/src/useForm.ts b/src/useForm.ts
index 27cc6f29..5932bfa9 100644
--- a/src/useForm.ts
+++ b/src/useForm.ts
@@ -127,6 +127,17 @@ export function useForm<
     }
   }, [props.values, control]);
 
+  // Feature 3: Handle sync defaultValues callback on mount
+  React.useEffect(() => {
+    const syncDefaults = props.defaultValues;
+    // Check if defaultValues exist, are sync, and callback hasn't run
+    if (syncDefaults && !isFunction(syncDefaults) && !control._state.hasResolvedInitialDefaults) {
+       props.onDefaultValuesResolved?.(syncDefaults);
+       control._state.hasResolvedInitialDefaults = true;
+    }
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+  }, []); // Run only once after initial mount
+
   React.useEffect(() => {
     if (props.errors) {
       control._setErrors(props.errors);

