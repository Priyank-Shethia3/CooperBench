diff --git a/src/__tests__/useForm.test.tsx b/src/__tests__/useForm.test.tsx
index ac26da8b..5b305ffc 100644
--- a/src/__tests__/useForm.test.tsx
+++ b/src/__tests__/useForm.test.tsx
@@ -2498,4 +2498,110 @@ describe('useForm', () => {
       ).toBeInTheDocument();
     });
   });
+
+  describe('onDefaultValuesResolved', () => {
+    type FormValues = {
+      test: string;
+    };
+
+    it('should call callback for sync defaultValues', () => {
+      const onResolved = jest.fn();
+      const defaultValues = { test: 'sync' };
+
+      renderHook(() =>
+        useForm<FormValues>({ defaultValues, onDefaultValuesResolved: onResolved }),
+      );
+
+      expect(onResolved).toHaveBeenCalledTimes(1);
+      expect(onResolved).toHaveBeenCalledWith(defaultValues);
+    });
+
+    it('should call callback for async defaultValues', async () => {
+      const onResolved = jest.fn();
+      const defaultValuesResult = { test: 'async' };
+
+      renderHook(() =>
+        useForm<FormValues>({
+          defaultValues: async () => {
+            await sleep(50);
+            return defaultValuesResult;
+          },
+          onDefaultValuesResolved: onResolved,
+        }),
+      );
+
+      expect(onResolved).not.toHaveBeenCalled();
+
+      await act(async () => {
+        jest.advanceTimersByTime(100);
+      });
+
+      await waitFor(() => expect(onResolved).toHaveBeenCalledTimes(1));
+      expect(onResolved).toHaveBeenCalledWith(defaultValuesResult);
+    });
+
+    it('should only call callback once', async () => {
+      const onResolved = jest.fn();
+      const defaultValuesResult = { test: 'async' };
+
+      const { rerender } = renderHook(() =>
+        useForm<FormValues>({
+          defaultValues: async () => {
+            await sleep(50);
+            return defaultValuesResult;
+          },
+          onDefaultValuesResolved: onResolved,
+        }),
+      );
+
+      expect(onResolved).not.toHaveBeenCalled();
+
+      await act(async () => {
+        jest.advanceTimersByTime(100);
+      });
+
+      await waitFor(() => expect(onResolved).toHaveBeenCalledTimes(1));
+
+      // Rerender or trigger effects that might cause internal reset logic
+      rerender();
+      await act(async () => {
+        jest.advanceTimersByTime(100);
+      });
+
+      expect(onResolved).toHaveBeenCalledTimes(1); // Should still be 1
+    });
+
+    it('should not call callback when props.values cause reset', () => {
+      const onResolved = jest.fn();
+      const initialValues = { test: 'initial' };
+      const updatedValues = { test: 'updated' };
+
+      const { rerender } = renderHook(
+        ({ values }) =>
+          useForm<FormValues>({
+            values,
+            onDefaultValuesResolved: onResolved,
+          }),
+        {
+          initialProps: { values: initialValues },
+        },
+      );
+
+      expect(onResolved).not.toHaveBeenCalled();
+
+      rerender({ values: updatedValues });
+
+      expect(onResolved).not.toHaveBeenCalled();
+    });
+
+     it('should not call callback if not provided', () => {
+      const defaultValues = { test: 'sync' };
+      // No error should be thrown
+      expect(() => {
+         renderHook(() =>
+           useForm<FormValues>({ defaultValues }),
+         );
+      }).not.toThrow();
+    });
+  });
 });
