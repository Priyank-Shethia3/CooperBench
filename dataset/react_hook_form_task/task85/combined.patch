diff --git a/src/logic/createFormControl.ts b/src/logic/createFormControl.ts
index fb589b9a..7d96ded8 100644
--- a/src/logic/createFormControl.ts
+++ b/src/logic/createFormControl.ts
@@ -129,6 +129,10 @@ export function createFormControl<
     action: false,
     mount: false,
     watch: false,
+    isLoadingValues: false,
+    isLoadingExternal: false,
+    hasResolvedInitialDefaults: false,
+    isDebouncingValues: false,
   };
   let _names: Names = {
     mount: new Set(),
@@ -1393,6 +1397,10 @@ export function createFormControl<
     isFunction(_options.defaultValues) &&
     _options.defaultValues().then((values: TFieldValues) => {
       reset(values, _options.resetOptions);
+      if (!_state.hasResolvedInitialDefaults) {
+        _options.onDefaultValuesResolved?.(values);
+        _state.hasResolvedInitialDefaults = true;
+      }
       _subjects.state.next({
         isLoading: false,
       });
diff --git a/src/types/form.ts b/src/types/form.ts
index c25c1387..5e174414 100644
--- a/src/types/form.ts
+++ b/src/types/form.ts
@@ -124,6 +124,10 @@ export type UseFormProps<
   progressive: boolean;
   criteriaMode: CriteriaMode;
   delayError: number;
+  isLoadingExternalValues?: boolean;
+  onDefaultValuesResolved?: (values: DefaultValues<TFieldValues>) => void;
+  debounceValuesMs?: number;
+  preventResetIfDirty?: boolean;
 }>;
 
 export type FieldNamesMarkedBoolean<TFieldValues extends FieldValues> = DeepMap<
@@ -777,6 +781,10 @@ export type Control<
     mount: boolean;
     action: boolean;
     watch: boolean;
+    isLoadingValues: boolean;
+    isLoadingExternal: boolean;
+    hasResolvedInitialDefaults: boolean;
+    isDebouncingValues: boolean;
   };
   _reset: UseFormReset<TFieldValues>;
   _options: UseFormProps<TFieldValues, TContext>;
diff --git a/src/useForm.ts b/src/useForm.ts
index 27cc6f29..8f1ef93c 100644
--- a/src/useForm.ts
+++ b/src/useForm.ts
@@ -54,10 +54,11 @@ export function useForm<
     UseFormReturn<TFieldValues, TContext, TTransformedValues> | undefined
   >();
   const _values = React.useRef<typeof props.values>();
+  const _debounceValuesTimeoutRef = React.useRef<ReturnType<typeof setTimeout> | null>(null);
   const [formState, updateFormState] = React.useState<FormState<TFieldValues>>({
     isDirty: false,
     isValidating: false,
-    isLoading: isFunction(props.defaultValues),
+    isLoading: isFunction(props.defaultValues) || !!props.isLoadingExternalValues,
     isSubmitted: false,
     isSubmitting: false,
     isSubmitSuccessful: false,
@@ -118,14 +119,74 @@ export function useForm<
   }, [control, formState.isDirty]);
 
   React.useEffect(() => {
-    if (props.values && !deepEqual(props.values, _values.current)) {
-      control._reset(props.values, control._options.resetOptions);
-      _values.current = props.values;
-      updateFormState((state) => ({ ...state }));
-    } else {
+    const isExternalLoading = !!props.isLoadingExternalValues;
+    const previousLoading = control._state.isLoadingExternal;
+    
+    if (previousLoading !== isExternalLoading) {
+      control._state.isLoadingExternal = isExternalLoading;
+      updateFormState((state) => ({ ...state, isLoading: isExternalLoading }));
+    }
+
+    const { values: currentValues, debounceValuesMs } = props;
+    const previousValues = _values.current;
+    const isDebounceEnabled = debounceValuesMs && debounceValuesMs > 0;
+
+    if (_debounceValuesTimeoutRef.current) {
+      clearTimeout(_debounceValuesTimeoutRef.current);
+      _debounceValuesTimeoutRef.current = null;
+      if (control._state.isDebouncingValues) {
+          control._state.isDebouncingValues = false;
+      }
+    }
+
+    if (currentValues && !deepEqual(currentValues, previousValues)) {
+      const shouldPreventReset = props.preventResetIfDirty && formState.isDirty;
+      
+      if (shouldPreventReset) {
+        // Update _values.current but don't reset the form
+        _values.current = currentValues;
+      } else if (isDebounceEnabled) {
+        control._state.isDebouncingValues = true;
+
+        _debounceValuesTimeoutRef.current = setTimeout(() => {
+          if (_formControl.current && _formControl.current.control._options.debounceValuesMs === debounceValuesMs) {
+              control._state.isDebouncingValues = false;
+              control._reset(currentValues, control._options.resetOptions);
+              _values.current = currentValues;
+              updateFormState((state) => ({ ...state, isLoading: false }));
+          }
+          _debounceValuesTimeoutRef.current = null;
+        }, debounceValuesMs);
+      } else {
+        if (!isExternalLoading) {
+          control._reset(currentValues, control._options.resetOptions);
+          _values.current = currentValues;
+          updateFormState((state) => ({ ...state, isLoading: false }));
+        }
+      }
+    } else if (!currentValues && !control._state.isLoadingValues) {
+      control._state.isLoadingValues = true;
       control._resetDefaultValues();
     }
-  }, [props.values, control]);
+
+    return () => {
+      if (_debounceValuesTimeoutRef.current) {
+        clearTimeout(_debounceValuesTimeoutRef.current);
+        _debounceValuesTimeoutRef.current = null;
+      }
+    };
+  }, [props.values, props.debounceValuesMs, props.preventResetIfDirty, formState.isDirty, control]);
+
+  // Feature 3: Handle sync defaultValues callback on mount
+  React.useEffect(() => {
+    const syncDefaults = props.defaultValues;
+    // Check if defaultValues exist, are sync, and callback hasn't run
+    if (syncDefaults && !isFunction(syncDefaults) && !control._state.hasResolvedInitialDefaults) {
+       props.onDefaultValuesResolved?.(syncDefaults);
+       control._state.hasResolvedInitialDefaults = true;
+    }
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+  }, []); // Run only once after initial mount
 
   React.useEffect(() => {
     if (props.errors) {
