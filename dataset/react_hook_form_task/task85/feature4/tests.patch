diff --git a/src/__tests__/useForm.test.tsx b/src/__tests__/useForm.test.tsx
index ac26da8b..61f9dd23 100644
--- a/src/__tests__/useForm.test.tsx
+++ b/src/__tests__/useForm.test.tsx
@@ -20,12 +20,38 @@ import {
   UseFormRegister,
   UseFormReturn,
   UseFormUnregister,
+  UseFormProps,
 } from '../types';
 import isFunction from '../utils/isFunction';
 import noop from '../utils/noop';
 import sleep from '../utils/sleep';
 import { Controller, useFieldArray, useForm } from '../';
 
+// Define helper component at the top level for Feature 4
+function DebounceApp ({ initialValues, updates, debounceMs }: {
+  initialValues: { test: string };
+  updates: { values: { test: string }; delay: number }[];
+  debounceMs: number;
+}) {
+  const [values, setValues] = useState<{ test: string }>(initialValues);
+  const { register, getValues } = useForm<{ test: string }>({ values, debounceValuesMs: debounceMs });
+
+  React.useEffect(() => {
+    let totalDelay = 0;
+    updates.forEach(({ values: newValues, delay }) => {
+      totalDelay += delay;
+      setTimeout(() => setValues(newValues), totalDelay);
+    });
+  }, [updates]);
+
+  return (
+    <form>
+      <input {...register('test')} />
+      <p>FormValue: {getValues('test')}</p>
+    </form>
+  );
+};
+
 jest.useFakeTimers();
 
 describe('useForm', () => {
@@ -2498,4 +2524,96 @@ describe('useForm', () => {
       ).toBeInTheDocument();
     });
   });
-});
+
+  // Feature 4 Tests
+  describe('debounceValuesMs', () => {
+    type FormValues = { test: string };
+    // DebounceApp is now defined above
+
+    it('should debounce value updates', async () => {
+      const debounceTime = 100;
+      render(
+        <DebounceApp
+          initialValues={{ test: 'initial' }}
+          updates={[
+            { values: { test: 'update1' }, delay: 10 },
+            { values: { test: 'update2' }, delay: 10 },
+            { values: { test: 'update3' }, delay: 10 }, // Last update before debounce timeout
+          ]}
+          debounceMs={debounceTime}
+        />,
+      );
+
+      expect((screen.getByRole('textbox') as HTMLInputElement).value).toBe('initial');
+
+      // Advance time just past the updates but before debounce timeout
+      await act(async () => {
+        jest.advanceTimersByTime(50);
+      });
+
+      expect((screen.getByRole('textbox') as HTMLInputElement).value).toBe('initial');
+
+      // Advance time past the debounce timeout for the last update
+      await act(async () => {
+        jest.advanceTimersByTime(100); // Total time >= 30 (updates) + 100 (debounce)
+      });
+
+      await waitFor(() => {
+        expect((screen.getByRole('textbox') as HTMLInputElement).value).toBe('update3');
+      });
+    });
+
+    it('should update immediately if debounceMs is 0 or undefined', async () => {
+       const { result, rerender } = renderHook(
+        (props: UseFormProps<FormValues>) => useForm<FormValues>(props),
+        {
+          initialProps: { values: { test: 'initial' } },
+        },
+      );
+
+      expect(result.current.getValues().test).toBe('initial');
+
+      // Rerender with debounce 0
+      rerender({ values: { test: 'updated' }, debounceValuesMs: 0 });
+      // No debounce, value should update synchronously with the reset logic
+      expect(result.current.getValues().test).toBe('updated');
+
+      // Rerender with debounce undefined
+      rerender({ values: { test: 'final' } });
+      expect(result.current.getValues().test).toBe('final');
+    });
+
+    it('clears previous timeout if value changes again within debounce period', async () => {
+       const debounceTime = 100;
+      render(
+        <DebounceApp
+          initialValues={{ test: 'initial' }}
+          updates={[
+            { values: { test: 'update1' }, delay: 10 }, // Fires at 10ms, schedules reset for 110ms
+            { values: { test: 'update2' }, delay: 50 }, // Fires at 60ms, clears previous, schedules reset for 160ms
+          ]}
+          debounceMs={debounceTime}
+        />,
+      );
+
+       expect((screen.getByRole('textbox') as HTMLInputElement).value).toBe('initial');
+
+       // Advance past first update's scheduled reset time (110ms)
+       await act(async () => {
+         jest.advanceTimersByTime(120);
+       });
+
+       // Should still be initial as timeout was cleared by second update
+       expect((screen.getByRole('textbox') as HTMLInputElement).value).toBe('initial');
+
+       // Advance past second update's scheduled reset time (160ms)
+        await act(async () => {
+         jest.advanceTimersByTime(50);
+       });
+
+       await waitFor(() => {
+         expect((screen.getByRole('textbox') as HTMLInputElement).value).toBe('update2');
+       });
+    });
+  }); // End of debounceValuesMs describe
+}); // End of useForm describe
