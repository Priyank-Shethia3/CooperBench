diff --git a/src/logic/createFormControl.ts b/src/logic/createFormControl.ts
index fb589b9a..209c43c4 100644
--- a/src/logic/createFormControl.ts
+++ b/src/logic/createFormControl.ts
@@ -129,6 +129,7 @@ export function createFormControl<
     action: false,
     mount: false,
     watch: false,
+    isDebouncingValues: false,
   };
   let _names: Names = {
     mount: new Set(),
@@ -1325,17 +1326,6 @@ export function createFormControl<
         : 0,
       isDirty: isEmptyResetValues
         ? false
-        : keepStateOptions.keepDirty
-          ? _formState.isDirty
-          : !!(
-              keepStateOptions.keepDefaultValues &&
-              !deepEqual(formValues, _defaultValues)
-            ),
-      isSubmitted: keepStateOptions.keepIsSubmitted
-        ? _formState.isSubmitted
-        : false,
-      dirtyFields: isEmptyResetValues
-        ? {}
         : keepStateOptions.keepDirtyValues
           ? keepStateOptions.keepDefaultValues && _formValues
             ? getDirtyFields(_defaultValues, _formValues)
diff --git a/src/types/form.ts b/src/types/form.ts
index c25c1387..6b765801 100644
--- a/src/types/form.ts
+++ b/src/types/form.ts
@@ -124,6 +124,7 @@ export type UseFormProps<
   progressive: boolean;
   criteriaMode: CriteriaMode;
   delayError: number;
+  debounceValuesMs?: number;
 }>;
 
 export type FieldNamesMarkedBoolean<TFieldValues extends FieldValues> = DeepMap<
@@ -777,6 +778,7 @@ export type Control<
     mount: boolean;
     action: boolean;
     watch: boolean;
+    isDebouncingValues: boolean;
   };
   _reset: UseFormReset<TFieldValues>;
   _options: UseFormProps<TFieldValues, TContext>;
diff --git a/src/useForm.ts b/src/useForm.ts
index 27cc6f29..488b8cba 100644
--- a/src/useForm.ts
+++ b/src/useForm.ts
@@ -54,6 +54,8 @@ export function useForm<
     UseFormReturn<TFieldValues, TContext, TTransformedValues> | undefined
   >();
   const _values = React.useRef<typeof props.values>();
+  const _debounceValuesTimeoutRef = React.useRef<ReturnType<typeof setTimeout> | null>(null);
+
   const [formState, updateFormState] = React.useState<FormState<TFieldValues>>({
     isDirty: false,
     isValidating: false,
@@ -118,14 +120,50 @@ export function useForm<
   }, [control, formState.isDirty]);
 
   React.useEffect(() => {
-    if (props.values && !deepEqual(props.values, _values.current)) {
-      control._reset(props.values, control._options.resetOptions);
-      _values.current = props.values;
-      updateFormState((state) => ({ ...state }));
-    } else {
+    const { values: currentValues, debounceValuesMs } = props;
+    const previousValues = _values.current;
+    const isDebounceEnabled = debounceValuesMs && debounceValuesMs > 0;
+
+    if (_debounceValuesTimeoutRef.current) {
+      clearTimeout(_debounceValuesTimeoutRef.current);
+      _debounceValuesTimeoutRef.current = null;
+      if (control._state.isDebouncingValues) {
+          control._state.isDebouncingValues = false;
+      }
+    }
+
+    if (currentValues && !deepEqual(currentValues, previousValues)) {
+      if (isDebounceEnabled) {
+        control._state.isDebouncingValues = true;
+
+        _debounceValuesTimeoutRef.current = setTimeout(() => {
+          if (_formControl.current && _formControl.current.control._options.debounceValuesMs === debounceValuesMs) {
+              control._state.isDebouncingValues = false;
+              control._reset(currentValues, control._options.resetOptions);
+              _values.current = currentValues;
+              updateFormState((state) => ({ ...state, isLoading: false }));
+          }
+          _debounceValuesTimeoutRef.current = null;
+        }, debounceValuesMs);
+      } else {
+        control._reset(currentValues, control._options.resetOptions);
+        _values.current = currentValues;
+        updateFormState((state) => ({ ...state }));
+      }
+    } else if (!currentValues && previousValues) {
+      control._resetDefaultValues();
+      _values.current = undefined;
+    } else if (!currentValues && !previousValues && !control._state.mount) {
       control._resetDefaultValues();
     }
-  }, [props.values, control]);
+
+    return () => {
+      if (_debounceValuesTimeoutRef.current) {
+        clearTimeout(_debounceValuesTimeoutRef.current);
+        _debounceValuesTimeoutRef.current = null;
+      }
+    };
+  }, [props.values, props.debounceValuesMs, control]);
 
   React.useEffect(() => {
     if (props.errors) {

