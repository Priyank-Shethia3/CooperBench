diff --git a/src/__tests__/useForm.test.tsx b/src/__tests__/useForm.test.tsx
index ac26da8b..bda305fd 100644
--- a/src/__tests__/useForm.test.tsx
+++ b/src/__tests__/useForm.test.tsx
@@ -20,6 +20,7 @@ import {
   UseFormRegister,
   UseFormReturn,
   UseFormUnregister,
+  UseFormProps,
 } from '../types';
 import isFunction from '../utils/isFunction';
 import noop from '../utils/noop';
@@ -2499,3 +2500,142 @@ describe('useForm', () => {
     });
   });
 });
+
+// Helper component for preventResetIfDirty tests
+const PreventResetApp = ({
+  preventResetIfDirty,
+  values,
+  defaultValues,
+}: UseFormProps<{ firstName: string }> & {
+  preventResetIfDirty?: boolean;
+}) => {
+  const { register, formState, reset, watch } = useForm<{ firstName: string }>(
+    {
+      values,
+      defaultValues,
+      preventResetIfDirty,
+      // Ensure dirty state is tracked for the tests
+      mode: 'onChange',
+    },
+  );
+  const watchedFirstName = watch('firstName'); // Watch the value for display
+
+  return (
+    <form>
+      <input {...register('firstName')} placeholder="firstName" />
+      {/* Display watched value */}
+      <p>Watched Value: {watchedFirstName}</p>
+      <p>Dirty: {formState.isDirty ? 'true' : 'false'}</p>
+      <button type="button" onClick={() => reset()}>Manual Reset</button>
+    </form>
+  );
+};
+
+describe('preventResetIfDirty', () => {
+  it('should prevent reset via props.values when dirty and prop is true', async () => {
+    const defaultValues = { firstName: 'default' };
+    const { rerender } = render(
+      <PreventResetApp
+        defaultValues={defaultValues}
+        preventResetIfDirty={true}
+        values={defaultValues}
+      />,
+    );
+
+    // Make the form dirty
+    fireEvent.input(screen.getByPlaceholderText('firstName'), {
+      target: { value: 'edited' },
+    });
+
+    await waitFor(() => {
+      expect(screen.getByPlaceholderText('firstName')).toHaveValue('edited');
+      expect(screen.getByText('Dirty: true')).toBeInTheDocument();
+      expect(screen.getByText('Watched Value: edited')).toBeInTheDocument(); // Verify watched value
+    });
+
+    // Trigger a props.values update
+    rerender(
+      <PreventResetApp
+        defaultValues={defaultValues}
+        preventResetIfDirty={true}
+        values={{ firstName: 'new external' }}
+      />,
+    );
+
+    // Value should NOT reset because form is dirty and prop is true
+    await waitFor(() => {
+      expect(screen.getByPlaceholderText('firstName')).toHaveValue('edited');
+      expect(screen.getByText('Dirty: true')).toBeInTheDocument();
+      expect(screen.getByText('Watched Value: edited')).toBeInTheDocument(); // Still the edited value
+    });
+  });
+
+  it('should allow reset via props.values when not dirty, even if prop is true', async () => {
+    const defaultValues = { firstName: 'default' };
+    const { rerender } = render(
+      <PreventResetApp
+        defaultValues={defaultValues}
+        preventResetIfDirty={true}
+        values={defaultValues}
+      />,
+    );
+
+    expect(screen.getByPlaceholderText('firstName')).toHaveValue('default');
+    expect(screen.getByText('Dirty: false')).toBeInTheDocument();
+    expect(screen.getByText('Watched Value: default')).toBeInTheDocument();
+
+    // Trigger a props.values update while form is NOT dirty
+    rerender(
+      <PreventResetApp
+        defaultValues={defaultValues}
+        preventResetIfDirty={true}
+        values={{ firstName: 'new external' }}
+      />,
+    );
+
+    // Value should reset because form is not dirty
+    await waitFor(() => {
+      expect(screen.getByPlaceholderText('firstName')).toHaveValue('new external');
+      expect(screen.getByText('Dirty: false')).toBeInTheDocument();
+      expect(screen.getByText('Watched Value: new external')).toBeInTheDocument();
+    });
+  });
+
+  it('should allow reset via props.values when prop is false, even if dirty', async () => {
+    const defaultValues = { firstName: 'default' };
+    const { rerender } = render(
+      <PreventResetApp
+        defaultValues={defaultValues}
+        preventResetIfDirty={false} // Prop is false
+        values={defaultValues}
+      />,
+    );
+
+    // Make the form dirty
+    fireEvent.input(screen.getByPlaceholderText('firstName'), {
+      target: { value: 'edited' },
+    });
+
+    await waitFor(() => {
+      expect(screen.getByPlaceholderText('firstName')).toHaveValue('edited');
+      expect(screen.getByText('Dirty: true')).toBeInTheDocument();
+      expect(screen.getByText('Watched Value: edited')).toBeInTheDocument();
+    });
+
+    // Trigger a props.values update
+    rerender(
+      <PreventResetApp
+        defaultValues={defaultValues}
+        preventResetIfDirty={false} // Prop is false
+        values={{ firstName: 'new external' }}
+      />,
+    );
+
+    // Value should reset because prop is false
+    await waitFor(() => {
+      expect(screen.getByPlaceholderText('firstName')).toHaveValue('new external');
+      expect(screen.getByText('Dirty: false')).toBeInTheDocument();
+      expect(screen.getByText('Watched Value: new external')).toBeInTheDocument();
+    });
+  });
+});
