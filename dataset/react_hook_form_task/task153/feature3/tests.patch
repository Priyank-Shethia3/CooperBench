diff --git a/src/__tests__/useForm/handleSubmit.test.tsx b/src/__tests__/useForm/handleSubmit.test.tsx
index a5d98cf0..76e796f7 100644
--- a/src/__tests__/useForm/handleSubmit.test.tsx
+++ b/src/__tests__/useForm/handleSubmit.test.tsx
@@ -388,6 +388,100 @@ describe('handleSubmit', () => {
     });
   });
 
+  describe('with validation hooks', () => {
+    it('should call onBeforeValidate before validation and onAfterValidate after validation (valid case)', async () => {
+      const { result } = renderHook(() => useForm<{ test: string }>());
+      const onValid = jest.fn();
+      const onInvalid = jest.fn();
+      const onBeforeValidate = jest.fn();
+      const onAfterValidate = jest.fn();
+      const initialData = { test: 'initial' };
+
+      result.current.setValue('test', initialData.test);
+
+      await act(async () => {
+        await result.current.handleSubmit(onValid, onInvalid, {
+          onBeforeValidate,
+          onAfterValidate,
+        })({
+          preventDefault: () => {},
+          persist: () => {},
+        } as React.SyntheticEvent);
+      });
+
+      expect(onBeforeValidate).toHaveBeenCalledTimes(1);
+      // Note: Built-in validation doesn't modify fieldValues passed to onValid unless resolver returns different values
+      expect(onBeforeValidate).toHaveBeenCalledWith(initialData); 
+      expect(onAfterValidate).toHaveBeenCalledTimes(1);
+      expect(onAfterValidate).toHaveBeenCalledWith({}, initialData); // Errors should be empty
+      expect(onValid).toHaveBeenCalledTimes(1);
+      expect(onInvalid).not.toHaveBeenCalled();
+      // Check execution order (crude check)
+      // expect(onBeforeValidate).toHaveBeenCalledBefore(onValid); // Removed matcher
+      // expect(onAfterValidate).toHaveBeenCalledBefore(onValid); // Removed matcher
+    });
+
+    it('should call onBeforeValidate before validation and onAfterValidate after validation (invalid case)', async () => {
+      const { result } = renderHook(() => useForm<{ test: string }>());
+      const onValid = jest.fn();
+      const onInvalid = jest.fn();
+      const onBeforeValidate = jest.fn();
+      const onAfterValidate = jest.fn();
+      const initialData = { test: '' }; // This will be invalid
+
+      result.current.register('test', { required: true });
+      result.current.setValue('test', initialData.test);
+
+      await act(async () => {
+        await result.current.handleSubmit(onValid, onInvalid, {
+          onBeforeValidate,
+          onAfterValidate,
+        })({
+          preventDefault: () => {},
+          persist: () => {},
+        } as React.SyntheticEvent);
+      });
+
+      expect(onBeforeValidate).toHaveBeenCalledTimes(1);
+      expect(onBeforeValidate).toHaveBeenCalledWith(initialData);
+      expect(onAfterValidate).toHaveBeenCalledTimes(1);
+      // Make assertion more specific to the required error type
+      expect(onAfterValidate).toHaveBeenCalledWith(
+        expect.objectContaining({ test: expect.objectContaining({ type: 'required' }) }),
+        initialData,
+      );
+      expect(onValid).not.toHaveBeenCalled();
+      expect(onInvalid).toHaveBeenCalledTimes(1);
+      // Check execution order
+      // expect(onBeforeValidate).toHaveBeenCalledBefore(onInvalid); // Removed matcher
+      // expect(onAfterValidate).toHaveBeenCalledBefore(onInvalid); // Removed matcher
+    });
+
+    it('should await async validation hooks', async () => {
+      const { result } = renderHook(() => useForm<{ test: string }>());
+      const onValid = jest.fn();
+      const onBeforeValidate = jest.fn().mockResolvedValue(undefined);
+      const onAfterValidate = jest.fn().mockResolvedValue(undefined);
+
+      await act(async () => {
+        await result.current.handleSubmit(onValid, undefined, {
+          onBeforeValidate,
+          onAfterValidate,
+        })({
+          preventDefault: () => {},
+          persist: () => {},
+        } as React.SyntheticEvent);
+      });
+
+      expect(onBeforeValidate).toHaveBeenCalledTimes(1);
+      expect(onAfterValidate).toHaveBeenCalledTimes(1);
+      expect(onValid).toHaveBeenCalledTimes(1);
+      // Check execution order
+      // expect(onBeforeValidate).toHaveBeenCalledBefore(onValid); // Removed matcher
+      // expect(onAfterValidate).toHaveBeenCalledBefore(onValid); // Removed matcher
+    });
+  });
+
   it('should not provide internal errors reference to onInvalid callback', async () => {
     const { result } = renderHook(() =>
       useForm<{
