diff --git a/src/logic/createFormControl.ts b/src/logic/createFormControl.ts
index f7079332..4fa17575 100644
--- a/src/logic/createFormControl.ts
+++ b/src/logic/createFormControl.ts
@@ -1097,7 +1097,8 @@ export function createFormControl<
   };
 
   const handleSubmit: UseFormHandleSubmit<TFieldValues> =
-    (onValid, onInvalid) => async (e) => {
+    (onValid, onInvalid, options) => async (e?, context?) => {
+      let onValidError: Error | undefined = undefined;
       if (e) {
         e.preventDefault && e.preventDefault();
         e.persist && e.persist();
@@ -1108,36 +1109,107 @@ export function createFormControl<
         isSubmitting: true,
       });
 
-      if (_options.resolver) {
-        const { errors, values } = await _executeSchema();
-        _formState.errors = errors;
-        fieldValues = values;
-      } else {
-        await executeBuiltInValidation(_fields);
+      // Feature 3: onBeforeValidate callback
+      if (options?.onBeforeValidate) {
+        try {
+          await options.onBeforeValidate(fieldValues);
+        } catch (error) {
+          console.error(`Error in onBeforeValidate: ${error}`);
+        }
       }
 
-      unset(_formState.errors, 'root');
+      try {
+        if (_options.resolver) {
+          const { errors, values } = await _executeSchema();
+          _formState.errors = errors;
+          fieldValues = values;
+        } else {
+          await executeBuiltInValidation(_fields);
+        }
 
-      if (isEmptyObject(_formState.errors)) {
-        _subjects.state.next({
-          errors: {},
-        });
-        await onValid(fieldValues as TFieldValues, e);
-      } else {
-        if (onInvalid) {
-          await onInvalid({ ..._formState.errors }, e);
+        unset(_formState.errors, 'root');
+
+        // Feature 3: onAfterValidate callback
+        if (options?.onAfterValidate) {
+          try {
+            await options.onAfterValidate(_formState.errors, fieldValues);
+          } catch (error) {
+            console.error(`Error in onAfterValidate: ${error}`);
+          }
+        }
+
+        const validationPassed = isEmptyObject(_formState.errors);
+        
+        // Feature 5: shouldSubmit callback
+        let shouldProceed = true;
+        if (options?.shouldSubmit) {
+          try {
+            shouldProceed = options.shouldSubmit(_formState);
+          } catch (error) {
+            console.error(`Error in shouldSubmit callback: ${error}`);
+            shouldProceed = false;
+          }
+        }
+
+        if (shouldProceed) {
+          if (validationPassed) {
+            _subjects.state.next({
+              errors: {},
+            });
+
+            // Feature 6: transformData callback with context
+            let dataToPassToOnValid = fieldValues;
+            if (options?.transformData) {
+              try {
+                dataToPassToOnValid = await options.transformData(fieldValues, context);
+              } catch (error) {
+                onValidError = error as Error;
+                setError('root.transform', { type: 'transform', message: (error as Error)?.message });
+              }
+            }
+
+            if (onValid && !onValidError) {
+              try {
+                await onValid(dataToPassToOnValid as any, e, context);
+              } catch (error) {
+                onValidError = error as Error;
+              }
+            }
+          } else {
+            if (onInvalid) {
+              await onInvalid({ ..._formState.errors }, e, context);
+            }
+            // Feature 4: preventFocusOnError option
+            if (!options?.preventFocusOnError && _options.shouldFocusError) {
+              _focusError();
+              setTimeout(_focusError);
+            }
+          }
+        }
+      } catch (error) {
+        onValidError = error as Error;
+      }
+
+      // Feature 2: onFinally callback
+      if (options?.onFinally) {
+        try {
+          await options.onFinally(_formState);
+        } catch (error) {
+          console.error(`Error in onFinally callback: ${error}`);
         }
-        _focusError();
-        setTimeout(_focusError);
       }
 
       _subjects.state.next({
         isSubmitted: true,
         isSubmitting: false,
-        isSubmitSuccessful: isEmptyObject(_formState.errors),
+        isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
         submitCount: _formState.submitCount + 1,
         errors: _formState.errors,
       });
+
+      if (onValidError) {
+        throw onValidError;
+      }
     };
 
   const resetField: UseFormResetField<TFieldValues> = (name, options = {}) => {
diff --git a/src/types/form.ts b/src/types/form.ts
index 2f20133e..c07f7e4a 100644
--- a/src/types/form.ts
+++ b/src/types/form.ts
@@ -71,9 +71,10 @@ export type ValidationModeFlags = {
 
 export type CriteriaMode = 'firstError' | 'all';
 
-export type SubmitHandler<TFieldValues extends FieldValues> = (
+export type SubmitHandler<TFieldValues extends FieldValues, TSubmitContext = unknown> = (
   data: TFieldValues,
   event?: React.BaseSyntheticEvent,
+  context?: TSubmitContext,
 ) => unknown | Promise<unknown>;
 
 export type FormSubmitHandler<TFieldValues extends FieldValues> = (payload: {
@@ -84,9 +85,10 @@ export type FormSubmitHandler<TFieldValues extends FieldValues> = (payload: {
   method?: 'post' | 'put' | 'delete';
 }) => unknown | Promise<unknown>;
 
-export type SubmitErrorHandler<TFieldValues extends FieldValues> = (
+export type SubmitErrorHandler<TFieldValues extends FieldValues, TSubmitContext = unknown> = (
   errors: FieldErrors<TFieldValues>,
   event?: React.BaseSyntheticEvent,
+  context?: TSubmitContext,
 ) => unknown | Promise<unknown>;
 
 export type SetValueConfig = Partial<{
@@ -628,14 +630,23 @@ export type UseFormUnregister<TFieldValues extends FieldValues> = (
 export type UseFormHandleSubmit<
   TFieldValues extends FieldValues,
   TTransformedValues extends FieldValues | undefined = undefined,
+  TSubmitContext = unknown,
 > = (
   onValid: TTransformedValues extends undefined
-    ? SubmitHandler<TFieldValues>
+    ? SubmitHandler<TFieldValues, TSubmitContext>
     : TTransformedValues extends FieldValues
-    ? SubmitHandler<TTransformedValues>
+    ? SubmitHandler<TTransformedValues, TSubmitContext>
     : never,
-  onInvalid?: SubmitErrorHandler<TFieldValues>,
-) => (e?: React.BaseSyntheticEvent) => Promise<void>;
+  onInvalid?: SubmitErrorHandler<TFieldValues, TSubmitContext>,
+  options?: {
+    onBeforeValidate?: (data: TFieldValues) => Promise<void> | void;
+    onAfterValidate?: (errors: FieldErrors<TFieldValues>, data: TFieldValues) => Promise<void> | void;
+    preventFocusOnError?: boolean;
+    shouldSubmit?: (formState: FormState<TFieldValues>) => boolean;
+    onFinally?: (formState: FormState<TFieldValues>) => void | Promise<void>;
+    transformData?: (data: TFieldValues, context?: TSubmitContext) => any | Promise<any>;
+  },
+) => (e?: React.BaseSyntheticEvent, context?: TSubmitContext) => Promise<void>;
 
 /**
  * Reset a field state and reference.
