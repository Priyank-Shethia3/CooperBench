diff --git a/src/__tests__/useForm/handleSubmit.test.tsx b/src/__tests__/useForm/handleSubmit.test.tsx
index a5d98cf0..b76fbb8a 100644
--- a/src/__tests__/useForm/handleSubmit.test.tsx
+++ b/src/__tests__/useForm/handleSubmit.test.tsx
@@ -524,4 +524,108 @@ describe('handleSubmit', () => {
 
     await waitFor(() => expect(onSubmit).toBeCalled());
   });
+
+  describe('with shouldSubmit callback', () => {
+    it('should proceed with onValid when shouldSubmit is true', async () => {
+      const { result } = renderHook(() => useForm());
+      const onValid = jest.fn();
+      const onInvalid = jest.fn();
+      const shouldSubmit = jest.fn(() => true);
+
+      await act(async () => {
+        await result.current.handleSubmit(onValid, onInvalid, {
+          shouldSubmit,
+        })({ preventDefault: () => {}, persist: () => {} } as any);
+      });
+
+      expect(shouldSubmit).toHaveBeenCalledTimes(1);
+      expect(onValid).toHaveBeenCalledTimes(1);
+      expect(onInvalid).not.toHaveBeenCalled();
+    });
+
+    it('should skip onValid when shouldSubmit returns false (validation passes)', async () => {
+      const { result } = renderHook(() => useForm());
+      const onValid = jest.fn();
+      const onInvalid = jest.fn();
+      const shouldSubmit = jest.fn(() => false);
+
+      await act(async () => {
+        await result.current.handleSubmit(onValid, onInvalid, {
+          shouldSubmit,
+        })({ preventDefault: () => {}, persist: () => {} } as any);
+      });
+
+      expect(shouldSubmit).toHaveBeenCalledTimes(1);
+      expect(onValid).not.toHaveBeenCalled();
+      expect(onInvalid).not.toHaveBeenCalled();
+      expect(result.current.formState.isSubmitSuccessful).toBe(false);
+    });
+
+    it('should skip onInvalid when shouldSubmit returns false (validation fails)', async () => {
+      const { result } = renderHook(() => useForm<{ test: string }>());
+      result.current.register('test', { required: true }); // Ensure validation fails
+      const onValid = jest.fn();
+      const onInvalid = jest.fn();
+      const shouldSubmit = jest.fn(() => false);
+
+      await act(async () => {
+        await result.current.handleSubmit(onValid, onInvalid, {
+          shouldSubmit,
+        })({ preventDefault: () => {}, persist: () => {} } as any);
+      });
+
+      expect(shouldSubmit).toHaveBeenCalledTimes(1);
+      expect(onValid).not.toHaveBeenCalled();
+      expect(onInvalid).not.toHaveBeenCalled();
+      expect(result.current.formState.isSubmitSuccessful).toBe(false);
+    });
+
+    it('should call shouldSubmit with formState after validation', async () => {
+      const { result } = renderHook(() => useForm<{ test: string }>());
+      result.current.register('test', { required: true }); // Validation will fail
+      const onValid = jest.fn();
+      const onInvalid = jest.fn();
+      const shouldSubmit = jest.fn(() => true);
+
+      await act(async () => {
+        await result.current.handleSubmit(onValid, onInvalid, {
+          shouldSubmit,
+        })({ preventDefault: () => {}, persist: () => {} } as any);
+      });
+
+      expect(shouldSubmit).toHaveBeenCalledTimes(1);
+      expect(shouldSubmit).toHaveBeenCalledWith(expect.objectContaining({
+        errors: expect.objectContaining({ test: expect.objectContaining({ type: 'required' }) }),
+        isValid: false, // Since validation failed
+      }));
+      expect(onInvalid).toHaveBeenCalledTimes(1); // Should still call onInvalid if shouldSubmit is true
+    });
+
+    // Test interaction with onFinally (assuming Feature 2 structure)
+    it('should call onFinally even if shouldSubmit returns false', async () => {
+      const { result } = renderHook(() => useForm());
+      const onValid = jest.fn();
+      const onInvalid = jest.fn();
+      const onFinally = jest.fn(); // Mock onFinally if Feature 2 is merged/present
+      const shouldSubmit = jest.fn(() => false);
+
+      // Modification needed here if F2 is present to pass onFinally
+      // Example assuming F2 adds it as 3rd arg:
+      // await result.current.handleSubmit(onValid, onInvalid, onFinally, { shouldSubmit, ... }) 
+      // For now, simulate passing it in the options object if F3 structure is assumed:
+      await act(async () => {
+        await result.current.handleSubmit(onValid, onInvalid, {
+           shouldSubmit,
+           // Simulate onFinally being part of options if needed, 
+           // otherwise this test needs adjustment based on F2's actual signature
+           onFinally: onFinally 
+        })({ preventDefault: () => {}, persist: () => {} } as any);
+      });
+
+      expect(shouldSubmit).toHaveBeenCalledTimes(1);
+      expect(onValid).not.toHaveBeenCalled();
+      expect(onInvalid).not.toHaveBeenCalled();
+      expect(onFinally).toHaveBeenCalledTimes(1); // Assuming onFinally is called
+    });
+  });
 });
