diff --git a/src/logic/createFormControl.ts b/src/logic/createFormControl.ts
index f7079332..f200fc8d 100644
--- a/src/logic/createFormControl.ts
+++ b/src/logic/createFormControl.ts
@@ -1097,44 +1097,69 @@ export function createFormControl<
   };
 
   const handleSubmit: UseFormHandleSubmit<TFieldValues> =
-    (onValid, onInvalid) => async (e) => {
+    (onValid, onInvalid, options) => async (e) => {
       if (e) {
         e.preventDefault && e.preventDefault();
         e.persist && e.persist();
       }
       let fieldValues = cloneObject(_formValues);
+      let transformError: Error | null = null;
 
       _subjects.state.next({
         isSubmitting: true,
       });
 
-      if (_options.resolver) {
-        const { errors, values } = await _executeSchema();
-        _formState.errors = errors;
-        fieldValues = values;
-      } else {
-        await executeBuiltInValidation(_fields);
-      }
+      try {
+        if (_options.resolver) {
+          const { errors, values } = await _executeSchema();
+          _formState.errors = errors;
+          fieldValues = values;
+        } else {
+          await executeBuiltInValidation(_fields);
+        }
 
-      unset(_formState.errors, 'root');
+        unset(_formState.errors, 'root');
 
-      if (isEmptyObject(_formState.errors)) {
-        _subjects.state.next({
-          errors: {},
-        });
-        await onValid(fieldValues as TFieldValues, e);
-      } else {
-        if (onInvalid) {
-          await onInvalid({ ..._formState.errors }, e);
+        if (isEmptyObject(_formState.errors)) {
+          _subjects.state.next({
+            errors: {},
+          });
+
+          let dataToPassToOnValid = fieldValues;
+
+          if (options?.transformData) {
+            try {
+              dataToPassToOnValid = await options.transformData(fieldValues);
+              _formState.errors = {}; // Clear errors if transformation is successful
+            } catch (error: any) {
+              transformError = error;
+              setError('root.transform', { type: 'transform', message: error?.message });
+            }
+          }
+
+          if (!transformError) {
+            await onValid(dataToPassToOnValid as any, e);
+          }
+        } else {
+          if (onInvalid) {
+            await onInvalid({ ..._formState.errors }, e);
+          }
+          // Check preventFocusOnError before focusing
+          if (!options?.preventFocusOnError && _options.shouldFocusError) {
+            _focusError();
+            setTimeout(_focusError);
+          }
         }
-        _focusError();
-        setTimeout(_focusError);
+      } catch (error: any) {
+        // Handle errors from onValid/onInvalid/validation itself
+        // Note: We intentionally don't set state here as the submit promise should reject
+        throw error;
       }
 
       _subjects.state.next({
         isSubmitted: true,
         isSubmitting: false,
-        isSubmitSuccessful: isEmptyObject(_formState.errors),
+        isSubmitSuccessful: isEmptyObject(_formState.errors) && !transformError,
         submitCount: _formState.submitCount + 1,
         errors: _formState.errors,
       });
@@ -1320,7 +1345,7 @@ export function createFormControl<
 
   const _resetDefaultValues = () =>
     isFunction(_options.defaultValues) &&
-    _options.defaultValues().then((values) => {
+    _options.defaultValues().then((values: TFieldValues) => {
       reset(values, _options.resetOptions);
       _subjects.state.next({
         isLoading: false,
diff --git a/src/types/form.ts b/src/types/form.ts
index 2f20133e..57834bed 100644
--- a/src/types/form.ts
+++ b/src/types/form.ts
@@ -635,6 +635,10 @@ export type UseFormHandleSubmit<
     ? SubmitHandler<TTransformedValues>
     : never,
   onInvalid?: SubmitErrorHandler<TFieldValues>,
+  options?: {
+      preventFocusOnError?: boolean;
+      transformData?: (data: TFieldValues) => any | Promise<any>;
+  }
 ) => (e?: React.BaseSyntheticEvent) => Promise<void>;
 
 /**

