diff --git a/src/__tests__/useForm/handleSubmit.test.tsx b/src/__tests__/useForm/handleSubmit.test.tsx
index a5d98cf0..5cd1beb6 100644
--- a/src/__tests__/useForm/handleSubmit.test.tsx
+++ b/src/__tests__/useForm/handleSubmit.test.tsx
@@ -524,4 +524,83 @@ describe('handleSubmit', () => {
 
     await waitFor(() => expect(onSubmit).toBeCalled());
   });
+
+  describe('preventFocusOnError option', () => {
+    it('should focus on the first error field by default on invalid submission', async () => {
+      const focusSpy = jest.spyOn(HTMLInputElement.prototype, 'focus');
+      const App = () => {
+        const { register, handleSubmit } = useForm<{ name: string }>();
+        return (
+          <form onSubmit={handleSubmit(() => {})}>
+            <input {...register('name', { required: true })} data-testid="name-input" />
+            <button>Submit</button>
+          </form>
+        );
+      };
+      render(<App />);
+      fireEvent.click(screen.getByRole('button'));
+
+      await waitFor(() => expect(focusSpy).toHaveBeenCalled());
+      focusSpy.mockRestore();
+    });
+
+    it('should NOT focus on the first error field when preventFocusOnError is true', async () => {
+      const focusSpy = jest.spyOn(HTMLInputElement.prototype, 'focus');
+      const App = () => {
+        const { register, handleSubmit } = useForm<{ name: string }>();
+        return (
+          <form onSubmit={handleSubmit(() => {}, undefined, { preventFocusOnError: true })}>
+            <input {...register('name', { required: true })} />
+            <button>Submit</button>
+          </form>
+        );
+      };
+      render(<App />);
+      fireEvent.click(screen.getByRole('button'));
+
+      await waitFor(() => expect(focusSpy).not.toHaveBeenCalled());
+      focusSpy.mockRestore();
+    });
+
+    it('should NOT focus on the first error field when global shouldFocusError is false, regardless of preventFocusOnError', async () => {
+      const focusSpy = jest.spyOn(HTMLInputElement.prototype, 'focus');
+      const App = () => {
+        const { register, handleSubmit } = useForm<{ name: string }>({ shouldFocusError: false });
+        return (
+          // Test with both undefined and false for preventFocusOnError
+          <form onSubmit={handleSubmit(() => {}, undefined, { preventFocusOnError: false })}>
+            <input {...register('name', { required: true })} />
+            <button>Submit</button>
+          </form>
+        );
+      };
+      render(<App />);
+      fireEvent.click(screen.getByRole('button'));
+
+      await waitFor(() => expect(focusSpy).not.toHaveBeenCalled());
+      focusSpy.mockRestore();
+    });
+
+    it('should respect preventFocusOnError even when onInvalid is provided', async () => {
+      const focusSpy = jest.spyOn(HTMLInputElement.prototype, 'focus');
+      const onInvalidCallback = jest.fn();
+      const App = () => {
+        const { register, handleSubmit } = useForm<{ name: string }>();
+        return (
+          <form onSubmit={handleSubmit(() => {}, onInvalidCallback, { preventFocusOnError: true })}>
+            <input {...register('name', { required: true })} />
+            <button>Submit</button>
+          </form>
+        );
+      };
+      render(<App />);
+      fireEvent.click(screen.getByRole('button'));
+
+      await waitFor(() => {
+        expect(onInvalidCallback).toHaveBeenCalled();
+        expect(focusSpy).not.toHaveBeenCalled();
+      });
+      focusSpy.mockRestore();
+    });
+  });
 });
