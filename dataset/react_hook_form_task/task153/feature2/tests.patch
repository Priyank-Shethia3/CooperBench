diff --git a/src/__tests__/useForm/handleSubmit.test.tsx b/src/__tests__/useForm/handleSubmit.test.tsx
index a5d98cf0..8577a704 100644
--- a/src/__tests__/useForm/handleSubmit.test.tsx
+++ b/src/__tests__/useForm/handleSubmit.test.tsx
@@ -386,32 +386,127 @@ describe('handleSubmit', () => {
       expect(onValidCallback).not.toBeCalledTimes(1);
       expect(onInvalidCallback).toBeCalledTimes(1);
     });
+
+    it('should not provide internal errors reference to onInvalid callback', async () => {
+      const { result } = renderHook(() =>
+        useForm<{
+          test: string;
+        }>(),
+      );
+      result.current.register('test', { required: true });
+
+      await act(async () => {
+        await result.current.handleSubmit(
+          () => {},
+          (errors) => {
+            Object.freeze(errors);
+          },
+        )({
+          preventDefault: () => {},
+          persist: () => {},
+        } as React.SyntheticEvent);
+      });
+
+      await act(async () => {
+        expect(() =>
+          result.current.setError('test', { message: 'Not enough', type: 'min' }),
+        ).not.toThrow();
+      });
+    });
   });
 
-  it('should not provide internal errors reference to onInvalid callback', async () => {
-    const { result } = renderHook(() =>
-      useForm<{
-        test: string;
-      }>(),
-    );
-    result.current.register('test', { required: true });
+  describe('with onFinally callback', () => {
+    it('should invoke onFinally after onValid callback when validation passes', async () => {
+      const { result } = renderHook(() => useForm());
+      const onValidCallback = jest.fn();
+      const onInvalidCallback = jest.fn();
+      const onFinallyCallback = jest.fn();
+      let isSubmittingAtFinally = false; // Default to false
 
-    await act(async () => {
-      await result.current.handleSubmit(
-        () => {},
-        (errors) => {
-          Object.freeze(errors);
-        },
-      )({
-        preventDefault: () => {},
-        persist: () => {},
-      } as React.SyntheticEvent);
+      await act(async () => {
+        await result.current.handleSubmit(
+          onValidCallback,
+          onInvalidCallback,
+          (currentState) => {
+            isSubmittingAtFinally = currentState.isSubmitting;
+            onFinallyCallback();
+          },
+        )({
+          preventDefault: () => {},
+          persist: () => {},
+        } as React.SyntheticEvent);
+      });
+
+      expect(onValidCallback).toBeCalledTimes(1);
+      expect(onInvalidCallback).not.toBeCalled();
+      expect(onFinallyCallback).toBeCalledTimes(1);
+      expect(isSubmittingAtFinally).toBe(true); // Should be submitting during onFinally
+      expect(result.current.formState.isSubmitting).toBe(false); // Should be false after handleSubmit finishes
     });
 
-    await act(async () => {
-      expect(() =>
-        result.current.setError('test', { message: 'Not enough', type: 'min' }),
-      ).not.toThrow();
+    it('should invoke onFinally after onInvalid callback when validation fails', async () => {
+      const { result } = renderHook(() => useForm<{ test: string }>());
+      result.current.register('test', { required: true });
+      const onValidCallback = jest.fn();
+      const onInvalidCallback = jest.fn();
+      const onFinallyCallback = jest.fn();
+      let isSubmittingAtFinally = false;
+
+      await act(async () => {
+        await result.current.handleSubmit(
+          onValidCallback,
+          onInvalidCallback,
+          (currentState) => {
+            isSubmittingAtFinally = currentState.isSubmitting;
+            onFinallyCallback();
+          },
+        )({
+          preventDefault: () => {},
+          persist: () => {},
+        } as React.SyntheticEvent);
+      });
+
+      expect(onValidCallback).not.toBeCalled();
+      expect(onInvalidCallback).toBeCalledTimes(1);
+      expect(onFinallyCallback).toBeCalledTimes(1);
+      expect(isSubmittingAtFinally).toBe(true);
+      expect(result.current.formState.isSubmitting).toBe(false);
+    });
+
+    it('should invoke onFinally even when onValid throws an error', async () => {
+      const errorMsg = 'onValid error';
+      const { result } = renderHook(() => useForm());
+      const onValidCallback = jest.fn().mockRejectedValue(new Error(errorMsg));
+      const onInvalidCallback = jest.fn();
+      const onFinallyCallback = jest.fn();
+      let isSubmittingAtFinally = false;
+      let caughtError: Error | null = null;
+
+      await act(async () => {
+        try {
+          await result.current.handleSubmit(
+            onValidCallback,
+            onInvalidCallback,
+            (currentState) => {
+              isSubmittingAtFinally = currentState.isSubmitting;
+              onFinallyCallback();
+            },
+          )({
+            preventDefault: () => {},
+            persist: () => {},
+          } as React.SyntheticEvent);
+        } catch (error) {
+          caughtError = error as Error;
+        }
+      });
+
+      expect(onValidCallback).toBeCalledTimes(1);
+      expect(onInvalidCallback).not.toBeCalled();
+      expect(onFinallyCallback).toBeCalledTimes(1);
+      expect(isSubmittingAtFinally).toBe(true);
+      expect(result.current.formState.isSubmitting).toBe(false);
+      expect(caughtError).not.toBeNull();
+      expect(caughtError?.message).toBe(errorMsg); // Ensure the error still propagates
     });
   });
 
